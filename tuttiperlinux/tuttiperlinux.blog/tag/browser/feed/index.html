<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>browser &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/browser/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Mon, 19 Jan 2015 08:08:27 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>browser &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Bloccare la pubblicita&#8217; senza plug-in</title>
		<link>https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/</link>
					<comments>https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sun, 28 Dec 2014 11:36:52 +0000</pubDate>
				<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[Tips & Tricks]]></category>
		<category><![CDATA[127.0.0.1]]></category>
		<category><![CDATA[adblock]]></category>
		<category><![CDATA[banner]]></category>
		<category><![CDATA[bash]]></category>
		<category><![CDATA[browser]]></category>
		<category><![CDATA[chrome]]></category>
		<category><![CDATA[crontab]]></category>
		<category><![CDATA[extension]]></category>
		<category><![CDATA[google]]></category>
		<category><![CDATA[hosts]]></category>
		<category><![CDATA[linux blog in italiano]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[plugin]]></category>
		<category><![CDATA[schedulazione]]></category>
		<category><![CDATA[script]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=833</guid>

					<description><![CDATA[&#160; Negli ultimi anni i banner pubblicitari presenti nelle pagine di molti siti si sono trasformati in un mostro incontrollato e soprattutto molto invasivo e, a causa dell’abuso da parte di alcuni, sono finiti per diventare la bestia nera di Internet, inducendo numerosi utenti a trovare un modo per bloccarli con i metodi più disparati. &#160; Tra questi figurano &#8230; <a href="https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_836" style="width: 293px" class="wp-caption alignleft"><img aria-describedby="caption-attachment-836" data-attachment-id="836" data-permalink="https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/adblock/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg" data-orig-size="283,178" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="adblock" data-image-description="" data-image-caption="&lt;p&gt;Linux Ad Block&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=283" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=283" class="size-full wp-image-836" src="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=600" alt="Linux Ad Block" srcset="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg 283w, https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=150 150w" sizes="(max-width: 283px) 100vw, 283px"   /><p id="caption-attachment-836" class="wp-caption-text">Linux Ad Block</p></div>
<p>&nbsp;</p>
<p>Negli ultimi anni i banner pubblicitari presenti nelle pagine di molti siti si sono trasformati in un mostro incontrollato e soprattutto molto invasivo e, a causa dell’abuso da parte di alcuni, sono finiti per diventare la bestia nera di Internet, inducendo numerosi utenti a trovare un modo per bloccarli con i metodi più disparati.</p>
<p>&nbsp;</p>
<p>Tra questi figurano ad esempio due note estensioni per browser, ad esempio su Chrome tra i piu&#8217; conosciuti possiamo trovare AdBlock e AdBlock Plus, che svolgono egregiamente il proprio lavoro modificando al volo il foglio di stile delle pagine web impedendone la visualizzazione. D’altra parte questo vantaggio ha un peso materiale: entrambe le estensioni finiscono per appesantire notevolmente il browser, il che potrebbe essere uno svantaggio per molti.</p>
<p>In questo breve articolo verra&#8217; illustrato un metodo efficace per bloccare la visualizzazione dei banner pubblicitari dei più noti circuiti pubblicitari, usando una versione modificata del file <strong>/etc/hosts</strong></p>
<p>&nbsp;</p>
<p><strong>Bloccare la pubblicità senza AdBlock </strong></p>
<p>Il criterio che utilizzeremo è di per se molto semplice, infatti il file /etc/hosts permette di associare manualmente host ad indirizzi IP senza affidarsi alla risoluzione tramite server DNS; grazie al lavoro ed alla costanza di alcuni sviluppatori, è possibile scaricare un file modificato ad-hoc affinché agli host dei più noti banner pubblicitari venga automaticamente associato l&#8217;indirizzo IP 127.0.0.1, ovvero l’indirizzo locale della propria macchina (localhost).  Risultato:<br />
i banner non verranno più visualizzati!</p>
<p>Senza dilungarci in ulteriori spiegazioni procediamo alla modifica: andiamo innanzitutto a creare un backup del file /etc/hosts presente nel nostro sistema operativo, da ripristinare in caso di problemi, dopodiché, andremo a creare uno script per il download/upgrade automatico del file che inseriremo nel nostro crontab.</p>
<p><strong>*Preparazione</strong><br />
Creamo innanzitutto un backup del nostro file /etc/hosts originale da ripristinare in caso di problemi: per farlo, da terminale, digitiamo</p>
<pre># sudo cp /etc/hosts /etc/hosts.bak</pre>
<p>Adesso creiamo lo script che sara&#8217; in grado di scaricare automaticamente il nuovo file host, concedendogli eventualmente una serie di tentativi qualora la connessione ad Internet non fosse subito disponibile, quindi dal nostro terminale digitiamo</p>
<pre># sudo vim /usr/local/bin/adblock.sh</pre>
<p>All’interno del file appena creato inseriamo quanto segue:</p>
<pre>#!/bin/bash

exec 2&gt; /tmp/adblock.log
exec 1&gt;&amp;2
set -x
wget -q -O - 1 --retry-connrefused http://someonewhocares.org/hosts/hosts | grep -P "^(127.0.0.1 |::1 |# )" &gt; /etc/hosts

chmod 644 /etc/hosts</pre>
<p>Salviamo il file ed usciamo dall’editor, dopodiché renderlo eseguibile con il comando</p>
<pre># sudo chmod +x /usr/local/bin/adblock.sh</pre>
<p>Ora facciamo in modo di aggiungere il nostro nuovo script nel crontab del sistema in modo da farlo eseguire, in automatico, almeno ogni 4 ore (la scelta ottimale sta a voi).</p>
<p>Per coloro che non sono soliti ad utilizzare la gestione del crontab facciamo un breve ripasso sulla sua sintassi :</p>
<p id="Esempi_di_sintassi_dei_comandi"><strong>Esempi di sintassi dei comandi cron</strong></p>
<p class="line862">Il file <strong>crontab</strong> deve rispettare una sintassi ben precisa, diversamente il sistema non accetterà le impostazioni. Quello che segue è un esempio generico:<span id="line-37" class="anchor"></span><span id="line-38" class="anchor"></span><span id="line-39" class="anchor"></span></p>
<p><span id="line-1-3" class="anchor"></span>5 3 * * * /usr/bin/apt-get update</p>
<p class="line862">L&#8217;esempio precedente eseguirà il comando <strong>apt-get update</strong> ogni giorno di ogni mese alle ore 03:05 (l&#8217;orario viene indicato nel formato a 24 ore).<span id="line-42" class="anchor"></span><span id="line-43" class="anchor"></span></p>
<p class="line874">La prima parte della voce descrive quando l&#8217;azione deve essere effettuata. Ci sono cinque campi (nell&#8217;esempio precedente, «5 3 * * *»), separati da uno spazio, ognuno dei quali accetta un numero, un asterisco o un testo appropriato. I campi specificano, in ordine (tra parentesi l&#8217;abbreviazione standard):<span id="line-44" class="anchor"></span></p>
<ul>
<li>minuti, da 0 a 59 («m»);<span id="line-45" class="anchor"></span></li>
<li>ore, da 0 a 23 («h»);<span id="line-46" class="anchor"></span></li>
<li>giorno del mese, da 1 a 31 («dom»);<span id="line-47" class="anchor"></span></li>
<li>mese, da 1 a 12 («mon»);<span id="line-48" class="anchor"></span></li>
<li>giorno della settimana, da 0 (domenica) a 6 (sabato) («dow»)</li>
</ul>
<p>&nbsp;</p>
<p class="line874">Quelle che seguono sono alcune varianti della precedente pianificazione d&#8217;esempio:<span id="line-77" class="anchor"></span><span id="line-78" class="anchor"></span></p>
<div>
<table>
<tbody>
<tr>
<td>
<p class="line891"><strong>Stringa</strong></p>
</td>
<td>
<p class="line891"><strong>Descrizione</strong></p>
</td>
</tr>
<tr>
<td>
<p class="line862">«12 03 * * *»</p>
</td>
<td>
<p class="line862">tutte le mattine, più o meno alle 3</p>
</td>
</tr>
<tr>
<td>
<p class="line862">« 12 03 15 * *»</p>
</td>
<td>
<p class="line862">tutti i 15 del mese, alla stessa ora</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«12 03 31 * *»</p>
</td>
<td>
<p class="line862">7 volte l&#8217;anno, alla stessa ora</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«0 12 * * 0»</p>
</td>
<td>
<p class="line862">ogni domenica, a mezzogiorno</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«2 0 * * *»</p>
</td>
<td>
<p class="line862">ogni giorno, più o meno a mezzanotte</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«02 03 * * 1,5»</p>
</td>
<td>
<p class="line862">ogni lunedì e venerdì, alle 3 del mattino circa</p>
</td>
</tr>
</tbody>
</table>
<p>Altri esempi per aiutarvi a capire le varie combinazioni :</p>
<ul>
<li>Esempio 1</li>
</ul>
<pre>1-30 * * * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito ogni giorno, ogni ora e quando i minuti vanno da 1 a 30.</p>
<ul>
<li>Esempio 2</li>
</ul>
<pre>30 * 1-7 * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito i primi sette giorni di ogni mese, ad ogni ora e quando i minuti valgono 30.</p>
<ul>
<li>Esempio 3</li>
</ul>
<pre>00 */2 15 * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito il quindicesimo giorno di ogni mese, ogni due ore.</p>
<ul>
<li>Esempio 4</li>
</ul>
<pre>00 1-9/2 1 5 * /comando/da/eseguire
</pre>
<p>il comando viene eseguito il primo maggio alle 1,00 &#8211; 3,00 &#8211; 5,00 &#8211; 7,00 &#8211; 9,00. Cioè ogni due ore dalle 1,00 alle 9,00.</p>
<ul>
<li>Esempio 5</li>
</ul>
<pre>00 1-10/2 1 5 * /comando/da/eseguire
</pre>
<p>il comando viene eseguito il primo maggio alle 1,00 &#8211; 3,00 &#8211; 5,00 &#8211; 7,00 &#8211; 9,00. Cioè ogni due ore dalle 1,00 alle 10,00. Si noti come l&#8217;ultimo valore utile dell&#8217;intervallo non coincida, in questo caso, con l&#8217;ora in cui viene fatta partire l&#8217;ultima esecuzione giornaliera del comando.</p>
<ul>
<li>Esempio 6</li>
</ul>
<pre>00 13 2,8,14 * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito il secondo, l&#8217;ottavo e il quattordicesimo giorno di ogni mese alle 13.00</p>
<ul>
<li>Esempio 7</li>
</ul>
<pre>30 13 1-15 4,10 * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito i primi quindici giorni di aprile e ottobre alle 13,30.</p>
<ul>
<li>Esempio 8</li>
</ul>
<pre>*/30 13,20 * 1-7,9-12 1-5 /comando/da/eseguire
</pre>
<p>il comando verrà eseguito nei giorni feriali (da lunedì a venerdì) di tutti i mesi tranne agosto, alle 13,00 &#8211; 13,30 &#8211; 20,00 &#8211; 20,30.</p>
<ul>
<li>Esempio 9</li>
</ul>
<pre>00 14,19 1-15 * 5 /comando/da/eseguire
</pre>
<p>il comando verrà eseguito alle 14,00 e alle 19,00 dei primi quindici giorni di ogni mese e anche ogni venerdì.</p>
<p>** Ora per tornare al nostro esempio possiamo editare il file del nostro crontab tramite il comando</p>
<pre># crontab -e</pre>
<p>ed in base agli esempi appena visti la riga di configurazione per far si che lo script venga eseguito ogni 4 ore di ogni giorno dell&#8217;anno sara&#8217; la seguente :</p>
<pre># 00 */4 * * *  /usr/local/bin/adblock.sh</pre>
<p>una volta salvato ed usciti non rimarra&#8217; altro da fare che riavviare il servizio per far si che la modifica diventi operativa</p>
<pre># sudo /etc/init.d/cron restart</pre>
<p>per verificare che effettivamente la schedulazione sia stata inserita verifichiamo tramite il comando</p>
<pre># crontab -l</pre>
<p>Se doveste riscontrare problemi nella gestione della navigazione e voleste tornare alla configurazione iniziale vi bastera&#8217; rieditare il crontab eliminando la stringa inserita e ripristinare il file hosts iniziale di cui avevamo fatto il backup tramite il comando :</p>
<pre># sudo mv /etc/hosts.bak /etc/hosts</pre>
<p>Buon Anno!</p>
<p>#linuxadblocksenzaplugin</p>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg" medium="image">
			<media:title type="html">Linux Ad Block</media:title>
		</media:content>
	</item>
		<item>
		<title>Velocizzare Linux creando un RAM Disk</title>
		<link>https://tuttiperlinux.blog/2014/12/18/velocizzare-linux-creando-un-ram-disk/</link>
					<comments>https://tuttiperlinux.blog/2014/12/18/velocizzare-linux-creando-un-ram-disk/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Thu, 18 Dec 2014 13:23:43 +0000</pubDate>
				<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[Tips & Tricks]]></category>
		<category><![CDATA[browser]]></category>
		<category><![CDATA[cache]]></category>
		<category><![CDATA[debian]]></category>
		<category><![CDATA[filesystem]]></category>
		<category><![CDATA[firefox]]></category>
		<category><![CDATA[linuxblog]]></category>
		<category><![CDATA[ram]]></category>
		<category><![CDATA[ramdisk]]></category>
		<category><![CDATA[tmpfs]]></category>
		<category><![CDATA[ubuntu]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=812</guid>

					<description><![CDATA[Ram Disk o Ram Drive è una funzionalità disponibile in qualsiasi distribuzione Linux dedicata a poter utilizzare la RAM come un hard disk o memoria di massa. Grazie a Ram Disk potremo emulare un&#8217;hard disk utilizzando la nostra RAM rendendo cosi&#8217; più veloce l&#8217;avvio di applicazioni oppure dello stesso sistema operativo. La RAM difatti è &#8230; <a href="https://tuttiperlinux.blog/2014/12/18/velocizzare-linux-creando-un-ram-disk/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_813" style="width: 290px" class="wp-caption alignleft"><img aria-describedby="caption-attachment-813" data-attachment-id="813" data-permalink="https://tuttiperlinux.blog/2014/12/18/velocizzare-linux-creando-un-ram-disk/ramdisk/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png" data-orig-size="280,280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ramdisk" data-image-description="" data-image-caption="&lt;p&gt;Veloci con le RAM Disk&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png?w=280" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png?w=280" class="size-full wp-image-813" src="https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png?w=600" alt="Veloci con le RAM Disk" srcset="https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png 280w, https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png?w=150 150w" sizes="(max-width: 280px) 100vw, 280px"   /><p id="caption-attachment-813" class="wp-caption-text">Veloci con le RAM Disk</p></div>
<p><strong>Ram Disk</strong> o <strong>Ram Drive</strong> è una funzionalità disponibile in qualsiasi distribuzione Linux dedicata a poter utilizzare la RAM come un hard disk o memoria di massa.<br />
Grazie a Ram Disk potremo emulare un&#8217;hard disk utilizzando la nostra RAM rendendo cosi&#8217; più veloce l&#8217;avvio di applicazioni oppure dello stesso sistema operativo.</p>
<p>La RAM difatti è <strong>molto più veloce</strong> di un qualsiasi hard disk, quindi utilizzando questa funzionalità le applicazioni potranno utilizzare la nostra ram per caricare dati, o altro, rendendo più veloce l&#8217;avvio e più reattivo il loro utilizzo.</p>
<p>*N.B.: Logicamente i dati salvati nella ram Disk andranno persi ad ogni riavvio, inoltre l&#8217;uso di questa funzionalità è consigliato solo se abbiamo più di 2 Gb di Ram altrimenti rischiamo di rimanere senza RAM da poter utilizzare per la gestione del nostro sistema operativo.</p>
<p>In questo esempio vedremo come creare e attivare una Ram Disk su Ubuntu (Debian e derivate).<br />
N.B.: Prima di creare la cartella sul filesystem destinata alla Ram disk, lanciamo da terminale il comando:</p>
<pre>free</pre>
<p>in modo da liberare la memoria <strong>RAM non utilizzata</strong> sulla nostra distribuzione.</p>
<p><strong>1</strong>. Creare una RamDisk</p>
<p>Per creare una RAMDISK dovremo creare una cartella che fungerà da alias per poter navigare e utilizzare lo spazio della RAM per farlo basta digitare da terminale:</p>
<pre>sudo mkdir -p /opt/ramdisk</pre>
<pre>sudo chmod -R 777 /opt/ramdisk</pre>
<p>la cartella sarà denominata ramdisk e la troveremo all&#8217;interno della cartella opt del nostro sistema.</p>
<p><strong>2</strong>. Montare una RamDisk</p>
<p>A questo punto dovremo montare la cartella per un&#8217;area di archiviazione temporanea tmpfs che utilizza RAM invece di spazio sul disco rigido per farlo digitiamo da terminale:</p>
<pre>sudo mount -t tmpfs -o size=2048M tmpfs /opt/ramdisk</pre>
<p>come possiamo vedere abbiamo dato 2GB (2048M) possiamo variare il size conforme lo spazio disponibile nella nostra RAM.</p>
<p>Fatto questo provate ad avviare alcune applicazioni e dovreste notare un leggero miglioramento nel loro utilizzo.</p>
<p><strong>3</strong>. Smontare la RamDisk</p>
<p>Per smontare la RamDisk basta digitare:</p>
<pre>sudo umount /opt/ramdisk</pre>
<p>oppure basta riavviare.</p>
<p>E&#8217; possibile velocizzare questa procedura creando un&#8217;alias o script da avviare all&#8217;avvio del sistema.</p>
<p>Per effettuare il <strong>montaggio automatico</strong> ogni volta che avviamo la nostra distribuzione, dobbiamo aggiungere una riga nel file <em>/etc/fstab</em>. Apriamo quindi il file:</p>
<pre># sudo gedit /etc/fstab</pre>
<p>e aggiungiamo la seguente stringa:</p>
<pre>tmpfs /opt/ramdisk tmpfs nodev,nosuid,noexec,nodiratime,size=2048M 0  0</pre>
<p>Una volta terminata la configurazione possiamo montare la partizione con il comando :</p>
<pre>sudo mount -t tmpfs -o size=2048M tmpfs /opt/ramdisk</pre>
<p>Facciamo ora un esempio pratico per vedere se e come funziona la nostra modifica.</p>
<p><strong>Premessa</strong>: Se la nostra attività ci costringe a lavorare tutto il giorno con un browser, non bisogna sottovalutare l’idea di ottimizzare l’utilizzo di questo strumento.</p>
<p>Vediamo quindi come utilizzare la RAM Disk appena creata per ospitare ad esempio la cache del browser <strong>Firefox</strong>.</p>
<p>La procedura è molto semplice, dobbiamo immettere nella barra degli indirizzi il comando <strong>about:config </strong>, fare tasto destro sulla lista e selezionare Nuovo -&gt; Stringa.<br />
Nel nome dobbiamo scrivere <strong>browser.cache.disk.parent_directory</strong> e nel campo valore il percorso della cartella dove si desidera memorizzare la cache, che per noi e&#8217; <strong>/opt/ramdisk</strong>. Infine dobbiamo assicurarsi che la voce <strong>browser.cache.disk.enable</strong> sia <strong>True</strong>, altrimenti possiamo attivarla con un doppio click.</p>
<p>Una volta terminato il tutto riavviamo il browser e facciamo qualche test &#8230;.</p>
<pre>pwd   = /opt/ramdisk#</pre>
<pre>du -sh * = 85M cache2</pre>
<p>Funziona&#8230;!</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/12/18/velocizzare-linux-creando-un-ram-disk/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/12/ramdisk.png" medium="image">
			<media:title type="html">Veloci con le RAM Disk</media:title>
		</media:content>
	</item>
		<item>
		<title>Creare facilmente applicazioni Web su Linux</title>
		<link>https://tuttiperlinux.blog/2014/12/17/creare-facilmente-applicazioni-web-su-linux/</link>
					<comments>https://tuttiperlinux.blog/2014/12/17/creare-facilmente-applicazioni-web-su-linux/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 17 Dec 2014 14:49:07 +0000</pubDate>
				<category><![CDATA[WebServer]]></category>
		<category><![CDATA[browser]]></category>
		<category><![CDATA[chrome]]></category>
		<category><![CDATA[debian]]></category>
		<category><![CDATA[fogger]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[release]]></category>
		<category><![CDATA[ubuntu]]></category>
		<category><![CDATA[webserver]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=808</guid>

					<description><![CDATA[Tra le tante features incluse in Google Chrome / Chromium, Gnome Web, Rekonq ecc troviamo la possibilità di creare facilmente un&#8217;applicazione web da qualsiasi scheda. Questa funzionalità ci consente non solo di avviare velocemente il nostro sito web preferito ma anche risparmiare risorse dato che non andremo a caricare interamente il browser. Funzionalità tanto richiesta &#8230; <a href="https://tuttiperlinux.blog/2014/12/17/creare-facilmente-applicazioni-web-su-linux/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><img loading="lazy" data-attachment-id="809" data-permalink="https://tuttiperlinux.blog/2014/12/17/creare-facilmente-applicazioni-web-su-linux/fogger-create-web/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png" data-orig-size="702,551" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Fogger-create-web" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=600" class="alignleft size-medium wp-image-809" src="https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=300&#038;h=235" alt="Fogger Web Linux in un clic" width="300" height="235" srcset="https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=300&amp;h=235 300w, https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=600&amp;h=470 600w, https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=150&amp;h=118 150w" sizes="(max-width: 300px) 100vw, 300px" />Tra le tante features incluse in Google Chrome / Chromium, Gnome Web, Rekonq ecc troviamo la possibilità di creare facilmente un&#8217;applicazione web da qualsiasi scheda. Questa funzionalità ci consente non solo di avviare velocemente il nostro sito web preferito ma anche risparmiare risorse dato che non andremo a caricare interamente il browser. Funzionalità tanto richiesta ma attualmente non inclusa in Mozilla Firefox, un&#8217;alternativa arriva proprio dai developer Linux attraverso un semplice software.</p>
<p>Per creare facilmente un&#8217;applicazione web con Linux possiamo utilizzare <strong>Fogger</strong>, software open source che ci consente di creare facilmente un&#8217;applicazione web da qualsiasi sito, blog, forum ecc attraverso una semplice interfaccia grafica.<br />
Fogger ci consente di creare un&#8217;applicazione web da avviare velocemente nel nostro menu, una volta avviata avremo una finestra con solo il nostro sito web, non è inclusa alcuna barra degli strumenti ecc possiamo comunque ricaricare, andare avanti o indietro attraverso il menu contestuale o il menu dell&#8217;applicazione. Tutto questo ci consentirà di velocizzare l&#8217;avvio di social network, forum e altri siti preferiti senza utilizzare alcun browser richiedendo meno cpu e memoria ram.</p>
<p>&#8211; INSTALLARE FOGGER<br />
<strong>N.B.: Fogger</strong> è un software che non viene aggiornato da alcuni anni ma che funziona correttamente anche con le attuali distribuzioni Linux.</p>
<p>Per installare Fogger in Ubuntu e derivate basta scaricare il pacchetto deb da <a href="http://ppa.launchpad.net/loneowais/fogger/ubuntu/pool/main/f/fogger/">questa pagina</a> (per Ubuntu 14.04 e versioni successive basta scaricare il pacchetto per la release 13.10).</p>
<p>Prerequisiti: prima d&#8217;installare il pacchetto appena scaricato, accertarsi di avere i seguenti pacchetti :<br />
<strong>python-xlib</strong> &amp; <strong>gir1.2-rsvg-2.0</strong> altrimenti installarli con un semplice</p>
<pre># sudo apt-get install python-xlib gir1.2-rsvg-2.0</pre>
<p>Una volta installato, basta avviare Fogger da menu, ci si aprirà una finestra di dialogo nella quale inserire l&#8217;url, nome e icona dell&#8217;applicazione web da creare per poi cliccare sul tasto Create. Al termine basta avviare l&#8217;applicazione web da menu, per rimuoverla basta cliccare da file manager Ctrl + h .</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/12/17/creare-facilmente-applicazioni-web-su-linux/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/12/fogger-create-web.png?w=300" medium="image">
			<media:title type="html">Fogger Web Linux in un clic</media:title>
		</media:content>
	</item>
		<item>
		<title>Puppet: automatizziamo e gestiamo ogni task</title>
		<link>https://tuttiperlinux.blog/2014/11/30/puppet-automatizziamo-e-gestiamo-ogni-task/</link>
					<comments>https://tuttiperlinux.blog/2014/11/30/puppet-automatizziamo-e-gestiamo-ogni-task/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sun, 30 Nov 2014 15:59:27 +0000</pubDate>
				<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[aix]]></category>
		<category><![CDATA[bashboard]]></category>
		<category><![CDATA[browser]]></category>
		<category><![CDATA[bsd]]></category>
		<category><![CDATA[certificato]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[puppet]]></category>
		<category><![CDATA[puppetlabs]]></category>
		<category><![CDATA[ruby]]></category>
		<category><![CDATA[solaris]]></category>
		<category><![CDATA[ubuntu blog]]></category>
		<category><![CDATA[virtual machine]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=708</guid>

					<description><![CDATA[Introduzione a Puppet Puppet è un software open source, scritto in linguaggio Ruby, che permette la gestione automatizzata e centralizzata di un&#8217;infrastruttura di sistemi Linux e Unix, essendo disponibile per tutte le principali distribuzioni Linux, ma anche per le diverse varianti di BSD oltre che Solaris e AIX. Con Puppet è possibile gestire praticamente ogni &#8230; <a href="https://tuttiperlinux.blog/2014/11/30/puppet-automatizziamo-e-gestiamo-ogni-task/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_716" style="width: 274px" class="wp-caption alignleft"><a href="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png"><img loading="lazy" aria-describedby="caption-attachment-716" data-attachment-id="716" data-permalink="https://tuttiperlinux.blog/2014/11/30/puppet-automatizziamo-e-gestiamo-ogni-task/puppetlabs/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png" data-orig-size="275,275" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="puppetlabs" data-image-description="" data-image-caption="&lt;p&gt;Puppet Labs&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png?w=275" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png?w=275" class=" wp-image-716" src="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png?w=264&#038;h=264" alt="Puppet Labs" width="264" height="264" srcset="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png?w=264&amp;h=264 264w, https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png?w=150&amp;h=150 150w, https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png 275w" sizes="(max-width: 264px) 100vw, 264px" /></a><p id="caption-attachment-716" class="wp-caption-text">Puppet Labs</p></div>
<h4><strong>Introduzione a Puppet</strong></h4>
<p>Puppet è un software open source, scritto in linguaggio Ruby, che permette la gestione automatizzata e centralizzata di un&#8217;infrastruttura di sistemi Linux e Unix, essendo disponibile per tutte le principali distribuzioni Linux, ma anche per le diverse varianti di BSD oltre che Solaris e AIX.</p>
<p>Con Puppet è possibile gestire praticamente ogni risorsa di un sistema: programmi da insallare, servizi da avviare, file di configurazione con contenuti diversi a seconda di diverse logiche, utenti, cron jobs, mount point, esecuzione di comandi specifici ecc.<br />
Praticamente permette di automatizzare ogni attività sistemistica cambiando di fatto il modo con sui si opera su sun server.</p>
<p>La logica di Puppet è di definire lo stato di un sistema e fare in modo che questo sia tale ogni volta che il client Puppet viene eseguito.<br />
La prima volta che lo si esegue, vengono installati pacchetti, avviati servizi, modificati file di configurazione secondo quanto definito sul <strong>PuppetMaster,</strong> le volte successive, se non sono intervenute modifiche manuali sul sistema, o cambiamenti delle configurazioni sul master, non dovrebbe cambiare nulla, altrimenti verranno upgradati eventuali file di configurazione o servizi, cosi come indicato sul PuppetMaster.<br />
Questo è un concetto importante per il sistemista, e&#8217; un vero e proprio cambio di paradigma sul suo modo di operare, poiche&#8217; in un sistema gestito con Puppet non si devono modificare a mano i file che Puppet gestisce, perchè questi vengono aggiornati al successivo collegamento/verifica con il Master e, visto che nelle condizioni ideali, Puppet gestisce tutte le risorse di un sistema (non è obbligatorio che sia così, ma è comunque consigliabile), di fatto, salvo in casi di emergenza, un sistemista non dovrà mai intervenire a mano sui suoi server.</p>
<p>Se da un lato tutto questo può risultare laborioso e in qualche modo &#8220;innaturale&#8221; nella gestione dall&#8217;altro comporta una serie di <strong>vantaggi clamorosi</strong>:<br />
&#8211; Si può configurare il profilo di un server ed applicarlo a decine o centinaia di host, tutti uguali, tutti allineati, tutti configurati con la stessa logica.<br />
&#8211; La procedura di setup e configurazione di un sistema è riproducibile, evitando cosi&#8217; di trovarsi a gestire dei sistemi che poi non si sanno più reinstallare.<br />
&#8211; E&#8217; facile e quasi intrinseco prevedere per ogni host il suo corrispettivo di sviluppo, collaudo e produzione, non avendo limiti nel numero di ambienti previsti e avendo la certezza di avere i sistemi fra di loro allineati.<br />
&#8211; I manifest di puppet sono generalmente gestiti con un sistema di versioning (git, subversion, cvs vanno tutti bene), questo comporta automaticamente una gestione formale, reversibile, documentata e tracciata delle modifiche fatte sui sistemi.</p>
<p>Il risultato è che, già in infrastrutture di qualche decine di host, Puppet diventa uno strumento unico e insostituibile per una gestione rapida ed efficace del parco macchine, lo sforzo inizlae di definizione delle sue configurazioni viene ampiamente ripagato nel tempo con tempi di gestione e setup dei sistemi enormemente ridotti.<br />
Insomma, con Puppet ci si può dedicare al miglioramento e l&#8217;affinamento della propria infrastruttura risparmiando il tempo speso in attività ordinarie ripetitive e noiose.</p>
<p>Per chi volesse provare le potenzialita&#8217; di Puppet oggi e&#8217; possibile scaricare una versione Free Trial direttamente dal sito del produttore [<a href="http://puppetlabs.com/download-puppet-enterprise">To try Puppet Enterprise for free on up to 10 nodes</a>].<br />
Vi verranno richieste soltanto alcune informazioni formali, prima di poter ottenere il file installabile per la versione della nostra distro (sia 32 che 64 bit).<br />
Potrete cosi&#8217; scaricare il pacchetto puppet-&lt;vostra versione&gt;.tar.gz sul vostro Puppet Server; una volta estratto il contenuto del file, ad esempio sotto <strong>/opt </strong>, per lanciare l&#8217;installazione del pacchetto vi bastera&#8217; lanciare lo script :</p>
<pre>cd /opt/puppet

# sudo ./puppet-enterprise-installer</pre>
<p>L&#8217;installazione procedera&#8217; sostanzialmente da sola, all&#8217;inizio ci verra&#8217; soltanto chiesta la conferma (premendo <strong>Y</strong> ) per avviare il processo d&#8217;installazione e copia dei file necessari, dopodiche&#8217; bastera&#8217; avere un po&#8217; di pazienza.</p>
<p>Altrimenti e&#8217; possibile questa ulteriore strada (ad esempio per un sistema Ubuntu 14.x)</p>
<pre class="prettyprint"><code><span class="pln">wget https</span><span class="pun">:</span><span class="com">//apt.puppetlabs.com/puppetlabs-release-trusty.deb
</span></code><span class="pln">sudo gdebi</span><span class="pln"> puppetlabs</span><span class="pun">-</span><span class="pln">release</span><span class="pun">-</span><span class="pln">trusty</span><span class="pun">.</span><span class="pln">deb 
</span><span class="pln">sudo apt</span><span class="pun">-</span><span class="kwd">get</span><span class="pln"> update 
</span><span class="pln">sudo aptitude install puppet</span><span class="pun">-</span><span class="pln">common</span><span class="pun">=</span><span class="lit">3.7</span><span class="pun">.3</span><span class="pun">-</span><span class="lit">1puppetlabs1</span><span class="pln"> puppet</span><span class="pun">=</span><span class="lit">3.7</span><span class="pun">.3</span><span class="pun">-</span><span class="lit">1puppetlabs1
sudo apt-get install puppetmaster-passenger</span></pre>
<p>Nel caso in cui invece dobbiate solo fare un upgrade all&#8217;ultima versione vi bastera&#8217; eseguire :</p>
<pre>$ sudo apt-get update
$ sudo puppet resource package puppetmaster ensure=latest</pre>
<p>Se poi non avete il tempo da impiegare nell&#8217;installazione, ma non volete perdere l&#8217;occasione di testare un prodotto cosi interessante potete anche scaricare una VM gia pronta al seguente link <a href="http://puppetlabs.com/download-learning-vm">puppetlabs_VM</a></p>
<h4><strong>Configurazione</strong></h4>
<p><strong>&#8211; Il puppet master</strong><br />
Raggiungete la macchina prescelta come puppet master che chiameremo, senza troppa fantasia, master e installate i programmi necessari:</p>
<p>root@master:</p>
<pre>~# apt-get install puppetmaster</pre>
<p>Questa operazione installerà anche le dipendenze, compreso il pacchetto per l&#8217;agent puppet.<br />
L&#8217;installazione terminerà con uno sconfortante errore: niente paura! semplicemente il master non è ancora stato configurato a dovere e gli script di init non sono in grado di avviarlo correttamente.<br />
Preoccupiamoci innanzitutto di permettere l&#8217;accesso ai file che verranno serviti dal nostro master, editate il file /etc/puppet/fileserver.conf e aggiungete una riga per permettere l&#8217;accesso alla sottorete 192.168.0.0/24 (per esempio).</p>
<p>&nbsp;</p>
<p>Prepariamo un piccolo laboratorio con 3 macchine</p>
<pre>Name                 IP                     OS                    Descrizione
puppet01        192.168.1.10            CentOS 6.5               puppet master
puppet02        192.168.1.20            CentOS 6.5               puppet client
puppet03        192.168.1.30            CentOS 5.10              puppet client</pre>
<p>** configuriamo il file /etc/hosts</p>
<pre># vim /etc/hosts

192.168.1.10    puppet01
192.168.1.20    puppet02
192.168.1.30    puppet03</pre>
<p>&#8211; Inseriamo queste due righe nel [main] edl file /etc/puppet/puppet.conf</p>
<pre class="prettyprint prettyprinted"><span class="pln">certname </span><span class="pun">=</span><span class="pln"> puppet
dns_alt_names </span><span class="pun">=</span><span class="pln"> puppet</span><span class="pun">,</span><span class="pln">puppet01</span><span class="pun">.localdomain</span></pre>
<p>&#8211; Configuriamo il certificato<br />
Con questo comando si creerà il certificato CA e il certificato per il puppetmaster</p>
<p>puppet01 # puppet master &#8211;verbose &#8211;no-daemonize</p>
<p>notice: Starting Puppet master version 2.7.25<br />
(una volta apparsa la riga qui sopra potete chiudere con un Ctrl-C)</p>
<p>* verifichiamo: # puppet cert list &#8211;all<br />
+ &#8220;srv-c6.localdomain&#8221; (10:BD:EB:92:CE:98:A7:37:FE:4B:D8:20:5E:C2:44:D5) (alt names: &#8220;DNS:puppet&#8221;, &#8220;DNS:puppet.localdomain&#8221;, &#8220;DNS:puppet01.localdomain&#8221;)</p>
<p>* riavviamo il servizio :</p>
<pre>#  /etc/init.d/puppetmaster restart</pre>
<p>&#8211; <strong>Installazione dei client</strong></p>
<p>sulle macchine puppet02 e puppet03 installare soltanto il client &#8220;puppet&#8221; nei seguenti modi :</p>
<pre>Ubuntu/Debian : # sudo apt-get install puppet

RHEL/Centos   : # sudo yum install puppet -y</pre>
<p>** sulle macchine client andremo a modificare il file puppet.conf indicando il nome della macchina Server, il puppetmaster</p>
<pre># vim /etc/puppet/puppet.conf

[agent]
server = puppet01</pre>
<p>su puppet02 e puppet03</p>
<p># puppet agent &#8211;test # si dovrebbe vedere l&#8217;agente creare una richiesta di certificato al master</p>
<p>ora su puppet01 eseguite</p>
<p># puppet cert list &#8211;all # dovreste vedere le richieste effettuate dai client 01 e 02</p>
<p>La prima fase e&#8217; cosi terminata, nel prossimo articolo vedremo come installare e configurare la <strong>Dashboard</strong> di Puppet per avere una gestione centralizzata tramite Browser</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/11/30/puppet-automatizziamo-e-gestiamo-ogni-task/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/11/puppetlabs.png" medium="image">
			<media:title type="html">Puppet Labs</media:title>
		</media:content>
	</item>
	</channel>
</rss>
