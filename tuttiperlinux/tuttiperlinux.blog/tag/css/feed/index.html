<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>css &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/css/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Sun, 06 Oct 2019 21:28:04 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>css &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Il miracoloso NodeJS</title>
		<link>https://tuttiperlinux.blog/2019/10/06/il-miracoloso-nodejs/</link>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sun, 06 Oct 2019 21:28:04 +0000</pubDate>
				<category><![CDATA[Cloud]]></category>
		<category><![CDATA[News]]></category>
		<category><![CDATA[Scripting]]></category>
		<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[Virtualizzazione]]></category>
		<category><![CDATA[callback]]></category>
		<category><![CDATA[container]]></category>
		<category><![CDATA[css]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[facebook]]></category>
		<category><![CDATA[framework]]></category>
		<category><![CDATA[html]]></category>
		<category><![CDATA[java]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[nodejs]]></category>
		<category><![CDATA[npm]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[ruby]]></category>
		<category><![CDATA[twitter]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.blog/?p=1556</guid>

					<description><![CDATA[Ok, ammetto che fino a non molto tempo fa mi ero quasi scordato di Javascript, nonostante fosse stato uno dei primi linguaggi da me studiati, nel lontano 1997, quando mi approcciai al mondo del web; negli anni successivi pero&#8217;, non essendo io uno sviluppatore, le tecnologie di gestione e deploy dei server web che dovevo &#8230; <a href="https://tuttiperlinux.blog/2019/10/06/il-miracoloso-nodejs/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1557" style="width: 310px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1557" data-attachment-id="1557" data-permalink="https://tuttiperlinux.blog/2019/10/06/il-miracoloso-nodejs/nodejs/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg" data-orig-size="1000,407" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nodejs" data-image-description="" data-image-caption="&lt;p&gt;NodeJS &#8211; una piattaforma Open Source event-driven&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=600" class="size-medium wp-image-1557" src="https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=300&#038;h=122" alt="piattaforma Open Source event-driven" width="300" height="122" srcset="https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=300&amp;h=122 300w, https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=600&amp;h=244 600w, https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=150&amp;h=61 150w" sizes="(max-width: 300px) 100vw, 300px" /><p id="caption-attachment-1557" class="wp-caption-text">NodeJS &#8211; una piattaforma Open Source event-driven</p></div>
<p>Ok, ammetto che fino a non molto tempo fa mi ero quasi scordato di Javascript, nonostante fosse stato uno dei primi linguaggi da me studiati, nel lontano 1997, quando mi approcciai al mondo del web; negli anni successivi pero&#8217;, non essendo io uno sviluppatore, le tecnologie di gestione e deploy dei server web che dovevo gestire si erano spostate verso un grande quantitativo di linguaggi, in particolare per la parte back-end , passando cosi dal php, perl, python, java, ruby, lua etc&#8230;&#8230;</p>
<p>Come stavo dicendo, per me javascript era rimasto in sordina come un linguaggio di scripting che intercorreva tra l&#8217;hmtl ed il css, nella composizione piu&#8217; o meno dinamica di una pagina web ,prima che i pesi massimi sopra citati entrassero in campo per svolgere il duro lavoro.</p>
<p>Poi, un giorno, a ciel sereno&#8230;&#8230;BOOOOOOOMMMM ! scopro l&#8217;esistenza di NodeJS, ed iniziai a chiedermi a cosa si dovesse tutto l&#8217;interesse di cui stavo leggendo; scopro quindi che NodeJS e&#8217; una piattaforma Open Source event-driven per l’esecuzione di codice JavaScript Server-side, costruita sul motore V8 di Google Chrome. Mmmmhhhh, ok bene, ma quindi? cosa fa?</p>
<p>Ebbene questa piccola rivoluzione creata da Google consente agli sviluppatori di realizzare web application con JavaScript non più solo lato client, ma anche sfruttandolo come linguaggio di programmazione lato server.</p>
<p>E gli sviluppi sono davvero moltissimi, cosi tanti che mettere un&#8217;elenco sarebbe noioso e stancante ma, tanto per farne uno molto odierno, con NodeJS possiamo, ad esempio, realizzare dei ChatBot.</p>
<p>Ma qual&#8217;e&#8217; dunque il funzionamento che lo rende cosi appetitoso? Innanzitutto partiamo dal dire che <em class="kz">Node</em> funziona con una logica a eventi: quando un evento viene generato, allora viene eseguita un’azione. Grazie a questa tecnica non bisogna attendere che le istruzioni precedenti siano terminate, rendendo cosi il tutto molto veloce.</p>
<p>Nella pratica, non c&#8217;e&#8217; bisogno di sapere come funziona il V8 per poter utilizzare NodeJS, basti sapere che e&#8217; l&#8217;interprete javascript piu&#8217; veloce al mondo, poiche&#8217; e&#8217; stato altamente ottimizzato utilizzando un tipo di programmazione JIT (Just In Time), che trasforma rapidamente il codice javascript in linguaggio macchina.</p>
<p>Ma la cosa che, almeno a parere personale, mi ha maggiormente colpito, e&#8217; stato quello che possiamo chiamare come &#8220;<strong>Modello non bloccante</strong>&#8221; , questo si basa sul concetto degli eventi, ma per meglio chiarire dovremmo spiegare un minimo la differenza tra modello bloccante e NON bloccante.</p>
<p>Immaginiamo di dover creare un programma che ci permetta di scaricare un file da internet e che alla fine dell&#8217;esecuzione del download ci mostri un messaggio.</p>
<p>Bene, con il modello classico (bloccante) basato sulla programmazione sincrona potremmo schematizzare il processo nel seguente modo:</p>
<ul>
<li>Scarica il file</li>
<li>Mostra il messaggio</li>
<li>Fai qualcos&#8217;altro</li>
</ul>
<p>Ci aspetteremmo quindi che le azione vengano eseguite in ordine, leggendo le operazioni da eseguire dall&#8217;alto verso il basso.</p>
<p>Nel sistema asincrono di NodeJS invece le operazioni verranno svolte nel seguente modo:</p>
<ul>
<li>Scarica file</li>
<li>Fai qualcos&#8217;altro</li>
<li>Mostra il messaggio</li>
</ul>
<p>Perche&#8217; questa diversita&#8217; nell&#8217;esecuzione rende il tutto piu&#8217; veloce e performante? Beh perche&#8217; mentre il sistema effettua il download del file, il programma non rimane in attesa che il processo venga portato a termine ma anzi nell&#8217;attesa il programma esegue altre operazioni.</p>
<p>Il codice in oggetto avra&#8217;un aspetto tipo questo:</p>
<p><span style="color:#00ccff;">request(&#8216;<a href="http://www.site.com/file.zip&#038;#8217" rel="nofollow">http://www.site.com/file.zip&#038;#8217</a>;, function (error, response, body) {</span><br />
<span style="color:#00ccff;">console.log(&#8220;Download completato!&#8221;);</span><br />
<span style="color:#00ccff;">});</span></p>
<p><span style="color:#00ccff;">console.log(&#8220;Mentre aspetto eseguo il resto del codice&#8230;&#8221;);</span></p>
<p><span style="color:#000000;">Quello appena descritto qui sopra e&#8217; un&#8217;esempio di procedura di <strong>callback </strong></span></p>
<p>Ok ma se non fosse ancora del tutto chiaro, proviamo ancora a spiegare perche&#8217; le callback sono cosi importanti, procediamo con l&#8217;esempio di prima ed aggiungiamo una difficolta&#8217;; adesso i file da scaricare sono diventati due, dunque nel sistema sincrono il programma procederebbe nel seguente modo:</p>
<ul>
<li>Scarico primo file</li>
<li>Attendo che finisca</li>
<li>Scarico secondo file</li>
<li>Attendo che finisca</li>
<li>Mando messaggio</li>
</ul>
<p>La grande differenza in questo esempio sarebbe che con NodeJS verrebbero lanciati entrambi i download, nello stesso momento, permettendo gia cosi un piu&#8217; veloce download e, nel frattempo il programma e&#8217; in grado di svolgere eventuali altri compiti. Ma questo come dicevo e&#8217; soltanto un esempio, invece di un download multiplo, potrebbero essere delle query ad un DB, o la richiesta di dati a servizi esterni tramite API (Facebook, Twitter).</p>
<p>Pensiamo quindi ad un sistema come Facebook, che riceve X richieste di Like ogni tot secondi e vengono cosi aperti N operatori che devono attendere il loro turno per fare la modifica (del like) consumando comunque energie anche mentre sono fermi in attesa; invece NodeJS nella stessa situazione di richiesta di &#8220;reaction&#8221; sul sisto di FB (like o altro) si comporterebbe nel seguente modo:</p>
<p>metterebbe tutte le richieste in ordine di arrivo, prenderebbe la prima e, vedendo che si tratta di una sfilza di input le inserirebbe all&#8217;interno del sistema e, una volta capito che si tratta di stesse azioni (ad esempio che aggiungono un Like) che devono contattare un DB, NodeJS contatta il DB e invece di attendere per effettuare ogni singola modifica, aggancia alla richiesta una callback, per ogni richiesta di modifica, tutti uno dietro l&#8217;altro. Quando il DB finisce la prima modifica scatta la callback e NodeJS restituisce all&#8217;utente l&#8217;avvenuta modifica della pagina e cosi via, gestendo quindi con un solo operatore le N richieste di modifica del Like invece di crearne uno per ogni richiesta e parcheggiandoli tutti in attesa della loro singola modifica. Quindi con un server (magari anche un container con Docker) e con poche risorse possiamo gestire un&#8217;enorme quantita&#8217; di richieste al secondo.</p>
<p>Inoltre NodeJS usa come sistema di pacchetti e librerie l&#8217;NPM, ma di questo fantastico sistema di librerie parleremo in un&#8217;altro articolo.</p>
<p>Nel prossimo articolo su NodeJS parleremo anche di 5 nuovi framework ottimi per chi si occupa di sviluppare.</p>
<p>#NodeJS</p>
<p>&nbsp;</p>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2019/10/nodejs.jpeg?w=300" medium="image">
			<media:title type="html">piattaforma Open Source event-driven</media:title>
		</media:content>
	</item>
		<item>
		<title>Docker i Container ed i Microservices</title>
		<link>https://tuttiperlinux.blog/2017/03/02/docker-i-container-ed-i-microservices/</link>
					<comments>https://tuttiperlinux.blog/2017/03/02/docker-i-container-ed-i-microservices/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Thu, 02 Mar 2017 11:02:08 +0000</pubDate>
				<category><![CDATA[News]]></category>
		<category><![CDATA[Virtualizzazione]]></category>
		<category><![CDATA[asp]]></category>
		<category><![CDATA[container]]></category>
		<category><![CDATA[css]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[guest]]></category>
		<category><![CDATA[hava]]></category>
		<category><![CDATA[host]]></category>
		<category><![CDATA[microservices]]></category>
		<category><![CDATA[overhead]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[soa]]></category>
		<category><![CDATA[toolbox]]></category>
		<category><![CDATA[virtualizzazione]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=1308</guid>

					<description><![CDATA[Su questo portale abbiamo gia piu&#8217; volte scritto e descritto la tecnologia che sta dietro al progetto Docker, sicuramente una delle nuove scoperte informatiche degli ultimi anni, a livello dell&#8217;uscita della Virtualizzazione; ma nonostante tutto, non sempre e&#8217; facile capire in poche righe concetti nuovi non sempre semplici da comprendere, quindi eccovi un nuovo articolo, &#8230; <a href="https://tuttiperlinux.blog/2017/03/02/docker-i-container-ed-i-microservices/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1309" style="width: 310px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1309" data-attachment-id="1309" data-permalink="https://tuttiperlinux.blog/2017/03/02/docker-i-container-ed-i-microservices/docker_microservices/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png" data-orig-size="1229,766" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker ed i Microservices" data-image-description="&lt;p&gt;Docker ed i Microservices&lt;/p&gt;
" data-image-caption="&lt;p&gt;Docker ed i Microservices&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=600" class="size-medium wp-image-1309" src="https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=300&#038;h=187" alt="Docker ed i Microservices" width="300" height="187" srcset="https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=300&amp;h=187 300w, https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=600&amp;h=374 600w, https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=150&amp;h=93 150w" sizes="(max-width: 300px) 100vw, 300px" /><p id="caption-attachment-1309" class="wp-caption-text">Docker ed i Microservices</p></div>
<p>Su questo portale abbiamo gia piu&#8217; volte scritto e descritto la tecnologia che sta dietro al progetto <a href="https://www.docker.com/"><strong>Docker</strong></a>, sicuramente una delle nuove scoperte informatiche degli ultimi anni, a livello dell&#8217;uscita della Virtualizzazione; ma nonostante tutto, non sempre e&#8217; facile capire in poche righe concetti nuovi non sempre semplici da comprendere, quindi eccovi un nuovo articolo, che fara&#8217; parte di una piccola serie di episodi, in cui cercheremo di fare ulteriormente luce su cos&#8217;e&#8217; e come funziona questo fantastico progetto.</p>
<p><strong>Dagli script PHP ai microservice<br />
</strong>Alla fine degli anni ’90 i siti erano per lo più ancora statici, con qualche script CGI , o altre soluzioni oggi considerate poco eleganti. Poi arrivarono ASP JAVA e PHP. Da li in avanti un progetto Web era prettamente fondato, ad esempio, su file PHP, CSS e immagini; in queste soluzioni tecnologiche era sufficiente copiare tutti questi file su uno spazio hosting e al più modificare qualche file di configurazione, per ricreare un nuovo ambiente web e ricominciare su di un nuovo sito.</p>
<p>Venti anni dopo gli scenari sono drasticamente diversi, le architetture <a href="https://it.wikipedia.org/wiki/Service-oriented_architecture"><strong>SOA</strong></a> hanno preso piede, si è iniziato a parlare di <a href="https://en.wikipedia.org/wiki/Microservices"><strong>microservice</strong></a> e tutto è diventato più complesso. Un’applicazione web, soprattutto in ambito enterprise, non è più la directory di cui parlavamo prima, ma un&#8217; insieme di componenti autonomi, ognuno col suo ciclo di vita indipendente, rilasciati su macchine diverse e a ritmi sempre crescenti.</p>
<p>Una complessità così grande non può piu&#8217; essere amministrata con il vecchio copia e incolla, diventa cosi&#8217; necessario uno strumento affidabile che consenta di manipolare o spostare intere applicazioni limitando errori umani, checklist lunghissime da controllare e tutti i passaggi snervanti e carichi di rischi necessari per il deployment.</p>
<p><strong>I container</strong><br />
Cosi&#8217; come nell’industria dei trasporti nacque l&#8217;esigenza di una soluzione unica intercambiabile, vennero cosi creati i container: contenitori multiuso, realizzati in formati standard che possono essere passati con facilità da un camion a una nave, poi magari su un treno merci e così via.</p>
<p>Anche nel campo informatico abbiamo bisogno di qualcosa che “contenga” la nostra applicazione, che ci consenta di manovrarla con facilità senza sapere nulla, o quasi, riguardo il suo contenuto. In pratica, abbiamo bisogno anche noi del nostro container!</p>
<p><strong>Docker</strong><br />
L’intuizione del team di Docker è stata quella di prendere il concetto di container e costruirvi attorno un&#8217; ecosistema che ne semplificasse l’impiego. Di questo ecosistema fanno parte una serie di tool: Docker engine, Docker Toolbox, Swarm, Kitematic e tant&#8217; altro ancora per rendere i container qualcosa di accessibile anche a chiunque, sfruttando anche il fatto che la community di sviluppatori che utilizza Docker è davvero molto vasta. Ad esempio, Docker Hub è un repository di container pubblici pronti per l’uso, mentre il codice sorgente del Docker engine è liberamente disponibile su GitHub e vanta quasi 1500 contributor.</p>
<p><strong>Container VS Virtual Machine</strong><br />
Apparentemente i container e le virtual machine sembrano due concetti molto simili ma, sebbene queste due soluzioni abbiano delle caratteristiche in comune, si tratta di tecnologie profondamente diverse tra loro, così come diverso è anche il modo in cui dobbiamo iniziare a pensare all’architettura delle nostre applicazioni. Possiamo creare un container con la nostra applicazione monolitica all’interno, ma così non sfrutteremmo a pieno la forza dei container e quindi di Docker.</p>
<p>Una possibile architettura software adatta per un’infrastruttura a container è la classica architettura a microservizi. L’idea, in pratica, è quella di scomporre l’applicazione in tante piccole componenti ognuna col suo compito specifico ma capaci di scambiarsi messaggi e di cooperare tra loro, cio&#8217; che e&#8217; alla base dei sistemi SOA. Il deploy di tali componenti avverrà poi effettuato singolarmente, come tanti container.</p>
<p>Uno scenario come quello ipotizzato è assolutamente poco pratico con una macchina virtuale, in quanto ogni nuova macchina virtuale istanziata richiederebbe un bel dispendio di energia per la macchina host. I container, al contrario, sono molto leggeri, poiché effettuano una virtualizzazione completamente diversa da quella praticata dalle macchine virtuali.<br />
Nelle macchine virtuali, lo strumento detto <strong>hypervisor</strong> si preoccupa di riservare (staticamente o dinamicamente) un certo quantitativo di risorse dal sistema operativo host da dedicare poi ad uno o più sistemi operativi, detti guest o ospiti, inoltre ogni sistema operativo guest sarà completamente isolato dal sistema operativo host. Questo meccanismo è molto dispendioso in termini di risorse, per cui l’idea di associare un micro-servizio ad una macchina virtuale è del tutto irrealizzabile.</p>
<p>I container, d’altro canto, apportano un contributo completamente diverso alla questione, l’isolamento è molto più blando e tutti i container in esecuzione condividono lo stesso kernel del sistema operativo sottostante, host. Scompare completamente l’overhead dell’hypervisor, e un singolo host può arrivare a ospitare centinaia di container.</p>
<div data-shortcode="caption" id="attachment_1310" style="width: 310px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1310" data-attachment-id="1310" data-permalink="https://tuttiperlinux.blog/2017/03/02/docker-i-container-ed-i-microservices/dockervsvm/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg" data-orig-size="600,339" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker VS VirtualMachine" data-image-description="&lt;p&gt;Docker VS VirtualMachine&lt;/p&gt;
" data-image-caption="&lt;p&gt;Docker VS VirtualMachine&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg?w=600" class="size-medium wp-image-1310" src="https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg?w=300&#038;h=170" alt="Docker VS VirtualMachine" width="300" height="170" srcset="https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg?w=300&amp;h=170 300w, https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg?w=150&amp;h=85 150w, https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg 600w" sizes="(max-width: 300px) 100vw, 300px" /><p id="caption-attachment-1310" class="wp-caption-text">Docker VS VirtualMachine</p></div>
<p>Nel prossimo articolo rivedremo come installare Docker tramite i Docker-ToolBox, e come interagire con i container.<br />
Alla prossima</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2017/03/02/docker-i-container-ed-i-microservices/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2017/03/docker_microservices.png?w=300" medium="image">
			<media:title type="html">Docker ed i Microservices</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2017/03/dockervsvm.jpg?w=300" medium="image">
			<media:title type="html">Docker VS VirtualMachine</media:title>
		</media:content>
	</item>
	</channel>
</rss>
