<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>bilanciamento &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/bilanciamento/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Mon, 15 Sep 2014 07:01:22 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>bilanciamento &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Ottimizzare grazie a Memcached</title>
		<link>https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/</link>
					<comments>https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sun, 14 Sep 2014 23:54:10 +0000</pubDate>
				<category><![CDATA[Networking]]></category>
		<category><![CDATA[balance]]></category>
		<category><![CDATA[bilanciamento]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[front-end]]></category>
		<category><![CDATA[hot key]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[mctop]]></category>
		<category><![CDATA[memcached]]></category>
		<category><![CDATA[nic]]></category>
		<category><![CDATA[sql]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=547</guid>

					<description><![CDATA[Ottimizzazione server dedicato grazie a MemCached Spesso si e&#8217; portati a credere che i meccanismi di cache siano una specie di Panacea, e che dalla loro implementazione non si debba temere alcun  problema : ovviamente non è così. Specialmente se il tuo cloud è dedicato all’erogazione di siti/portali web con volumi importanti l’utilizzo di memcached &#8230; <a href="https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg"><img loading="lazy" data-attachment-id="548" data-permalink="https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/theflash_memcached/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg" data-orig-size="600,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="theflash_memcached" data-image-description="&lt;p&gt;Memcached flash website&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=600" class="alignleft size-medium wp-image-548" src="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300&#038;h=168" alt="theflash_memcached" width="300" height="168" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300&amp;h=168 300w, https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=598&amp;h=336 598w, https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=150&amp;h=84 150w, https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg 600w" sizes="(max-width: 300px) 100vw, 300px" /></a>Ottimizzazione server dedicato grazie a MemCached</strong></p>
<p>Spesso si e&#8217; portati a credere che i meccanismi di cache siano una specie di Panacea, e che dalla loro implementazione non si debba temere alcun  problema : <strong>ovviamente non è così</strong>.<br />
Specialmente se il tuo cloud è dedicato all’erogazione di siti/portali web con volumi importanti l’utilizzo di memcached può sicuramente aumentare le performance di quest&#8217;ultimo;  ma può anche introdurre un nuovo point of failure, uno di quelli che non ti aspetti.<br />
Facciamo un esempio, non ti aspetteresti che un’istanza memcached possa rappresentare un collo di bottiglia !, men che meno un pool di istanze bilanciate e, cosa forse ancor più singolare, che lo possano rappresentare a livello di networking. Eppure succede!</p>
<p><strong>Cos’è memcached, e come funziona?</strong><br />
<a href="http://memcached.org/">Memcached</a> è un sistema di caching distribuito ed ha una struttura client/server che permette di servire i dati più richiesti direttamente dalla RAM, riducendo cosi al tempo stesso il carico sul database.<br />
Questo può essere di grande aiuto se si ha la necessità di gestire una quantità di dati davvero importante.<br />
<strong>Sfruttare elaborazioni già effettuate</strong>: questo è il punto di forza di Memcached; infatti raggruppando la cache dei nodi crea una memoria a breve termine che serve per ottimizzare le operazioni ripetute.</p>
<p>Memcached è semplice ma potente. Il suo design semplice promuove un&#8217;implementazione veloce, facilità di sviluppo, e risolve molti dei problemi che ci si trova ad affrontare quando si ha a che fare con grandi cache di dati.</p>
<p>Il server funziona ricevendo una serie di coppie chiave-valore e mantenendole in RAM.<br />
In genere è compito della logica applicativa (quindi della programmazione degli scripts php, ruby, phyton ecc&#8230;) decidere se effettuare un’operazione di scrittura su memcached oppure di lettura, ed e&#8217;sempre compito dell’applicazione computare un hash delle key che invia a memcached e, successivamente, inviare la coppia chiave-valore al server stesso.<br />
Nel caso di un cluster, l’applicazione deve determinare in base all’hash quale nodo memcached contiene quale valore.</p>
<p>Ora, può succedere che alcune coppie chiavi-valore siano molto più utilizzate di altre, queste si definiscono in gergo “hot keys”.<br />
Può succedere inoltre, nel caso che il sito sia molto trafficato, che i front-end web interroghino con preferenza alcune coppie chiave-valore specifiche.<br />
Facciamo un&#8217;altro esempio: immaginiamo di dover gestire la home page di un quotidiano nazionale (a me e&#8217; capitato).<br />
Immaginiamo che il codice che muove quel sito interroghi memcached per evitare che, ad ogni richiesta della home page, vengano fatte delle richieste al database.<br />
Immaginiamo infine che la home page del tuo portale riceva un grosso picco di traffico completamente inatteso (per esempio un terremoto).<br />
Man mano che il traffico aumenta, aumentano le richieste che i front-end devono effettuare al back-end memcached per evitare di interrogare continuamente i database.<br />
Per servire un sito di questo tipo, si sono probabilmente predisposti una mezza dozzina di front-end applicativi, o forse di più, e ciascuno di questi chiama il back-end memcache.<br />
Man mano che il traffico da servire lato pubblico scala verso le decine di Mbit/s, il traffico verso il backend memcached aumenta con un moltiplicatore pari al numero di front-end e questo comincia a saturare la scheda di rete del memcached.<br />
Il traffico aumenta fintanto che la scheda di rete si satura, il sistema crolla, con buona pace di ottimizzazioni lato front-end, bilanciatori di carico, e ottimizzazioni lato SQL.</p>
<p>Se avessimo configurato un cluster memcached alle spalle dei front-end il problema potrebbe comunque presentarsi perchè alcuni nodi del cluster potrebbero avere delle “hot-keys” un po più “hot” delle chiavi degli altri nodi.</p>
<p>Ora, potrebbe anche essere che i memcached contengano solo piccole porzioni di dato e quindi il traffico sulla NIC sia molto contenuto, ma se non siete stati voi ad aver scritto l’applicazione, non potrete esserne certi, quindi si dovra&#8217; quantomeno monitorare la saturazione della NIC e l’eventuale presenza di differenti hot keys sui server.</p>
<p><strong>Come uscirne fuori?</strong><br />
Se la situazione non si è ancora deteriorata del tutto, potreste effettuare l’analisi del traffico in uscita dalla NIC con un packet sniffer e cercare di capire quale sia la chiave “incriminata” e i dati ad essa associati.<br />
Ma c&#8217;e&#8217; da dire che state facendo passare qualche centinaio di Mbit/s su una NIC, un’attività del genere non deve essere una passeggiata anche solo per la mole di dati che si deve processare.<br />
In alternativa, può venirci in aiuto uno strumento come mctop, che permette di tracciare il numero di chiamate, richieste al secondo, e l’uso della banda per ogni singolo pacchetto.<br />
In questo modo, sara&#8217; molto più facile individuare le key che tendono a saturare la banda ed indicare dove ai programmatori o tecnici dove devono intervenire.</p>
<p><strong>Non è solo un problema lato server</strong>.<br />
Come si puo&#8217; immaginare, questo tipo di problemi va affrontato sia lato sistemi che lato sviluppo<br />
In una situazione di emergenza identificare una “hot key” manualmente, potra&#8217; anche andare bene, ma il punto è che dal lato sviluppo applicativo dovranno mettere mano al codice ed essere in grado di effettuare, per quanto possibile, questo tipo di operazione in autonomia migliorando le fasi di test e di pre produzione.<br />
Diventa cosi&#8217; davvero opportuno avere nella propria infrastruttura, dei sistemi di monitoraggio e di alert, che possano segnalare per tempo gli status ed i possibili rischi di saturazione lato NIC.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300" medium="image">
			<media:title type="html">theflash_memcached</media:title>
		</media:content>
	</item>
		<item>
		<title>Catturare il traffico di rete</title>
		<link>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/</link>
					<comments>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 06 Aug 2014 22:41:38 +0000</pubDate>
				<category><![CDATA[Load Balancing]]></category>
		<category><![CDATA[back-end]]></category>
		<category><![CDATA[bilanciamento]]></category>
		<category><![CDATA[carico]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[load balancing]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[opensource]]></category>
		<category><![CDATA[pound]]></category>
		<category><![CDATA[rinetd]]></category>
		<category><![CDATA[servizi]]></category>
		<category><![CDATA[url]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=281</guid>

					<description><![CDATA[Redirect fai da te Molte volte vi capitera&#8217; (ed a me e&#8217; capitato piu&#8217; volte) di aver bisogno di gestire il traffico di rete ottimizzandolo, filtrandolo e redirezionandolo. Si pensi, ad esempio, ai test di sviluppo effettuati sulle molte VM in cui si deve tenere conto della quantita&#8217; di Server interessati e del carico di &#8230; <a href="https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg"><img data-attachment-id="282" data-permalink="https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/redirect/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg" data-orig-size="252,200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="redirect" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=252" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=252" class="alignleft size-full wp-image-282" src="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=600" alt="redirect" srcset="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg 252w, https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=150 150w" sizes="(max-width: 252px) 100vw, 252px"   /></a>Redirect fai da te </strong></h3>
<p>Molte volte vi capitera&#8217; (ed a me e&#8217; capitato piu&#8217; volte) di aver bisogno di gestire il traffico di rete ottimizzandolo, filtrandolo e redirezionandolo.<br />
Si pensi, ad esempio, ai test di sviluppo effettuati sulle molte VM in cui si deve tenere conto della quantita&#8217; di Server interessati e del carico di rete da gestire bilanciando quest&#8217;ultimo e gestendo le porte interessate.</p>
<p>In questo articolo illustrero&#8217; alcuni dei migliori tra quelli da me usati in ambito OpenSource sono, <strong>Rinetd,</strong> <strong>LVS</strong> e <strong>Pound</strong>, ma l&#8217;elenco potrebbe ancora allungarsi, magari per un seguito.</p>
<p><strong>PARTIAMO</strong></p>
<p><strong>rinetd</strong></p>
<p>E&#8217; il piu&#8217; semplice dei tre, dunque partiremo da questo; esso permette di ridirigere una destinazione TCP, definita attraverso una coppia <em>&lt;indirizzo-ip&gt;</em>:<em>&lt;numero-di-porta&gt;</em>, presso un&#8217;altra coppia di questi valori. Lo scopo di questo può essere semplicemente quello di dirigere una porta locale verso un&#8217;altra porta locale, oppure si può arrivare a intercettare il traffico IP che attraversa un <em>router</em> in modo da ridirigere alcune coppie di indirizzi e porte presso altre destinazioni.</p>
<p>Tutto è composto semplicemente da un <em>daemon</em>, <b><code>rinetd</code></b>, che si avvale di un file di configurazione, <code>/etc/rinetd.conf</code>, nel quale si indicano semplicemente le ridirezioni da applicare.</p>
<p>La presenza in funzione di <b><code>rinetd</code></b> è incompatibile con altri <em>daemon</em> che stanno in ascolto delle stesse porte che devono essere ridirette, anche se queste sono intese appartenere a <em>host</em> differenti.</p>
<p>Il programma rinetd è il demone che si occupa di ridirigere il traffico TCP in base a quanto contenuto nel file di configurazione <code class="file">/etc/rinetd.conf<br />
E' sufficiente avviarlo e, se il file di configurazione risultera'corretto, iniziare subito a lavorarci. All'avvio, dopo aver letto la configurazione, rinetd deve poter stare in ascolto dell'indirizzo da ridirigere e della porta relativa; qualunque sia l'indirizzo in questione, è necessario che non ci sia già un programma locale che fa la stessa cosa su quella stessa porta; per esempio, non si può tentare di ridirigere il servizio HTTP di un indirizzo qualunque, se questo è presente localmente.</code></p>
<p>Un esempio di configurazione del file rinetd.conf dovrebbe essere sufficiente a chiarire le idee su questo file. Supponiamo di voler dirottare il traffico diretto verso l&#8217;indirizzo IP 10.11.12.13 alla porta 80, in modo che questo vada verso l&#8217;indirizzo IP 192.168.1.7, alla porta 80.</p>
<pre>120.121.122.123 80 192.168.1.7 80</pre>
<p>L&#8217;indirizzo da ridirigere, può appartenere a un&#8217;interfaccia del nodo presso cui si trova in funzione il demone rinetd,<br />
oppure no, purché i pacchetti diretti a tale indirizzo transitino attraverso il nodo che attua la ridirezione.<br />
Se si vuole apprendere il funzionamento di rinetd senza disporre di una rete vera e propria, basta una direttiva di configurazione simile a quella seguente:</p>
<pre>localhost 8888 localhost html</pre>
<p>In questo modo, la porta locale 8888 viene ridiretta sulla porta del servizio HTTP (80). Se il servizio HTTP è attivo, si può verificare la ridirezione con un programma di navigazione qualunque, puntando all&#8217;URL</p>
<pre>http://localhost:8888</pre>
<p>Rispetto ai prossimi due tool rinetd non e&#8217; in grado di fungere anche come LoadBalancer.</p>
<hr />
<p><strong>ipvsadm</strong></p>
<p>Questo servizio aggiorna la tabella d&#8217;instradamento IPVS nel kernel. Il demone <strong><code class="command">lvs</code></strong> imposta e gestisce Load Balancer Add-On richiamando <strong><code class="command">ipvsadm</code></strong> per aggiungere, modificare e cancellare le voci all&#8217;interno della tabella d&#8217;instradamento IPVS. Inoltre ipvsadm fa parte del paccheto LVS  che è una soluzione di bilanciamento del carico avanzato per sistemi Linux.<br />
Si tratta di un progetto open source avviato da Wensong Zhang nel lontano 1998. La missione del progetto è di costruire un server ad alte prestazioni e ad alta disponibilità per Linux utilizzando tecnologie di clustering, offrendo una buona scalabilità, affidabilità e facilità di manutenzione. L’opera principale del progetto LVS è ora quello di sviluppare un software avanzato di bilanciamento del carico IP (IPVS), ed un software di bilanciamento a livello dell’applicazione (KTCPVS), ed i componenti di gestione dei cluster.</p>
<h3>Ipvs in pratica</h3>
<p>IPVS (IP Virtual Server) implementa un bilanciatore di carico a livello Layer 4 della rete. IPVS in esecuzione su un host si comporta come un sistema di bilanciamento del carico di fronte ad un insieme di server reali in cluster, può indirizzare le richieste per servizi basati si TCP/UDP ai veri server, e fa apparire i servizi dei server reali come un unico servizio virtuale su un unico indirizzo IP.</p>
<p>La componente IPVS è presente in tutti i recenti Kernel, per installare la componente in user-space utilizzate il vostro gestore di pacchetti, ad esempio in Ubuntu:</p>
<pre>aptitude install ipvsadm</pre>
<p>a questo punto si può creare uno script da far avviare al boot. Io di solito inserisco i comandi all’interno del file<br />
<strong>/etc/rc.local</strong>.</p>
<div>Prima di tutto dobbiamo <em>resettare</em> l’attuale configurazione con il comando:</div>
<pre>ipvsadm -C</pre>
<div>Dopodiché iniziamo a dare le regole con i comandi come nell’esempio qui sotto in cui diciamo che le chiamate TCP (parametro -t) all’indirizzo 192.168.10.100 sulla porta 5060 (quella per il protocollo SIP) debbano essere inoltrate alla stessa porta dell’indirizzo 192.168.10.250.  Per reindirizzare una chiamata UDP sostituire il -t con -u.</div>
<pre>ipvsadm -A -t 192.168.10.100:5060 -s rr</pre>
<p>ipvsadm -a -t 192.168.10.100:5060 -r 192.168.10.250:5060 -m</p>
<div id="_mcePaste">Naturalmente è possibile catturare il traffico su una porta e inoltrarla ad un’altra con un comando tipo questo:</div>
<div>ipvsadm -A -t 192.168.10.100:88 -s rr</div>
<div>ipvsadm -a -t 192.168.10.100:88 -r 192.168.10.250:80 -m</div>
<div>In questo caso non abbiamo fatto altro che prendere le chiamate alla porta 88 dell’indirizzo 192.168.10.100 e rinviarle al server web dell’IP 192.168.10.250 sulla normale porta 80</div>
<p><strong>Metodi di bilanciamento utilizzati da LVS</strong></p>
<p>In caso si desideri testare il funzionamento di <strong>LVS</strong> senza la necessita&#8217; di monitorare i servizi e possibile aggiungere e rimuovere nodi con il comando <code>ipvsadm</code>:<br />
<code><br />
ipvsadm -C<br />
ipvsadm -A -t 10.2.1.164:8080 -s lc<br />
ipvsadm -a -t 10.2.1.164:8080 -r 10.2.1.166 -g<br />
ipvsadm -a -t 10.2.1.164:8080 -r 10.2.1.165 -g<br />
</code><br />
Le opzioni utilizzate nelle linee di comando di ipvsadm per l&#8217;esempio riportato sono le seguenti:</p>
<p>&#8211; <strong>-C</strong>, <strong>&#8211;clear</strong>: cancella la tabella del virtual server.<br />
&#8211; <strong>-A</strong>, <strong>&#8211;add-service</strong>: crea un servizio virtuale.<br />
&#8211; <strong>-a</strong>, <strong>&#8211;add-server</strong>: aggiunge un nodo ad un servizio virtuale.<br />
&#8211; <strong>-t</strong>, <strong>&#8211;tcp-service</strong>: specifica indirizzo ip e numero di porta tcp del servizio virtuale.<br />
&#8211; <strong>-s</strong>, <strong>&#8211;scheduler</strong>: specifica l&#8217;algoritmo di bilanciamento<br />
&#8211; <strong>-r</strong>, <strong>&#8211;real-server</strong>: specifica l&#8217;indirizzo ip del nodo reale<br />
&#8211; <strong>-g</strong>, <strong>&#8211;gatewaying</strong>: indica il metodo di forwarding direct routing (<strong>LVS-DR</strong>)</p>
<p><strong>** algoritmi per il bilanciamento che possiamo usare con LVS</strong>.</p>
<p><strong>Statici</strong>:</p>
<p>&#8211; Round Robin</p>
<p>&#8211; Weighted Round Robin</p>
<p>&#8211; Destination Hashing</p>
<p>&#8211; Source Hashing</p>
<p><strong>Dinamici</strong>:</p>
<p>&#8211; Least-Connection</p>
<p>&#8211; Weighted least-connection</p>
<p>&#8211; Never queue</p>
<p>&#8211; Locality-based least-connection</p>
<p>&#8211; Locality-based least-connection with replication scheduling</p>
<p>&#8211; Shortest expected delay</p>
<hr />
<p><strong>pound<br />
</strong></p>
<p>Pound è un proxy server di bilanciamento del carico inverso. Accetta richieste da HTTP / HTTPS clienti e li distribuisce a uno o più server web. Le richieste HTTPS vengono decifrati e passati al back-end come semplice protocollo HTTP.</p>
<p>Se più di un server back-end è definita, Pound sceglie uno di loro a caso, sulla base delle priorità definite. Per impostazione predefinita, Pound tiene traccia di associazioni tra client e server back-end (sessioni).</p>
<p>General Principles</p>
<p>In generale, Pound ha bisogno di tre tipi di oggetti definiti, al fine di funzione: ascoltatori , i servizi e back-end .</p>
<p><strong>Ascoltatori</strong><br />
Un ascoltatore è una definizione di come Pound riceve le richieste dai client (browser). Due tipi di ascoltatori può essere definito: normale connessione HTTP ascoltatori e HTTPS (HTTP su SSL / TLS) ascoltatori . Per lo meno un ascoltatore deve definire l&#8217;indirizzo e la porta per l&#8217;ascolto su, con ulteriori requisiti per HTTPS ascoltatori .</p>
<p><strong>Servizi</strong><br />
Un servizio è la definizione di come le domande trovano risposta. Il servizio può essere definito all&#8217;interno di un ascoltatore o al livello superiore (globale). Quando viene ricevuta una richiesta Pound tenta di far corrispondere a ciascun servizio , a sua volta, a partire dai servizi definiti nel ascoltatore stesso e, se necessario, di proseguire con l&#8217; servizi definiti a livello globale. I servizi possono definire le proprie condizioni al quale le domande si può rispondere: in genere si tratta certo URL (solo foto, o un certo percorso) o intestazioni specifiche (come ad esempio l&#8217;intestazione Host). Un servizio può anche definire una sessione meccanismo: se definito le richieste future da un determinato cliente sarà sempre la stessa risposta da parte di back-end .</p>
<p><strong>Back-end</strong><br />
Il back-end sono i server reale per il contenuto richiesto. Di per sé, Pound fornisce nessuna risposta &#8211; tutti i contenuti devono essere ricevuti da un vero e proprio &#8220;web server&#8221;. Il back-end definisce come il server dovrebbe essere contattato.</p>
<p>Tre tipi di back-end può essere definito: un &#8220;regolare&#8221; back-end che riceve le richieste e le risposte restituisce, un &#8220;redirect&#8221; back-end in questo caso, Pound risponde con una risposta redirect, senza l&#8217;accesso a qualsiasi back-end a tutti , o una &#8220;emergenza&#8221; back-end che sarà usato solo se tutti gli altri backend sono &#8220;morti&#8221;.</p>
<p>Multiple back-end può essere definito all&#8217;interno di un servizio , nel qual caso Pound sarà bilanciamento del carico tra i disponibili back-end .</p>
<p>Se un back-end non riesce a rispondere, sarà considerato &#8220;morto&#8221;, nel qual caso Pound si ferma l&#8217;invio di richieste ad esso. Dead indietro _ e NDS sono periodicamente controllate per la disponibilità, e una volta che rispondono ancora sono &#8220;resurected&#8221; e le richieste sono inviati di nuovo la loro strada. Se non back-end sono disponibili (nessuno è stato definito, o sono tutti &#8220;morti&#8221;), allora Pound risponderà con &#8220;503 Servizio non disponibile&#8221;, senza verificare ulteriori servizi .</p>
<p>Il collegamento tra Pound e il back end- è sempre via HTTP, a prescindere dal protocollo utilizzato tra Pound e il cliente.</p>
<p><strong>Installazione </strong></p>
<pre>sudo apt-get install pound</pre>
<p>La gestione completa del servizio avviene tramite la configurazione del file <strong>/etc/pound/pound.cfg</strong><br />
<strong>Esempio 1:</strong></p>
<p><strong>Semplice configurazione HTTP Proxy </strong><br />
Supponiamo di forwardare le richieste http che arrivano dall”IP pubblico 202.54.10.5 all’IP sulla LAN 192.168.1.5 su cui è configurato un web server Apache sulla porta 8080.<br />
Editiamo il file di configurazione di pound di una distro Debian/Ubuntu:</p>
<p>vim /etc/pound/pound.cfg</p>
<p>Questo è l’aspetto del file:</p>
<pre>ListenHTTP
Address  202.54.10.5
Port          80
Service
BackEnd
Address  192.168.1.5
Port           8080
End
End
End</pre>
<p>Salvare e chiudere il file e restartare Pound:</p>
<p>/etc/init.d/pound restart</p>
<p><strong>Esempio 2</strong><br />
<strong>Semplice configurazione HTTP &amp; HTTPS Proxy<br />
</strong>In questo esempio vediamo come “proxare” una richiesta http e https dallo stesso IP pubblico 202.54.10.5 a due web server 192.168.1.5 e 192.168.1.6, entrambi sulla porta 80:</p>
<pre>ListenHTTP
Address  202.54.10.5
Port          80
End

ListenHTTPs
Address   202.54.10.5
Port           443
Cert           “/etc/ssl/local.server.pem” -–&gt;percorso certificato ssl
End

Service
BackEnd
Address     192.168.1.5
Port              80
Priority       1
Backend
Address     192.168.1.6
Port              80
Priority       3
End
End</pre>
<p>Salviamo il file di configurazione e restartiamo pound.</p>
<p>In questo esempio le richieste alla porta 80 all’ ip 202.54.10.5  vengono inoltrate alla porta 80 del webserver 192.168.1.5, mentre le richieste alla porta 443 dall’ ip 202.54.10.5 vengono inoltrate alla porta 80 del web server 192.168.1.6  e in questo caso pound gestisce il certificato ssl, che è possibile generarsi senza alcuna modifica nel backend del web server, che continua a gestire chiamate in http.</p>
<p><strong>PS:</strong> e&#8217; possibile inoltre impostare una priorità di inoltro del traffico differente, nel caso si disponga di più server web, cosi&#8217; come indicato dalla voce &#8220;Priority&#8221; presente nella configurazione del secondo esempio; minore è la cifra, maggiore sarà la priorità assegnata al server.</p>
<p>Buon divertimento !</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg" medium="image">
			<media:title type="html">redirect</media:title>
		</media:content>
	</item>
	</channel>
</rss>
