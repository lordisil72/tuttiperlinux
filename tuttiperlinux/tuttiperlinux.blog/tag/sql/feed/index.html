<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>sql &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/sql/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Mon, 19 Jan 2015 08:09:04 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>sql &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Couchbase = CouchDB + Membase</title>
		<link>https://tuttiperlinux.blog/2014/12/16/couchbase-couchdb-membase/</link>
					<comments>https://tuttiperlinux.blog/2014/12/16/couchbase-couchdb-membase/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Tue, 16 Dec 2014 10:18:43 +0000</pubDate>
				<category><![CDATA[DB]]></category>
		<category><![CDATA[cassandra]]></category>
		<category><![CDATA[centos]]></category>
		<category><![CDATA[couchbase]]></category>
		<category><![CDATA[couchdb]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[ebay]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[membase]]></category>
		<category><![CDATA[memcache]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[nosql]]></category>
		<category><![CDATA[paypal]]></category>
		<category><![CDATA[redhat]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[ubuntu]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=801</guid>

					<description><![CDATA[Scopriamo perche’ grandi aziende come Ebay,PayPal, LinkedIn, Viber hanno scelto Couchbase. Stupiscono le sue incredibili performance e di quanto sia piu’ veloce di MongoDB e Cassandra . Innanzitutto Il mondo informatico e&#8217; come non mai in continuo fermento ed evoluzione, questi continui cambiamenti a volte sono difficili da seguire ma, spesso portano novita&#8217; interessanti come &#8230; <a href="https://tuttiperlinux.blog/2014/12/16/couchbase-couchdb-membase/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_802" style="width: 310px" class="wp-caption alignleft"><img aria-describedby="caption-attachment-802" data-attachment-id="802" data-permalink="https://tuttiperlinux.blog/2014/12/16/couchbase-couchdb-membase/couchbase-logo/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg" data-orig-size="300,300" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="couchbase-logo" data-image-description="" data-image-caption="&lt;p&gt;Couchbase NoSQL&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg?w=300" class="size-full wp-image-802" src="https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg?w=600" alt="Couchbase NoSQL" srcset="https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg 300w, https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg?w=150 150w" sizes="(max-width: 300px) 100vw, 300px"   /><p id="caption-attachment-802" class="wp-caption-text">Couchbase NoSQL</p></div>
<p>Scopriamo perche’ grandi aziende come Ebay,PayPal, LinkedIn, Viber hanno scelto Couchbase.<br />
Stupiscono le sue incredibili performance e di quanto sia piu’ veloce di MongoDB e Cassandra .</p>
<p><strong>Innanzitutto<br />
</strong>Il mondo informatico e&#8217; come non mai in continuo fermento ed evoluzione, questi continui cambiamenti a volte sono difficili da seguire ma, spesso portano novita&#8217; interessanti come Couchbase NoSQL. Ma di cosa si tratta ??<br />
Nel variegato mondo dei database NoSQL da qualche tempo c&#8217;è una novità: <a class="bbcode_url" href="http://couchdb.apache.org/" target="">CouchDB</a> e <a class="bbcode_url" href="http://www.membase.org/" target="">Membase</a>, insieme alle relative società, si sono unite, dando luogo a un unico prodotto e una sola azienda, entrambi chiamati <a class="bbcode_url" href="http://www.couchbase.com/" target="">Couchbase</a>.</p>
<p><strong>#Couchbase = CouchDB + Membase</strong><br />
Quest&#8217;ultimo unisce le caratteristiche salienti dei predecessori da cui trae origine, ereditando lo <b>storage ad oggetti</b> su disco di <a title="Introduzione a CouchDB" href="http://tuttiperlinux.com/2014/07/26/introduzione-a-couchdb/">CouchDB</a> e le capacità di <b>caching</b> in memoria di Membase.<br />
Interessante e&#8217; anche la possibilità di utilizzare la stessa tecnologia anche su piattaforme mobili, ottenendo con il minimo sforzo la sincronizzazione dei dati fra il dispositivo mobile e il data center grazie alla tecnologia di sincronizzazione dei dati tipica di CouchDB.</p>
<p>In questo primo articolo vedremo i passi necessari per l&#8217;installazione di CouchBase su piattaforma Linux-Ubuntu .</p>
<p>PS: l&#8217;installazione di un sistema di questo tipi non e&#8217; per PC casalignhi infatti le richieste minime sono nell&#8217;ordine di:<br />
<strong>Minimum number of processors required : 4 cores</strong><br />
<strong>Minimum RAM required  : 4 GB</strong></p>
<p>Innanzitutto, occorre scaricare la versione piu&#8217; appropriata al vostro sistema operativo, a questo <a href="http://www.couchbase.com/download" target="_blank">link</a>. Io ho scelto la &#8220;couchbase-server-enterprise_3.0.2-ubuntu12.04_amd64.deb&#8221;<br />
Quindi lanciare il seguente comando :</p>
<p># sudo dpkg -i couchbase-server-enterprise_3.0.2-ubuntu12.04_amd64.deb</p>
<p>ed al termine dell&#8217;installazione, verificare che tutto e&#8217; andato correttamente, digitando nel browser, questo link</p>
<pre class="prettyprint prettyprinted"><span class="com">http://127.0.0.1:8091/</span></pre>
<p>e seguite la procedura di Setup&#8230;&#8230;, una volta ultimata il primo login come Amministratori sara&#8217; automatico e vi ritroverete direttamente all&#8217;interno della console di gestione del DB. Complimenti  il primo step e&#8217; stato ultimato con successo.</p>
<p>Se durante l&#8217;installazione non avete cambiato nulla avrete notato che i file di gestione/configurazione del DB sono stati salvati in <i>/opt/couchbase/&#8230;&#8230;&#8230;/</i> &#8211; Per fare lo shutdown e lo startup, digitare questi comandi</p>
<pre class="prettyprint prettyprinted"><span class="pln"># sudo </span><span class="pun">/</span><span class="pln">etc</span><span class="pun">/</span><span class="pln">init</span><span class="pun">.</span><span class="pln">d</span><span class="pun">/</span><span class="pln">couchbase</span><span class="pun">-</span><span class="pln">server start
</span><span class="pln"># sudo </span><span class="pun">/</span><span class="pln">etc</span><span class="pun">/</span><span class="pln">init</span><span class="pun">.</span><span class="pln">d</span><span class="pun">/</span><span class="pln">couchbase</span><span class="pun">-</span><span class="pln">server stop</span></pre>
<p>Per ogni ulteriore dettaglio nella configurazione per ora vi rimando alla documentazione ufficiale che potete trovare a questo <a href="http://docs.couchbase.com/admin/admin/Couchbase-intro.html">LINK</a> .</p>
<p>Per il momento e&#8217; tutto, spero che queste poche righe abbiano destato l&#8217;interesse verso una soluzione DB ad alte prestazioni interessante qual&#8217;e&#8217; CouchBase.<br />
Bis Bald, a presto!</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/12/16/couchbase-couchdb-membase/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/12/couchbase-logo.jpg" medium="image">
			<media:title type="html">Couchbase NoSQL</media:title>
		</media:content>
	</item>
		<item>
		<title>CouchDB conosciamolo meglio</title>
		<link>https://tuttiperlinux.blog/2014/11/19/couchdb-conosciamolo-meglio/</link>
					<comments>https://tuttiperlinux.blog/2014/11/19/couchdb-conosciamolo-meglio/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 19 Nov 2014 12:26:16 +0000</pubDate>
				<category><![CDATA[DB]]></category>
		<category><![CDATA[acid]]></category>
		<category><![CDATA[apache]]></category>
		<category><![CDATA[cms]]></category>
		<category><![CDATA[couchdb]]></category>
		<category><![CDATA[crm]]></category>
		<category><![CDATA[dbms]]></category>
		<category><![CDATA[document oriented]]></category>
		<category><![CDATA[documentale]]></category>
		<category><![CDATA[erlang]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[locking]]></category>
		<category><![CDATA[mvcc]]></category>
		<category><![CDATA[nosql]]></category>
		<category><![CDATA[rdbms]]></category>
		<category><![CDATA[replicazione]]></category>
		<category><![CDATA[rest]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[subversion]]></category>
		<category><![CDATA[tabelle]]></category>
		<category><![CDATA[webserver]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=674</guid>

					<description><![CDATA[Questo articolo e&#8217; la continuazione della precedente &#8220;Introduzione a CouchDB&#8221; per cui riprenderemo alcune informazioni di base gia viste per poi allargare alcuni importanti concetti ed aspetti che riguardano questo interessantissimo documentale via HTTP. Apache CouchDB e’ un moderno documentale, document-oriented, richiamabile semplicemente con l’HTTP e che al tempo stesso offre le piu’ avanzate funzionalita’ &#8230; <a href="https://tuttiperlinux.blog/2014/11/19/couchdb-conosciamolo-meglio/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png"><img data-attachment-id="214" data-permalink="https://tuttiperlinux.blog/2014/07/26/introduzione-a-couchdb/couch/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png" data-orig-size="160,112" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="couchDB" data-image-description="&lt;p&gt;Performing Web DB&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=160" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=160" class="alignleft size-full wp-image-214" src="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=600" alt="couchDB" srcset="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png 160w, https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=150 150w" sizes="(max-width: 160px) 100vw, 160px"   /></a>Questo articolo e&#8217; la continuazione della precedente &#8220;<a title="Introduzione a CouchDB" href="http://tuttiperlinux.com/2014/07/26/introduzione-a-couchdb/">Introduzione a CouchDB</a>&#8221; per cui riprenderemo alcune informazioni di base gia viste per poi allargare alcuni importanti concetti ed aspetti che riguardano questo interessantissimo documentale via HTTP.</p>
<p><strong><br />
Apache CouchDB</strong> e’ un moderno documentale, document-oriented, richiamabile semplicemente con l’HTTP e che al tempo stesso offre le piu’ avanzate funzionalita’ di replicazione dati e di ricerca in parallelo (Map/Reduce).</p>
<h3><strong>Caratteristiche</strong></h3>
<p>Scritto in: Erlang<br />
Punto principale: Consistenza DB consistency, facilità d’uso<br />
Licenza: Apache<br />
Protocolli: HTTP/REST<br />
Replicazione bidirezionale continua o ad-hoc con individuazione dei conflitti, replicazione master-master<br />
MVCC – le operazioni di scrittura non bloccano le letture<br />
Sono disponibili le versioni precedenti dei documenti<br />
Progettazione crash-only (reliable)<br />
Necessità di compattazioni nel tempo<br />
Viste: embedded map/reduce<br />
Viste formattate: lists &amp; shows<br />
Possibilità di validazione server-side dei documenti<br />
Possibile autenticazione<br />
Aggiornamenti real-time attraverso _changes (!)<br />
Gestione degli allegati e, CouchApps (standalone js apps)<br />
libreria jQuery inclusa<br />
Utilizzo ideale: Per accumulazione dei dati con cambi occasionali sui quali vengono eseguite query predefinite. Situazioni in cui la gestione delle versioni è importante.<br />
Per esempio: CRM, sistemi CMS. Situazioni in cui la replicazione master-master è una caratteristica interessante (ad esempio multisito).</p>
<p><strong>In CouchDB non esistono tabelle</strong>. Il contenuto informativo è suddiviso in diversi database che fungono da contenitori di documenti con strutture potenzialmente disomogenee tra di loro. Il documento è il fulcro di questo software (e di quelli che come lui condividono l’approccio document-oriented).<br />
<strong>Un documento è formato da un insieme di coppie chiave-valore.</strong><br />
A differenza dei database relazionali <strong>CouchDB non possiede il concetto di schema</strong> e quindi ogni documento in ogni database può essere strutturato in modo diverso dagli altri.</p>
<p><strong>Le uniche due chiavi obbligatorie sono</strong>:<br />
<strong>_id </strong>serve per identificare univocamente il documento (è comparabile, semanticamente, alla chiave primaria dei database relazionali)<br />
<strong>_rev </strong>viene utilizzata per la gestione delle revisioni, ad ogni operazione di modifica infatti la chiave &#8220;_rev&#8221; viene aggiornata (questo meccanismo è alla base della prevenzione dei conflitti<br />
in fase di salvataggio su CouchDB).</p>
<p>Questo accorgimento permette inoltre di poter interrogare il DBMS su versioni del documento non più attuali in quanto, con un approccio simile a quello di Subversion, <strong>CouchDB mantiene memoria di ogni revisione, da quella iniziale alla più recente</strong>.</p>
<p>L’altra grande differenza rispetto ai tradizionali RDBMS è il meccanismo di gestione delle query. Nei database relazionali una volta specificate e popolate le tabelle è possibile eseguire query utilizzando un linguaggio conosciuto come SQL (ne esistono vari dialetti ma il concetto non cambia nell’essenza);<br />
a fronte di una query il RDBMS utilizza indici interni e le proprie relazioni per costruire in tempo reale una tabella di risultato (che può, nelle query più semplici, essere un sottoinsieme della tabella di partenza).</p>
<p>Questa soluzione riesce ad essere performante in quanto i dati sono strutturati con questo preciso scopo; inoltre il database non deve conoscere a priori le query che verranno eseguite ma può rispondere a qualsiasi interrogazione, purché sia stilata usando SQL valido.</p>
<h3><strong>Consistenza dei dati e replicazione</strong></h3>
<p><strong>CouchDB non utilizza alcun meccanismo di locking</strong> ma sfrutta l&#8217;MVCC (Multiversion Concurrency Control): ogni modifica di un oggetto ne crea una nuova versione. Le versioni precedenti non vengono cancellate. Se due modifiche vanno in conflitto poiche&#8217; accedono allo stesso documenti, la seconda riceve un errore in save. L&#8217;applicazione deve riprendere l&#8217;ultima versione del documento e rieseguire l&#8217;UPDATE.<br />
L&#8217;isolamento e&#8217; mantenuto solo a livello di un singolo documento, questa e&#8217; una notevole semplificazione, rispetto alla complessa logica transazionale di altri database, ma consente l&#8217;ottimizzazione, la parallelizzazione e la distribuzione dei dati in modo semplice. A livello di accesso al file di dati ogni singola modifica ad un documento rispetta le proprieta ACID (Atomic Consistent Isolated Durable) con la serializzazione delle modifiche sui documenti e la scrittura sincrona sul disco.</p>
<p><strong>Piu&#8217; database CouchDB possono essere collegati tra loro</strong> in modo molto semplice. I database vengono aggiornati tra loro con una replicazione peer-to-peer incrementale implementata nativamente nell&#8217;engine. <strong>CouchDB permette una replicazione bidirezionale asincrona</strong>, utilizza un meccanismo automatico di risoluzione dei conflitti e fornisce una eventual consistency tra i database. Se i database sono ospitati su nodi differenti si ottiene con questo la distribuzione dei dati.<br />
La replicazione di CouchDB puo&#8217; essere utilizzata sia per sincronizzare database locali che per complesse configurazioni con sharding dei dati.</p>
<p>Per lavorare su CouchDB esiste anche la possibilita&#8217; di installare <b>CouchApp, </b>in pratica<b> </b>una serie di script che permettono di costruire completi applicazioni stand-alone per il database usando solo HTML e JavaScript. Poiche&#8217; il database stesso risponde in HTTP e&#8217; possibile concentrare su un solo nodo (eventualmente replicabile) la classica pila applicativa web a tre livelli.</p>
<p>CouchDB si e&#8217; cosi&#8217; rapidamente imposto sul mercato, diventando uno tra i piu&#8217; usati database non relazionali. In pratica i due piu&#8217; diffusi NoSQL documentali sono <b>CouchDB</b> e <b>MongoDB</b>: entrambi sono velocissimi (memorizzano i dati in BSON/JSON), sono scalabili in modo nativo su piu&#8217; nodi e non forniscono un&#8217;interfaccia SQL.</p>
<p>Per una documentazione piu&#8217; dettagliata si rimanda al sito ufficiale di <a href="http://couchdb.apache.org/" rel="nofollow">Apache CouchDB</a>.</p>
<p>&nbsp;</p>
<p>Per ora e&#8217; tutto, alla prossima e, buon divertimento!</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/11/19/couchdb-conosciamolo-meglio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png" medium="image">
			<media:title type="html">couchDB</media:title>
		</media:content>
	</item>
		<item>
		<title>Ottimizzare grazie a Memcached</title>
		<link>https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/</link>
					<comments>https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sun, 14 Sep 2014 23:54:10 +0000</pubDate>
				<category><![CDATA[Networking]]></category>
		<category><![CDATA[balance]]></category>
		<category><![CDATA[bilanciamento]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[front-end]]></category>
		<category><![CDATA[hot key]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[mctop]]></category>
		<category><![CDATA[memcached]]></category>
		<category><![CDATA[nic]]></category>
		<category><![CDATA[sql]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=547</guid>

					<description><![CDATA[Ottimizzazione server dedicato grazie a MemCached Spesso si e&#8217; portati a credere che i meccanismi di cache siano una specie di Panacea, e che dalla loro implementazione non si debba temere alcun  problema : ovviamente non è così. Specialmente se il tuo cloud è dedicato all’erogazione di siti/portali web con volumi importanti l’utilizzo di memcached &#8230; <a href="https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg"><img loading="lazy" data-attachment-id="548" data-permalink="https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/theflash_memcached/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg" data-orig-size="600,337" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="theflash_memcached" data-image-description="&lt;p&gt;Memcached flash website&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=600" class="alignleft size-medium wp-image-548" src="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300&#038;h=168" alt="theflash_memcached" width="300" height="168" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300&amp;h=168 300w, https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=598&amp;h=336 598w, https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=150&amp;h=84 150w, https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg 600w" sizes="(max-width: 300px) 100vw, 300px" /></a>Ottimizzazione server dedicato grazie a MemCached</strong></p>
<p>Spesso si e&#8217; portati a credere che i meccanismi di cache siano una specie di Panacea, e che dalla loro implementazione non si debba temere alcun  problema : <strong>ovviamente non è così</strong>.<br />
Specialmente se il tuo cloud è dedicato all’erogazione di siti/portali web con volumi importanti l’utilizzo di memcached può sicuramente aumentare le performance di quest&#8217;ultimo;  ma può anche introdurre un nuovo point of failure, uno di quelli che non ti aspetti.<br />
Facciamo un esempio, non ti aspetteresti che un’istanza memcached possa rappresentare un collo di bottiglia !, men che meno un pool di istanze bilanciate e, cosa forse ancor più singolare, che lo possano rappresentare a livello di networking. Eppure succede!</p>
<p><strong>Cos’è memcached, e come funziona?</strong><br />
<a href="http://memcached.org/">Memcached</a> è un sistema di caching distribuito ed ha una struttura client/server che permette di servire i dati più richiesti direttamente dalla RAM, riducendo cosi al tempo stesso il carico sul database.<br />
Questo può essere di grande aiuto se si ha la necessità di gestire una quantità di dati davvero importante.<br />
<strong>Sfruttare elaborazioni già effettuate</strong>: questo è il punto di forza di Memcached; infatti raggruppando la cache dei nodi crea una memoria a breve termine che serve per ottimizzare le operazioni ripetute.</p>
<p>Memcached è semplice ma potente. Il suo design semplice promuove un&#8217;implementazione veloce, facilità di sviluppo, e risolve molti dei problemi che ci si trova ad affrontare quando si ha a che fare con grandi cache di dati.</p>
<p>Il server funziona ricevendo una serie di coppie chiave-valore e mantenendole in RAM.<br />
In genere è compito della logica applicativa (quindi della programmazione degli scripts php, ruby, phyton ecc&#8230;) decidere se effettuare un’operazione di scrittura su memcached oppure di lettura, ed e&#8217;sempre compito dell’applicazione computare un hash delle key che invia a memcached e, successivamente, inviare la coppia chiave-valore al server stesso.<br />
Nel caso di un cluster, l’applicazione deve determinare in base all’hash quale nodo memcached contiene quale valore.</p>
<p>Ora, può succedere che alcune coppie chiavi-valore siano molto più utilizzate di altre, queste si definiscono in gergo “hot keys”.<br />
Può succedere inoltre, nel caso che il sito sia molto trafficato, che i front-end web interroghino con preferenza alcune coppie chiave-valore specifiche.<br />
Facciamo un&#8217;altro esempio: immaginiamo di dover gestire la home page di un quotidiano nazionale (a me e&#8217; capitato).<br />
Immaginiamo che il codice che muove quel sito interroghi memcached per evitare che, ad ogni richiesta della home page, vengano fatte delle richieste al database.<br />
Immaginiamo infine che la home page del tuo portale riceva un grosso picco di traffico completamente inatteso (per esempio un terremoto).<br />
Man mano che il traffico aumenta, aumentano le richieste che i front-end devono effettuare al back-end memcached per evitare di interrogare continuamente i database.<br />
Per servire un sito di questo tipo, si sono probabilmente predisposti una mezza dozzina di front-end applicativi, o forse di più, e ciascuno di questi chiama il back-end memcache.<br />
Man mano che il traffico da servire lato pubblico scala verso le decine di Mbit/s, il traffico verso il backend memcached aumenta con un moltiplicatore pari al numero di front-end e questo comincia a saturare la scheda di rete del memcached.<br />
Il traffico aumenta fintanto che la scheda di rete si satura, il sistema crolla, con buona pace di ottimizzazioni lato front-end, bilanciatori di carico, e ottimizzazioni lato SQL.</p>
<p>Se avessimo configurato un cluster memcached alle spalle dei front-end il problema potrebbe comunque presentarsi perchè alcuni nodi del cluster potrebbero avere delle “hot-keys” un po più “hot” delle chiavi degli altri nodi.</p>
<p>Ora, potrebbe anche essere che i memcached contengano solo piccole porzioni di dato e quindi il traffico sulla NIC sia molto contenuto, ma se non siete stati voi ad aver scritto l’applicazione, non potrete esserne certi, quindi si dovra&#8217; quantomeno monitorare la saturazione della NIC e l’eventuale presenza di differenti hot keys sui server.</p>
<p><strong>Come uscirne fuori?</strong><br />
Se la situazione non si è ancora deteriorata del tutto, potreste effettuare l’analisi del traffico in uscita dalla NIC con un packet sniffer e cercare di capire quale sia la chiave “incriminata” e i dati ad essa associati.<br />
Ma c&#8217;e&#8217; da dire che state facendo passare qualche centinaio di Mbit/s su una NIC, un’attività del genere non deve essere una passeggiata anche solo per la mole di dati che si deve processare.<br />
In alternativa, può venirci in aiuto uno strumento come mctop, che permette di tracciare il numero di chiamate, richieste al secondo, e l’uso della banda per ogni singolo pacchetto.<br />
In questo modo, sara&#8217; molto più facile individuare le key che tendono a saturare la banda ed indicare dove ai programmatori o tecnici dove devono intervenire.</p>
<p><strong>Non è solo un problema lato server</strong>.<br />
Come si puo&#8217; immaginare, questo tipo di problemi va affrontato sia lato sistemi che lato sviluppo<br />
In una situazione di emergenza identificare una “hot key” manualmente, potra&#8217; anche andare bene, ma il punto è che dal lato sviluppo applicativo dovranno mettere mano al codice ed essere in grado di effettuare, per quanto possibile, questo tipo di operazione in autonomia migliorando le fasi di test e di pre produzione.<br />
Diventa cosi&#8217; davvero opportuno avere nella propria infrastruttura, dei sistemi di monitoraggio e di alert, che possano segnalare per tempo gli status ed i possibili rischi di saturazione lato NIC.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/14/ottimizzare-grazie-a-memcached/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/theflash_memcached.jpg?w=300" medium="image">
			<media:title type="html">theflash_memcached</media:title>
		</media:content>
	</item>
		<item>
		<title>DB fate largo ai No-SQL</title>
		<link>https://tuttiperlinux.blog/2014/09/10/db-fate-largo-ai-no-sql/</link>
					<comments>https://tuttiperlinux.blog/2014/09/10/db-fate-largo-ai-no-sql/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 10 Sep 2014 12:20:56 +0000</pubDate>
				<category><![CDATA[DB]]></category>
		<category><![CDATA[cassandra]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[dbms]]></category>
		<category><![CDATA[java]]></category>
		<category><![CDATA[language]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[nosql]]></category>
		<category><![CDATA[opensource]]></category>
		<category><![CDATA[redis]]></category>
		<category><![CDATA[sql]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=504</guid>

					<description><![CDATA[I Database NoSQL NO-SQL è un movimento che negli ultimi anni si è molto affermato, producendo dei risultati soddisfacenti con la creazione di progetti e iniziative utilizzate anche su larga scala. Tale movimento vuole “rompere” la storica linea dei database relazionali e definire delle nuove linee guida per l’implementazione di database che non utilizzano il &#8230; <a href="https://tuttiperlinux.blog/2014/09/10/db-fate-largo-ai-no-sql/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png"><img loading="lazy" data-attachment-id="505" data-permalink="https://tuttiperlinux.blog/2014/09/10/db-fate-largo-ai-no-sql/nosql_logo/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png" data-orig-size="492,291" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nosql_logo" data-image-description="&lt;p&gt;No-SQL comparazione tra DB&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png?w=492" class="alignleft size-medium wp-image-505" src="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png?w=300&#038;h=177" alt="nosql_logo" width="300" height="177" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png?w=300&amp;h=177 300w, https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png?w=150&amp;h=89 150w, https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png 492w" sizes="(max-width: 300px) 100vw, 300px" /></a>I Database NoSQL</strong></h3>
<p>NO-SQL è un movimento che negli ultimi anni si è molto affermato, producendo dei risultati soddisfacenti con la creazione di progetti e iniziative utilizzate anche su larga scala. Tale movimento vuole “rompere” la storica linea dei database relazionali e definire delle nuove linee guida per l’implementazione di database che non utilizzano il linguaggio di interrogazione SQL e non siano strettamente legati ad una definizione “rigida” dello schema dati.<br />
La filosofia del <a href="http://it.wikipedia.org/wiki/NoSQL">NO-SQL</a> si può riassumere nei seguenti punti, partendo dalla domanda “Perchè avere altri DBMS se esistono quelli relazionali?”:</p>
<ol>
<li>I database relazionali sono troppo costosi e spesso, quelli che svolgono bene il loro lavoro, sono solo commerciali. NO-SQL abbraccia totalmente la filosofia <strong>open-source</strong>;</li>
<li>NO-SQL è semplice da usare e <strong>non occorre uno specialista di DBMS</strong>. Il paradigma di programmazione è, infatti, ad oggetti;</li>
<li>I dati sono altamente portabili su sistemi differenti, da Macintosh a DOS;</li>
<li>Non definisce uno schema “rigido” (schemaless) e non occorre prototipare i campi, per cui <strong>non esistono </strong><strong>limiti o restrizioni ai dati memorizzati</strong> nei database NO-SQL;</li>
<li>Velocità di esecuzione, di interrogazione di grosse quantità di dati e possibilità di distribuirli su più sistemi eterogenei (replicazione dei dati), con un meccanismo totalmente trasparente all’utilizzatore;</li>
<li>I DBMS NO-SQL <strong>si focalizzano su una scalabilità orizzontale</strong> e non verticale come quelli relazionali.</li>
</ol>
<p>A questo punto passiamo a fare una comparazione tra quelli che attualmente sono tra i piu&#8217; utilizzati , quali :</p>
<pre>Cassandra, MongoDB, CouchDB, Redis, Riak, HBase, Membase e Neo4j :</pre>
<p>** (vedi anche precedente articolo <a title="Not Only SQL" href="http://tuttiperlinux.com/2014/07/24/not-only-sql/">Not Only Sql</a>)<br />
<strong>&#8211; CouchDB</strong></p>
<p>Scritto in: Erlang<br />
Punto principale: Consistenza DB consistency, facilità d’uso<br />
Licenza: Apache<br />
Protocolli: HTTP/REST<br />
Replicazione bidirezionale continua o ad-hoc con individuazione dei conflitti, replicazione master-master<br />
MVCC – le operazioni di scrittura non bloccano le letture<br />
Sono disponibili le versioni precedenti dei documenti<br />
Progettazione crash-only (reliable)<br />
Necessità di compattazioni nel tempo<br />
Viste: embedded map/reduce<br />
Viste formattate: lists &amp; shows<br />
Possibilità di validazione server-side dei documenti<br />
Possibile autenticazione<br />
Aggiornamenti real-time attraverso _changes (!)<br />
Gestione degli allegati e, CouchApps (standalone js apps)<br />
libreria jQuery inclusa<br />
Utilizzo ideale: Per accumulazione dei dati con cambi occasionali sui quali vengono eseguite query predefinite. Situazioni in cui la gestione delle versioni è importante.<br />
Per esempio: CRM, sistemi CMS. Situazioni in cui la replicazione master-master è una caratteristica interessante (ad esempio multisito).</p>
<p><strong>&#8211; Redis</strong></p>
<p>Scritto in: C/C++<br />
Punto principale: Velocità<br />
Licenza: BSD<br />
Protocolli: Telnet-like<br />
Disk-backed in-memory database,<br />
In questo momento non include il disk-swap (VM e Diskstore sono stati abbandonati)<br />
Replicazione master-slave<br />
Recupero di valori semplici o intere tables a partire da una chiave<br />
suppporto ad operazioni complesse come ZREVRANGEBYSCORE.<br />
INCR (incremento) e  simili (molto utili per gestire limitazioni di valore e statistiche)<br />
permette l’uso di insiemi (sets) e operazioni su essi (unione/differenza/intersezione)<br />
permette l’uso di liste (lists) e  operazioni su esse (queue; blocking pop)<br />
permette l’uso di hashes (oggetti dotati di campi)<br />
permette l’uso di insiemi ordinati (utili per classifiche, e ricerche su range di valori)<br />
Redis implementa correttamente le transazioni (!)<br />
I valori memorizzati possono avere una scadenza temporale (sistemi di cache)<br />
Implementa facilmente il messaging Publisher/Subscriber (!)<br />
Utilizzo ideale: Adatto a moli di dati (residenti in memoria) di dimensione nota che cambiano frequentemente .<br />
Per esempio: Quotazioni azionistiche. Analisi. Gestione dati in Real-time. Comunicazioni in Real-time.</p>
<p><strong>&#8211; MongoDB</strong></p>
<p>Scritto in: C++<br />
Punto principale: Mantiene alcune proprietà utili del modello SQL (Query, index) molto facili da usare.<br />
Licenza: AGPL (Drivers: Apache)<br />
Protocollo: Specifico, binario (BSON)<br />
Replica Master/slave (munita di  failover quando si usano i  “replica sets”)<br />
Lo Sharding è parte integrante del sistema<br />
Le intterrogazioni a db (queries) sono espressioni javascript<br />
Permette l’uso di funzion i javascript lato server<br />
Update-in-place migliore rispetto a CouchDB<br />
Usa “memory mapped files” per la persistenza dei dati<br />
Favorisce la velocità rispetto alle funzionalità implementate<br />
Journaling (opzione –journal) fortemente consigliato<br />
Sui sistemi a 32bit risente di una  limitazione sulla quantità di dati a circa 2.5Gb<br />
Un database vuoto occupa comunque 192Mb<br />
GridFS per la memorizzazione di “big data + metadata” (effettivamente non è un  FS)<br />
Indicizzazione geospaziale Geospatial indexing<br />
Utilizzo ideale: se si necessita di query dinamiche. Se si preferisce lavorare con gli indici rispetto ad usare algoritmi map/reduce. Buono se si ha bisogno di velocità quando si lavora con grandi moli di dati.  Adatto a tutti gli scenari in cui si usa CouchDB e non si può scegliere quest’ultimo perchè i dati cambiano troppo riempiendo la memoria fisica.<br />
Per esempio: tutte le situazioni in cui si vorrebbe usare MySQL o PostgreSQL senza avere colonne definite a priori.</p>
<p><strong>&#8211; Riak</strong></p>
<p>Scritto in: Erlang &amp; C, some Javascript<br />
Punto principale: Fault tolerance<br />
Licenza: Apache<br />
Protocollo: HTTP/REST o custom binary<br />
Trade-offs modulabili per replica e distribuzione (N, R, W)<br />
Hooks di pre- e post-commit in JavaScript o Erlang, per la validazione e la sicurezza.<br />
Map/reduce in JavaScript o Erlang<br />
Links &amp; link walking per utilizzarlo come database a grafi<br />
Indici secondari: ricerca nei metadati<br />
Supporto per oggetti di grandi dimensioni (Luwak)<br />
Edizioni sia “open source” che “enterprise”<br />
Ricerca full-text, indexing e querying con il Riak Search server (beta)<br />
Sta migrando lo storing di backend da “Bitcask” al “LevelDB” di Google<br />
La multi-site replication replication senza alcun master e il monitoring SNMP necessitano di una licenza commerciale<br />
Utilizzo ideale: se si vuole qualcosa di simile a Cassandra (Dynamo), ma non si ha nessuna intenzione di avere a che fare con la realtiva inerente complessità. Se si ha bisogno di un’ottima scalabilità, disponibilità e fault-tolerance per un solo sito ma si è disposti a pagare per la replica multi-sito.<br />
Per esempio: Raccolta dei dati di point-of-sales. Sistemi di controllo aziendali. Situazioni in cui anche il downtime di alcuni secondi può essere rilevante. Potrebbe essere anche utilizzato come un web server estremamente aggiornabile.</p>
<p><strong>&#8211; Membase</strong></p>
<p>Scritto in: Erlang &amp; C<br />
Punto principale: Compatibile con memcache ma con persistenza e clustering<br />
Licenza: Apache 2.0<br />
Protocollo: memcached con estensioni<br />
Accesso molto veloce ai dati mediante chiave (200k+/sec)<br />
Persistenza su disco<br />
Tutti i nodi sono identici (replicazione master-master)<br />
Fornisce un sistema a buckets simile a memcached<br />
De-duplicazione delle scritture per ridurre IO<br />
Interfaccia GUI per la gestione dei cluster molto interessante<br />
Aggiornamento software senza mettere offline il database<br />
Proxy di connessione per il pooling e il multiplexing (Moxi)<br />
Utilizzo ideale: Qualsiasi applicazione dove un bassa latenza dell’accesso ai dati, un’alta concorrenzialità e un’alta disponibilità degli stessi sono requisiti chiave.<br />
Per esempio: Casi in cui c’è necessità di bassa latenza come l’erogazione di servizi di pubblicità mirata (ad targeting)  o alta concorrenza come il giochi online (per esempio Zynga).</p>
<p><strong>&#8211; Neo4j<br />
</strong></p>
<p>Scritto in: Java<br />
Punto principale: Database a grafi o dati connessi<br />
Licenza: GPL, salcune caratterstiche con AGPL/commerciale<br />
Protocollo: HTTP/REST (o incluso in  Java)<br />
Standalone, o includibile nelle applicazioni Java<br />
Piena conformità ACID (incluso i dati durable)<br />
Sia i nodi che le releazioni possono avere dei metadati<br />
Linquaggio di query basato su pattern-matching (“Cypher”)<br />
Può anche essere usato il linguaggio di attraversamento dei gravi “Gremlin”<br />
Indicizzazione dei nodi, delle chiavi e delle relazioni<br />
Piacevole interfaccia di amministrazione web<br />
Sono disponibili diversi algoritmi di ricerca dei percorsi<br />
Ottimizzato per le letture<br />
Ha le transazioni (nelle API Java)<br />
Si può usare il linguaggio di scripting Groovy<br />
Backup online, monitoraggio avanzato e alta disponibilità con licenza AGPL/commerciale<br />
Utilizzo ideale: Per dati interconnessi, semplici o complessi, con struttura a grafo. In questo senso Neo4j is è un po’ diverso dagli altri database noSQL.<br />
Per esempio: Relazioni sociali, collegamenti nei trasposti pubblici, mappe di strade, topologie di rete.</p>
<p><strong>&#8211; Cassandra</strong></p>
<p>Scritto in: Java<br />
Punto principale: Migliore di BigTable e Dynamo<br />
Licenza: Apache<br />
Protocollo: Proprietario, binario (Thrift)<br />
Distribuzione e replicazione attivabile (N, R, W)<br />
Query possibili mediante colonne e insiemi di chiavi<br />
Carattersitiche simili a BigTable: colonne, famiglie di colonne<br />
Indici secondati<br />
La scrittura è molto più veloce della lettura(!)<br />
Mappatura e riduzione possibile mediante Apache Hadoop<br />
I admit being a bit biased against it, because of the bloat and complexity it has partly because of Java (configuration, seeing exceptions, etc)<br />
Utilizzo ideale: Quando si scrive più che leggere (logging). Se ogni componente del sistema deve essere in Java.<br />
Per esempio: Sistemi bancari e industria finanziaria.<br />
Inoltre, siccome le scritture sono più veloci delle letture, una nicchia naturale è l’analisi dei dati in tempo reale.</p>
<p><strong>&#8211; HBase</strong></p>
<p>Scritto in: Java<br />
Punto principale: miliardi di righe con milioni di colonne<br />
Licenza: Apache<br />
Protocollo: HTTP/REST (anche Thrift)<br />
Modellato dopo BigTable<br />
Mappatura e riduzione con Hadoop<br />
Costrutti query push down attraverso scansione lato server e con filtri per il get<br />
ottimizzazione per le query in tempo reale<br />
E’ un gateway Thrift con alte performance<br />
HTTP supports XML, Protobuf, and binary<br />
Cascading, hive, and pig source and sink modules<br />
Shell basata su Jruby (JIRB)<br />
Punti di ripristino multipli<br />
Rolling restart for configuration changes and minor upgrades<br />
L’accesso random ai dati è paragonabile a quello di MySQL<br />
Utilizzo ideale: Se siete innamorati di BigTable.   e quando c’è la necessità di un accesso in lettura e scrittura, random e in tempo reale alla grande quantità di dati.<br />
Per esempio: il database dei messaggi in Facebook.</p>
<p>&nbsp;</p>
<p>La scelta e&#8217; davvero varia a seconda del compito che vi serve maggiormente venga svolto dal DB che avrete prescelto, quindi perche&#8217; non provarli ?</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/10/db-fate-largo-ai-no-sql/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/nosql_logo.png?w=300" medium="image">
			<media:title type="html">nosql_logo</media:title>
		</media:content>
	</item>
		<item>
		<title>Not Only SQL</title>
		<link>https://tuttiperlinux.blog/2014/07/24/not-only-sql/</link>
					<comments>https://tuttiperlinux.blog/2014/07/24/not-only-sql/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Thu, 24 Jul 2014 21:09:27 +0000</pubDate>
				<category><![CDATA[DB]]></category>
		<category><![CDATA[nosql]]></category>
		<category><![CDATA[orizzontale]]></category>
		<category><![CDATA[rdbms]]></category>
		<category><![CDATA[scalare]]></category>
		<category><![CDATA[sql]]></category>
		<category><![CDATA[tabelle]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/2014/07/24/not-only-sql/</guid>

					<description><![CDATA[NoSQL è l’acronimo di &#8220;Not only SQL&#8221; e viene usato generalmente per indicare quei database che non usano un modello di dati relazionale e quindi potrebbero non usare SQL come linguaggio di interrogazione. Dunque il concetto è di per se’ stesso più antico dei RDBMS, eppure è tornato in auge quando, per varie motivazioni, i &#8230; <a href="https://tuttiperlinux.blog/2014/07/24/not-only-sql/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_206" style="width: 212px" class="wp-caption alignnone"><a href="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png"><img loading="lazy" aria-describedby="caption-attachment-206" data-attachment-id="206" data-permalink="https://tuttiperlinux.blog/nosql/" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png" data-orig-size="278,256" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="nosql" data-image-description="" data-image-caption="&lt;p&gt;NoSQL Database&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png?w=278" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png?w=278" class=" wp-image-206" src="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png?w=202&#038;h=186" alt="NoSQL Database" width="202" height="186" srcset="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png?w=202&amp;h=186 202w, https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png?w=150&amp;h=138 150w, https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png 278w" sizes="(max-width: 202px) 100vw, 202px" /></a><p id="caption-attachment-206" class="wp-caption-text">NoSQL Database</p></div>
<p><strong>NoSQL</strong> è l’acronimo di &#8220;Not only SQL&#8221; e viene usato generalmente per indicare quei database che <strong>non usano un modello di dati relazionale</strong> e quindi potrebbero non usare SQL come linguaggio di interrogazione. Dunque il concetto è di per se’ stesso più antico dei RDBMS, eppure è tornato in auge quando, per varie motivazioni, i database <strong>non relazionali</strong> hanno mostrato diversi vantaggi, rispetto ai database SQL tradizionali.</p>
<p>Una delle principali motivazioni per l’uso di tali database è rappresentata dalla scalabilità. La scalabilità è un requisito sempre più importante per le applicazioni web, e ciò è dovuto a molti fattori: l’esplosione del numero di utenti della rete (letteralmente esponenziale negli ultimi dieci anni secondo i dati del ISC Domain Survey ), la sempre maggiore diffusione di OpenID, quindi la sinergia tra le varie community e tra esse e i fornitori di servizi, ma anche la crescente disponibilità di dispositivi con accesso ad Internet come smartphone, tablet e altri dispositivi portatili.</p>
<p><strong>La scalabilita&#8217; </strong></p>
<p>La <strong>scalabilita&#8217; orizzontale</strong> si ha se l’aumento delle risorse si riferisce all’aumento dei nodi nel sistema, cioè il sistema riesce a parallelizzare il carico di lavoro e gestire il</p>
<ul>
<li>fault tolerance</li>
<li>load balancing</li>
<li>high availability</li>
</ul>
<p>Avere piu&#8217; macchine per poter disrtibuire e replicare i dati su piu&#8217; nodi, questo lo rende ideale per ambienti quali</p>
<ul>
<li>ambienti distribuiti</li>
<li>affidabilita&#8217;</li>
<li>elevate prestazioni</li>
</ul>
<p>il tutto in bundle , senza bisogno di software aggiuntivi.</p>
<h4>Scalabilità verticale</h4>
<p>La <strong>scalabilità verticale</strong> si ottiene quando, per aumentare le prestazioni dell’intero sistema, si aumentano le risorse di un singolo nodo del sistema, ad esempio utilizzando una CPU con frequenza maggiore o incrementando la memoria disponibile. Il vantaggio di questo tipo di scalabilità è che generalmente non è necessario modificare le applicazioni, ne’ sono richiesti interventi amministrativi. Lo svantaggio consiste innanzitutto nel costo, perche’ l’aggiornamento spinto di una macchina può essere economicamente molto più gravoso dell’acquisto di una ulteriore macchina di pari potenza.</p>
<p>I principali metodi d’implementazione dei database <strong>NoSQL</strong> sono i seguenti:</p>
<p><strong>Coloumnfamily</strong>: i dati sono organizzati in righe e colonne, ma le righe possono avere quante colonne si vogliono e non c’è bisogno di definire le colonne come prima cosa.</p>
<p><strong>Document store</strong>: è l’evoluzione del metodo key/value, rispetto ai normali database relazionali invece che immagazzinare i dati in tabelle con dei campi fissi, questi vengono messi in un documento che può contenere illimitati campi di illimitata lunghezza, così se ad esempio di una persona conosciamo solo nome e cognome, ma magari di un’altra persona anche indirizzo, data di nascita e codice fiscale, si evita che per il primo nominativo ci siano campi inutilizzati che occupano inutilmente spazio.</p>
<p><strong>Graph</strong>: i dati vengono immagazzinati sotto forma di strutture a grafi, rendendo più performante l’accesso a questi da applicativi orientati agli oggetti.</p>
<p><strong>Key/Value</strong>: in questo caso i dati vengono immagazzinati in un elemento che contiene una chiave assieme ai dati veri e propri, questo metodo è il più semplice da implementare, ma anche il più inefficiente se la maggior parte delle operazioni riguardano soltanto una parte di un elemento.</p>
<h3> </h3>
<h3><strong>Pro e Contro dei database non relazionali</strong></h3>
<p><strong>Vantaggi</strong></p>
<ul>
<li>Dato che un elemento contiene tutte le informazioni necessarie <strong>non serve usare</strong> i <strong>dispendiosi</strong> (in termini di performance) <strong>JOIN</strong> come invece avviene per i database relazionali.</li>
</ul>
<ul>
<li>La <strong>semplicità</strong> di questi database è uno degli elementi fondamentali, è proprio questo che permette di scalare in orizzontale in maniera così efficiente, molti NRDBMS, infatti, permettono di <strong>aggiungere nodi a caldo in maniera impercettibile dall’utente finale</strong>.</li>
</ul>
<ul>
<li>Scegliendo un database adatto alla mappatura più diretta alle object classes del proprio applicativo si possono ridurre di molto i tempi dedicati allo sviluppo del metodo di scambio dati tra il database e l’applicativo stesso (il cosiddetto object-relational mapping che è invece necessario in presenza di database relazionali).</li>
</ul>
<p><strong>Svantaggi</strong></p>
<ul>
<li>La semplicità di questi database, però, porta anche alla <strong>mancanza dei controlli fondamentali sull’integrità dei dati</strong>, il compito ricade quindi totalmente sull’applicativo che dialoga col database che ovviamente dovrebbe essere testato in modo molto approfondito prima di essere messo in produzione. Per fare un esempio, se avessimo un database dei clienti coi relativi ordini effettuati immagazzinati in elementi diversi, anche se è possibile definire una relazione attraverso le chiavi, in un database non relazionale alla cancellazione di un cliente tutti gli ordini resterebbero comunque nel database, è quindi l’applicativo che una volta impartito il comando di cancellazione dell’utente X deve anche andare a cancellare tutti i relativi ordini, cosa che invece in un database relazionale è gestita direttamente dal database stesso.</li>
</ul>
<ul>
<li>La mancanza di uno standard universale (come può essere l’SQL) è un’altra delle pecche di questi database non relazionali, ogni database ha infatti le proprie API e il suo metodo di storing e di accesso ai dati. Detto questo, risulta palese che se lo sviluppo del database sul quale abbiamo basato il nostro applicativo venisse interrotto, il passaggio ad un altro database non sarebbe sicuramente una cosa immediata, ma richiederebbe alcuni cambi più o meno radicali da apportare all’applicativo, è quindi bene tenere in considerazione la cosa al momento del brainstorming iniziale.</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/07/24/not-only-sql/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/07/nosql.png" medium="image">
			<media:title type="html">NoSQL Database</media:title>
		</media:content>
	</item>
	</channel>
</rss>
