<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>nginx &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/nginx/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Thu, 19 Mar 2015 17:07:14 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>nginx &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Ansible &#8211; automazione IT e Configuration Management (II parte)</title>
		<link>https://tuttiperlinux.blog/2015/03/19/ansible-automazione-it-e-configuration-management-ii-parte/</link>
					<comments>https://tuttiperlinux.blog/2015/03/19/ansible-automazione-it-e-configuration-management-ii-parte/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Thu, 19 Mar 2015 17:07:14 +0000</pubDate>
				<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[WebServer]]></category>
		<category><![CDATA[ansible]]></category>
		<category><![CDATA[ansible galaxy]]></category>
		<category><![CDATA[api]]></category>
		<category><![CDATA[automazione it]]></category>
		<category><![CDATA[configuration management]]></category>
		<category><![CDATA[deploy]]></category>
		<category><![CDATA[drupal]]></category>
		<category><![CDATA[forwarded port]]></category>
		<category><![CDATA[linux blog in italiano]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[nginx]]></category>
		<category><![CDATA[oracle]]></category>
		<category><![CDATA[playbook]]></category>
		<category><![CDATA[provisioning]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[tomcat]]></category>
		<category><![CDATA[vagrant]]></category>
		<category><![CDATA[versioning]]></category>
		<category><![CDATA[virtual environment]]></category>
		<category><![CDATA[web dashboard]]></category>
		<category><![CDATA[webserver]]></category>
		<category><![CDATA[yml]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=1073</guid>

					<description><![CDATA[&#160; &#160; &#160; &#160; &#160; &#160; Nel primo articolo &#8220;Ansible per l’automazione IT ed il Configuration Management&#8221; abbiamo descritto le caratteristiche principali di questo interessante prodotto per il Configuration Management. In questo secondo articolo descriveremo con degli esempi come utilizzare nel concreto Ansible. Per preparare il nostro ambiente di lavoro sfrutteremo un&#8217;altro software, che rappresenta, anch&#8217;esso &#8230; <a href="https://tuttiperlinux.blog/2015/03/19/ansible-automazione-it-e-configuration-management-ii-parte/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1078" style="width: 433px" class="wp-caption alignleft"><img loading="lazy" aria-describedby="caption-attachment-1078" data-attachment-id="1078" data-permalink="https://tuttiperlinux.blog/2015/03/19/ansible-automazione-it-e-configuration-management-ii-parte/multistage-ansible/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg" data-orig-size="750,280" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Ansible + Vagrant Environment" data-image-description="&lt;p&gt;Ansible + Vagrant Environment&lt;/p&gt;
" data-image-caption="&lt;p&gt;Ansible + Vagrant Environment&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=600" class=" wp-image-1078" src="https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=423&#038;h=158" alt="Ansible + Vagrant Environment" width="423" height="158" srcset="https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=423&amp;h=158 423w, https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=150&amp;h=56 150w, https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=300&amp;h=112 300w, https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg 750w" sizes="(max-width: 423px) 100vw, 423px" /><p id="caption-attachment-1078" class="wp-caption-text">Ansible + Vagrant Environment</p></div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Nel primo articolo &#8220;<a title="Ansible per l’automazione IT ed il Configuration Management" href="http://tuttiperlinux.com/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/">Ansible per l’automazione IT ed il Configuration Management</a>&#8221; abbiamo descritto le caratteristiche principali di questo interessante prodotto per il Configuration Management. In questo secondo articolo descriveremo con degli esempi come utilizzare nel concreto Ansible.</p>
<p>Per preparare il nostro ambiente di lavoro sfrutteremo un&#8217;altro software, che rappresenta, anch&#8217;esso una delle grandi novita&#8217; del Web degli ultimi mesi come <a href="https://www.vagrantup.com/">Vagrant</a>, di cui abbiamo parlato nell&#8217;articolo &#8220;<a title="Virtualizzazione e provisioning senza sforzo" href="http://tuttiperlinux.com/2015/01/03/virtualizzazione-e-provisioning-senza-sforzo/">Virtualizzazione e provisioning senza sforzo</a>&#8220;.</p>
<p>configuriamoci l&#8217;ambiente Vagrant:</p>
<pre>$ vagrant box add pre http://files.vagrantup.com/precise32.box
$ vagrant init precise32
$ vagrant up</pre>
<p>a seguito dell’ultimo comando, vedremo dei messaggi come questi:</p>
<pre>Bringing machine 'default' up with 'virtualbox' provider...
[default] Importing base box 'precise32'...
[default] Matching MAC address for NAT networking...
[default] Setting the name of the VM...
[default] Clearing any previously set forwarded ports...
[default] Clearing any previously set network interfaces...
[default] Preparing network interfaces based on configuration...
[default] Forwarding ports...
[default] -- <strong>22 =&gt; 2222</strong> (adapter 1)
[default] Booting VM...
[default] Waiting for machine to boot. This may take a few minutes...
[default] Machine booted and ready!
Guest Additions Version: 4.2.0
VirtualBox Version: 4.3
[default] Mounting shared folders...
[default] -- /vagrant

</pre>
<p>Vagrant ha quindi scaricato e creato per noi una macchina virtuale Ubuntu Precise (32bit). Scorrendo i messaggi ci sono due cose importanti da notare: la prima è che il traffico sulla porta 2222 del nostro pc locale sarà inoltrato alla porta 22 della macchina virtuale; la seconda è che l’utente “vagrant” sulla macchina remota può connettersi con la password “vagrant” ed ha già i privilegi per diventare root con sudo. Aggiorniamo quindi l&#8217;inventario delle macchine che decidete di coinvolgere modificando il file /etc/ansible/hosts</p>
<p>Dopo aver preso confidenza con Vagrant iniziamo la configurazione dell’ambiente per <a href="https://www.ansible.com/">Ansible</a>, iniziando ad usarlo per automatizzare i compiti di ogni giorno.</p>
<p>Configuriamo il file /etc/ansible/hosts tramite comando:</p>
<pre># sudo bash -c 'echo [web] &gt;&gt; /etc/ansible/hosts'
# sudo bash -c 'echo 127.0.0.1:2222 ansible_ssh_user=vagrant ansible_ssh_pass=vagrant &gt;&gt; /etc/ansible/hosts'</pre>
<p>Verifichiamo che ansible sia in grado di leggere correttamente i parametri inseriti nel file hosts usando il seguente comando:</p>
<pre># ansible -m ping all
127.0.0.1 | success &gt;&gt; {
"changed": false,
"ping": "pong"
}</pre>
<p><strong>Ansible facts</strong><br />
come possiamo essere sicuri che la macchina a cui ci stiamo connettendo sia quella giusta ? Diamo un’occhiata ai “facts”, ovvero a tutte le informazioni che Ansible raccoglie…</p>
<pre># ansible web -m setup | less</pre>
<p>otteniamo cosi&#8217; una serie di dati in formato JSON tra cui notiamo che il nostro nuovo server ha come hostname ‘localhost’.<br />
A titolo didattico scriveremo un playbook per installare un webserver nginx sul nuovo server.</p>
<p>Ora apriamo un editor per iniziare a scrivere il nostro playbook che si chiamera&#8217; <strong>nginx.yml</strong> :</p>
<pre>--- <strong>PLAYBOOK ottimizzato su Centos Linux</strong>
- name: installa NGINX e avvia il servizio
   remote_user: root
   sudo: yes
   hosts: web
   tasks:
   - name: installazione Nginx
     apt: pkg=nginx state=installed update_cache=true
     notify:
     - start nginx
   handlers:
     - name: start nginx
     service: name=nginx state=started
</pre>
<p>Come possiamo notare nel playbook abbiamo editato una lista di task, uno per ogni “step” del nostro compito.<br />
Se stiamo usando virtualbox come hypervisor, dobbiamo aggiungere una riga al file (bastera&#8217; solo decommentarla) di configurazione di vagrant perché attivi il forwarding della porta 80 della guest sulla porta 8080 del nostro pc.</p>
<p>(vedi <a href="https://docs.vagrantup.com/v2/networking/forwarded_ports.html">https://docs.vagrantup.com/v2/networking/forwarded_ports.html</a>)</p>
<pre>config.vm.network "forwarded_port", guest: 80, host: 8080</pre>
<p>e dare il comando per ricaricare la virtual machine con la nuova configurazione:</p>
<pre>vagrant reload
[default] Attempting graceful shutdown of VM...
[default] Clearing any previously set forwarded ports...
[default] Clearing any previously set network interfaces...
[default] Preparing network interfaces based on configuration...
[default] Forwarding ports...
[default] -- 22 =&gt; 2222 (adapter 1)
[default] -- <strong>80 =&gt; 8080</strong> (adapter 1)
[default] Booting VM...
[default] Machine booted and ready!</pre>
<p>Ora possiamo lanciare il playbook</p>
<pre># ansible-playbook nginx.yml

PLAY [installa NGINX e avvia il servizio] *****************************

GATHERING FACTS ***************************************************************
ok: [127.0.0.1]

TASK: [installazione Nginx] ***************************************************
changed: [127.0.0.1]

NOTIFIED: [start nginx] *******************************************************
changed: [127.0.0.1]

PLAY RECAP ********************************************************************
127.0.0.1 : ok=3 changed=2 unreachable=0 failed=0
</pre>
<p>sulla macchina virtuale potrete visualizzare, dal syslog, quello che sta accadendo:</p>
<p>ansible-apt: Invoked with dpkg_options=force-confdef,force-confold upgrade=None force=False package=[&#8216;nginx&#8217;] purge=False state=installed update_cache=True pkg=nginx default_release=None install_recommends=True deb=None cache_valid_time=None<br />
Mar 19 15:59:33 precise32 ansible-service: Invoked with name=nginx pattern=None enabled=None state=started sleep=None arguments= runlevel=default</p>
<p>ora sulla macchina virtuale mi ritrovo con l&#8217;nginx attivo e rispondente all&#8217;indirizzo 127.0.0.1:8080</p>
<h1>Welcome to nginx!</h1>
<p>Come gia accennato nel primo articolo la curva di apprendimento di questo ottimo strumento di Management dei server e&#8217; davvero bassa e funzionale, ed in poco tempo si e&#8217; in grado di gestire un ambiente ad alto volume di macchine.</p>
<p>Questa è solo una semplice introduzione al mondo di Ansible, e prima di concludere vi faccio inoltre presente che Ansible non è solo usufruibile da linea di comando ma presso <a href="http://www.ansible.com/tower">il sito ufficiale</a> è disponibile una <strong>web dashboard</strong> che permette di controllare i job, avere report, statistiche e così via.</p>
<p>Esiste anche <a href="https://galaxy.ansible.com/">Ansible Galaxy</a> , che è invece un repository comunitario di “ricette”, playbooks, task moduli e tutto quello che si può immaginare … Quindi se doveste installare e configurare software come tomcat, oracle, mongodb, jenkins, drupal, rabbitmq e tanti altri, troverete già tutto pronto.<br />
Di sicuro una base di partenza molto comoda per le vostre personalizzazioni!</p>
<p>Se tutto ciò non bastasse ancora, Ansible ha una API estremamente chiara e flessibile per scrivere moduli custom in Python o qualsiasi altro linguaggio, un esempio concreto</p>
<p>#AnsibleConfigurationManagement</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2015/03/19/ansible-automazione-it-e-configuration-management-ii-parte/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2015/03/multistage-ansible.jpg?w=300" medium="image">
			<media:title type="html">Ansible + Vagrant Environment</media:title>
		</media:content>
	</item>
		<item>
		<title>Nginx HTTP 2.0 supportato entro fine 2015</title>
		<link>https://tuttiperlinux.blog/2015/03/02/nginx-http-2-0-supportato-entro-fine-2015/</link>
					<comments>https://tuttiperlinux.blog/2015/03/02/nginx-http-2-0-supportato-entro-fine-2015/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Mon, 02 Mar 2015 22:09:19 +0000</pubDate>
				<category><![CDATA[Networking]]></category>
		<category><![CDATA[News]]></category>
		<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[api]]></category>
		<category><![CDATA[google spdy]]></category>
		<category><![CDATA[http 2.0]]></category>
		<category><![CDATA[linux blog in italiano]]></category>
		<category><![CDATA[multiplexing]]></category>
		<category><![CDATA[nginx]]></category>
		<category><![CDATA[protocollo tls]]></category>
		<category><![CDATA[rfc]]></category>
		<category><![CDATA[web server]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=1054</guid>

					<description><![CDATA[Nginx supporta da sempre l’attuale protocollo HTTP 1.1 ed il protocollo di Google SPDY. Con l’annuncio di HTTP 2.0, Nginx è pronta a convertire il supporto SPDY verso il neonato HTTP 2.0 entro la fine di quest’anno. Il protocollo HTTP 2.0 è la nuova generazione del protocollo attuale e su cui si basa l’intera Internet, &#8230; <a href="https://tuttiperlinux.blog/2015/03/02/nginx-http-2-0-supportato-entro-fine-2015/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1055" style="width: 277px" class="wp-caption alignleft"><img aria-describedby="caption-attachment-1055" data-attachment-id="1055" data-permalink="https://tuttiperlinux.blog/2015/03/02/nginx-http-2-0-supportato-entro-fine-2015/http_2-0/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg" data-orig-size="267,189" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Nginx e supporto HTTP 2.0" data-image-description="&lt;p&gt;Nginx e supporto HTTP 2.0&lt;/p&gt;
" data-image-caption="&lt;p&gt;Nginx e supporto HTTP 2.0&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg?w=267" data-large-file="https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg?w=267" class="size-full wp-image-1055" src="https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg?w=600" alt="Nginx e supporto HTTP 2.0" srcset="https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg 267w, https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg?w=150 150w" sizes="(max-width: 267px) 100vw, 267px"   /><p id="caption-attachment-1055" class="wp-caption-text">Nginx e supporto HTTP 2.0</p></div>
<p>Nginx supporta da sempre l’attuale protocollo HTTP 1.1 ed il protocollo di Google <strong>SPDY</strong>. Con l’annuncio di HTTP 2.0, Nginx è pronta a convertire il supporto SPDY verso il neonato HTTP 2.0 entro la fine di quest’anno.</p>
<p>Il protocollo <strong>HTTP 2.0</strong> è la nuova generazione del protocollo attuale e su cui si basa l’intera Internet, che viene adesso rinnovato dopo circa 16 anni.</p>
<p>Questo non significa certo che lo standard è stato finalizzato ed è appropriato all’operatività, ma indica che tutte le sue specifiche sono state definite in modo conclusivo e la documentazione può passare al gruppo RFC per l’approvazione finale come standard definitivo.</p>
<p id="TWP17" class="twUnmatched">Comunque, anche dopo la dichiarazione a standard, il protocollo non entrera&#8217; subito in attività, anche perché dovrà, prima di tutto, essere implementato e supportato nei browser e nei Web server.</p>
<p>Fra i Web server, Nginx si dice comunque pronto a supportare questa nuova tecnologia e il motivo di questa sicurezza sta nel pieno supporto alla versione draft 3.1 di SPDY, di cui Google ha deciso l’interruzione dello sviluppo e l’esclusione da Chrome.</p>
<p>Il fatto che il protocollo HTTP 2.0 sia gran parte basato su SPDY permette a Nginx di avere già una solida base di codice pronto per essere riutilizzato ai fini di ospitare il nuovo HTTP quando questo diventerà lo standard. Secondo Owen Garrett, responsabile di prodotto per Nginx : &#8221; l’implementazione nel Web browser sarà facile e snella, in quanto la maggior parte dei siti Web SPDY già viene eseguita correttamente in Nginx &#8220;.</p>
<p id="TWP17" class="twUnmatched"><strong>HTTP/2</strong> si baserà, inoltre, sulle stesse API che già conoscono e usano gli sviluppatori del web, ma in più offrirà feature esclusive a cui questi possono attingere. Fino ad oggi, ad esempio, bisognava adottare alcune tecniche di ottimizzazione per impedire alla pagina di effettuare troppe richieste HTTP. Il nuovo protocollo permetterà invece l&#8217;esecuzione di un numero superiore di richieste contemporanee, attraverso una tecnica chiamata <strong>multiplexing </strong>, senza che queste blocchino il caricamento degli elementi della pagina.</p>
<p id="TWP18" class="twUnmatched"><strong>HTTP/2 effettua un numero di connessioni inferiore</strong> rispetto alle tecnologie attuali, fattore che si traduce con un carico minore richiesto ai server e alle reti per il caricamento dei dati. Il nuovo protocollo supporta TLS ma non obbligherà all&#8217;implementazione del layer di crittografia.</p>
<p class="twUnmatched">Uno dei più <strong>importanti cambiamenti</strong> di HTTP 2.0 infatti sara&#8217; la <strong>crittografia </strong>basata<strong> su protocollo TLS</strong>, a cui Nginx dice di voler dare un approccio implementativo persistente. Inoltre, il nuovo protocollo Internet introduce alcune differenze nella gestione delle priorità, in modo da fornire un maggiore controllo sui flussi di traffico. Sempre secondo Garrett, la maggiore sfida non sarà tanto nell’implementazione nei browser e nei Web server, quanto nell’adeguamento dei siti Web, che dovranno essere ottimizzati per il protocollo HTTP 2.0.</p>
<p>&#8220;Ci potrebbe essere molto lavoro di ottimizzazione e re-ingegnerizzazione dei siti Web, soprattutto per mantenere la compatibilità con i client più anziani&#8221; ha detto Garrett.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2015/03/02/nginx-http-2-0-supportato-entro-fine-2015/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2015/03/http_2-0.jpg" medium="image">
			<media:title type="html">Nginx e supporto HTTP 2.0</media:title>
		</media:content>
	</item>
		<item>
		<title>Docker &#8211; costruire i contenitori</title>
		<link>https://tuttiperlinux.blog/2015/01/21/docker-costruire-i-contenitori/</link>
					<comments>https://tuttiperlinux.blog/2015/01/21/docker-costruire-i-contenitori/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 21 Jan 2015 11:41:38 +0000</pubDate>
				<category><![CDATA[Virtualizzazione]]></category>
		<category><![CDATA[ansible]]></category>
		<category><![CDATA[bash]]></category>
		<category><![CDATA[cache]]></category>
		<category><![CDATA[centos]]></category>
		<category><![CDATA[container]]></category>
		<category><![CDATA[coreos]]></category>
		<category><![CDATA[curl]]></category>
		<category><![CDATA[docker]]></category>
		<category><![CDATA[hypervisor]]></category>
		<category><![CDATA[linux blog in italiano]]></category>
		<category><![CDATA[lxc]]></category>
		<category><![CDATA[nginx]]></category>
		<category><![CDATA[Paas]]></category>
		<category><![CDATA[proxy]]></category>
		<category><![CDATA[ubuntu]]></category>
		<category><![CDATA[virtualizzazione]]></category>
		<category><![CDATA[web]]></category>
		<category><![CDATA[yum]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=948</guid>

					<description><![CDATA[Recentemente abbiamo parlato della virtualizzazione tramite Docker (vedi articolo Docker &#8211; cosi cambia la virtualizzazione) e, prima di proseguire sara&#8217; meglio rifare una piccola introduzione. Docker e&#8217; indubbiamente una valida alternativa alla virtualizzazione tradizionale nel mondo Linux. Questo tipo di virtualizzazione, detta a “container” non emula un&#8217; intero hardware come fanno invece gli hypervisor tipo &#8230; <a href="https://tuttiperlinux.blog/2015/01/21/docker-costruire-i-contenitori/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_949" style="width: 264px" class="wp-caption alignleft"><img loading="lazy" aria-describedby="caption-attachment-949" data-attachment-id="949" data-permalink="https://tuttiperlinux.blog/2015/01/21/docker-costruire-i-contenitori/docker2/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg" data-orig-size="593,290" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Docker costruire i contenitori" data-image-description="&lt;p&gt;Docker costruire i contenitori&lt;/p&gt;
" data-image-caption="&lt;p&gt;Docker costruire i contenitori&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=593" class=" wp-image-949" src="https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=254&#038;h=124" alt="Docker costruire i contenitori" width="254" height="124" srcset="https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=254&amp;h=124 254w, https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=508&amp;h=248 508w, https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=150&amp;h=73 150w, https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=300&amp;h=147 300w" sizes="(max-width: 254px) 100vw, 254px" /><p id="caption-attachment-949" class="wp-caption-text">Docker costruire i contenitori</p></div>
<p>Recentemente abbiamo parlato della virtualizzazione tramite Docker (vedi articolo <a title="Docker – cosi’ cambia la virtualizzazione" href="http://tuttiperlinux.com/2014/09/07/docker-cosi-cambia-la-virtualizzazione/">Docker &#8211; cosi cambia la virtualizzazione</a>) e, prima di proseguire sara&#8217; meglio rifare una piccola introduzione.</p>
<p>Docker e&#8217; indubbiamente una valida alternativa alla virtualizzazione tradizionale nel mondo Linux. Questo tipo di virtualizzazione, detta a “container” non emula un&#8217; intero hardware come fanno invece gli hypervisor tipo VMware, Virtualbox, Xen o KVM, ma crea invece dei “contenitori” nel sistema operativo dove possono essere messe in esecuzione applicazioni di vario genere in modo del tutto separato una dall’altra.</p>
<p>Dato che con il cloud il ruolo del sistema operativo diventa sempre meno importante perchè si punta più sullo strato applicativo, PaaS, rendendo il tutto più flessibile. A questo punto se dovessimo far girare 1000 clienti su un ambiente condiviso, diventerebbe interessante disporre di una tecnologia di virtualizzazione che riduca al minimo fisiologico gli overhead.</p>
<p>La virtualizzazione classica non è così, perchè per ogni ambiente applicativo, riservato ad un cliente, si dovrebbe  lanciare una intera macchina virtuale con dentro l’intero sistema operativo. E allora perchè non condividere lo stesso sistema operativo e invece isolare solo gli ambienti di esecuzione delle applicazioni , tipo application server, DB ecc&#8230;</p>
<p>I container sono dunque alla base dei moderni servizi cloud di tipo <strong>PaaS</strong> (Platform as a service) che usano questo tipo di virtualizzazione per misurare il consumo di risorse ed assegnarne i limiti.</p>
<p>Ad esempio, se su uno stesso server fisico, con una soluzione di virtualizzazione di tipo hypervisor si possono ospitare, supponiamo 50 virtual machines, con la virtualizzazione a container si potra&#8217; arrivare anche a 1000 container. Questo perchè un container di per sè è solo un contenitore di processi, mentre una virtual machine completa contiene tutto un ambiente operativo emulato.</p>
<p><strong>Il container può</strong> anche <strong>essere portabile</strong>, infatti ci basta copiare la directory che contiene il filesystem modificato dall’utente dopo la creazione del container, un piccolo file di configurazione, ed il container diventera&#8217; eseguibile su qualsiasi sistema che supporti <a title="LXC Linux Containers" href="http://tuttiperlinux.com/2014/07/27/lxc-linux-containers/">LXC</a>.</p>
<p>Il concetto è talmente interessante, che qualcuno ha pensato di fare un sistema operativo Linux interamente basato sui container, in cui non c’è nemmeno un package manager perchè si assume che gli applicativi saranno solo in forma di container. <a href="https://coreos.com/using-coreos/docker/">Coreos</a> è nato proprio con il principio di supportare ambienti di esecuzione a container, togliendo dal sistema tutto quello che non è strettamente necessario per farlo funzionare.</p>
<p><strong>INSTALLAZIONE</strong></p>
<p>Abbiamo tre possibili metodi d&#8217;installazione :</p>
<p>1) Centos</p>
<pre>sudo yum -y install docker-io</pre>
<p>2) Debian/Ubuntu</p>
<pre>sudo apt-get update 
sudo apt-get install docker.io 
sudo sudo apt-get install lxc-docker</pre>
<p>3) Download con Curl</p>
<pre>sudo curl -sSL https://get.docker.io/ubuntu/ | sudo sh</pre>
<p>* Linkiamo docker alla nostra bash</p>
<pre>ln -sf /usr/bin/docker.io /usr/local/bin/docker
sed -i '$acomplete -F _docker docker' /etc/bash_completion.d/docker.io</pre>
<p><strong>*</strong> Rendiamo docker attivo all&#8217;avvio</p>
<pre>update-rc.d docker.io defaults</pre>
<p>P.S.: Ci sono molti contenitori già disponibili nella community docker, che possono essere trovati attraverso una ricerca. Ad esempio con questo comando cerchero&#8217; la parola debian:</p>
<pre># docker search debian

NAME    DESCRIPTION      STARS     OFFICIAL   AUTOMATED
debian  Debianbaseimage  310         [OK]
google/debian            31                     [OK]</pre>
<p>&#8230;.e molte altre che potrete leggere dall&#8217;output completo.</p>
<p><strong>**</strong> Installiamo e facciamo provisioning con una immagine Centos</p>
<p># docker pull blalor/centos  # GitHub <a href="https://github.com/blalor/docker-centos-base">blalor/docker-centos-base  image</a></p>
<p>oppure per chi fosse interessato ad una immagine con gia inserito il tool <a href="http://tuttiperlinux.com/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/">Ansible</a> (per il Configuration Management ed IT Automation) di cui ho da poco parlato, potra&#8217; scegliere quest&#8217;altra immagine.</p>
<pre>sudo docker pull ansible/centos7-ansible # GitHub Ansible on Centos7
Pulling repository ansible/centos7-ansible
fff2afd18a57: Download complete</pre>
<p><strong>Avviamo un container docker</strong></p>
<p>Attiveremo ora un contenitore centos-base con una shell bash, utilizzando il comando <strong>run.</strong> Docker eseguira&#8217; questo comando in un nuovo contenitore, <strong>-i</strong> attribuisce stdin e stdout, <strong>-t</strong> assegna un terminale.</p>
<pre>docker run -i -t centos /bin/bash</pre>
<p>Questo è tutto! Adesso stai usando una shell bash all&#8217;interno di un contenitore centos.<br />
Per scollegarsi dalla shell la sequenza di escape e&#8217; : Ctrl-p + Ctrl-q.</p>
<p>Diamo un&#8217;occhiata ai processi attivi tramite :</p>
<pre># docker ps -a
CONTAINER   ID IMAGE          COMMAND     CREATED
fff2afd18a57     blalor/centos     /bin/bash         About an hour ago</pre>
<p><strong>Il Dockerfile</strong><br />
Per automatizzare la procedura di creazione e modifica di un container docker, possiamo utilizzare il Dockerfile, che è una delle parti principali di Docker, infatti attraverso il Dockerfile è possibile non solo fare il deploy istantaneo automatizzato di più istanze e più container, ma è anche possibile eseguire il provisioning di queste istanze, automatizzando task di gestione del sistema, installazione del software e molto altro.</p>
<p>Nel prossimo articolo vedremo un esempio utile, utilizzando ad esempio un&#8217;applicazione leggera, che puo&#8217; lavorare molto bene in un contenitore, come <a href="http://tuttiperlinux.com/2014/12/05/nginx-ecco-le-ragioni-per-cui-dovreste-usarlo/">NGINX</a>, il noto server web/cached per la gestione di siti web/proxy ad alto carico.</p>
<p>#DockerContainerAvviato</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2015/01/21/docker-costruire-i-contenitori/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2015/01/docker2.jpg?w=150" medium="image">
			<media:title type="html">Docker costruire i contenitori</media:title>
		</media:content>
	</item>
		<item>
		<title>NGINX ecco le ragioni per cui dovreste usarlo</title>
		<link>https://tuttiperlinux.blog/2014/12/05/nginx-ecco-le-ragioni-per-cui-dovreste-usarlo/</link>
					<comments>https://tuttiperlinux.blog/2014/12/05/nginx-ecco-le-ragioni-per-cui-dovreste-usarlo/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Fri, 05 Dec 2014 23:03:53 +0000</pubDate>
				<category><![CDATA[Load Balancing]]></category>
		<category><![CDATA[Networking]]></category>
		<category><![CDATA[Proxy]]></category>
		<category><![CDATA[apache]]></category>
		<category><![CDATA[caching]]></category>
		<category><![CDATA[cms]]></category>
		<category><![CDATA[debian]]></category>
		<category><![CDATA[fastcgi]]></category>
		<category><![CDATA[load balancer]]></category>
		<category><![CDATA[nginx]]></category>
		<category><![CDATA[proxy]]></category>
		<category><![CDATA[stack lamp]]></category>
		<category><![CDATA[ubuntu]]></category>
		<category><![CDATA[webserver]]></category>
		<category><![CDATA[wordpress]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=728</guid>

					<description><![CDATA[nginx (pronunciato come &#8220;engine-x&#8221;) è un web server/reverse proxy leggero ad alte prestazioni; è anche un server proxy di posta elettronica (IMAP / POP3), rilasciato sotto licenza BSD-like. Funziona su sistemi Unix, Linux, varianti di BSD, Mac OS X, Solaris e Microsoft Windows. &#160; nginx fornisce rapidamente i contenuti statici con un utilizzo efficiente delle &#8230; <a href="https://tuttiperlinux.blog/2014/12/05/nginx-ecco-le-ragioni-per-cui-dovreste-usarlo/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="http://www.nginx.org/"><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png"><img loading="lazy" data-attachment-id="729" data-permalink="https://tuttiperlinux.blog/2014/12/05/nginx-ecco-le-ragioni-per-cui-dovreste-usarlo/nginx_vs_apache/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png" data-orig-size="960,480" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="nginx_vs_apache" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=600" class="alignleft size-medium wp-image-729" src="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=300&#038;h=150" alt="nginx fast web server" width="300" height="150" srcset="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=300&amp;h=150 300w, https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=600&amp;h=300 600w, https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=150&amp;h=75 150w" sizes="(max-width: 300px) 100vw, 300px" /></a>nginx</strong></a> (pronunciato come &#8220;engine-x&#8221;) è un web server/reverse proxy leggero ad alte prestazioni; è anche un server proxy di posta elettronica (IMAP / POP3), rilasciato sotto licenza BSD-like. Funziona su sistemi Unix, Linux, varianti di BSD, Mac OS X, Solaris e Microsoft Windows.</p>
<p>&nbsp;</p>
<p>nginx fornisce rapidamente i contenuti statici con un utilizzo efficiente delle risorse di sistema. È possibile distribuire contenuti dinamici HTTP su una rete che utilizza i gestori FastCGI (ad esempio php5-fpm, php-fastcgi) per gli script, e può servire anche come un bilanciatore di carico software molto capace.</p>
<p>nginx utilizza un approccio asincrono basato su eventi nella gestione delle richieste in modo da ottenere prestazioni più prevedibili sotto stress, in contrasto con il modello del server HTTP Apache che usa un approccio orientato ai thread o ai processi nella gestione delle richieste.</p>
<p>nginx è più leggero e meno dispendioso di memoria rispetto ad Apache e già questo è un punto a favore del web server russo. Poi, nonostante sia più compatto, garantisce prestazioni migliori rispetto al concorrente, infatti con un bassissimo utilizzo di risorse, nginx garantisce tempi di risposta eccellenti anche in presenza di un numero molto elevato di connessioni concomitanti e, con un’occupazione di memoria pari a un quarto di quella pretesa da Apache, nginx è capace di garantire fino a quattro volte il numero di connessioni contemporanee gestite dal concorrente. Di fronte a questa verità, siti ad alto traffico come WordPress.com, YouTube e tanti altri non potevano non effettuare il cambio e spostarsi su nginx.</p>
<p>Secondo il Web Server <a href="http://news.netcraft.com/archives/2014/02/03/february-2014-web-server-survey.html">Survey Netcraft</a> di febbraio 2014, nginx è risultato essere il terzo server web più utilizzato in tutti i domini (15,00% dei siti esaminati) e il secondo server web più utilizzato per tutti i siti &#8220;attivi&#8221; (13,46% dei siti esaminati).</p>
<p>Una cosa importante da capire, comunque, è che nginx possiede un’architettura event-based ovvero, detta in modo semplice, non necessita di effettuare la creazione di tanti processi per quante richieste siano in esecuzione, ottimizzando l’uso di memoria al contrario di Apache che, in certi casi, può provocare problemi di memoria su WordPress o altri CMS. Apache usa infatti un thread per connessione, mentre nginx lavora in modo asincrono con thread non bloccanti, il che riduce l’uso di RAM ed ottimizza l’esecuzione dei processi.</p>
<p>Una delle caratteristiche che più colpisce di nginx è la capacità di <strong>supportare nativamente il load balancing</strong>, per cui possiamo utilizzare questa tecnica per scalare velocemente i server HTTP. Con il load balancing di nginx possiamo distribuire il traffico fra differenti server, definiti in un gruppo nel file &#8220;<em>nginx.conf&#8221;,</em> in questo modo, ad esempio, se in un particolare momento operativo dobbiamo aggiungere un nuovo webserver al nostro stack LAMP, possiamo semplicemente inserirlo nel gruppo di server gestito dal file nginx.conf. In seguito al reload della configurazione (nginx -s reload), nginx effettuerà le operazioni di load balancing fra tutti i server indicati nel file di configurazione, compreso l’ultimo appena inserito.</p>
<p>Anche l’installazione di nginx è semplicissima e si può effettuare da qualsiasi shell-bash con una sola riga di comando. Nello specifico sulle distribuzioni Ubuntu e Debian scriveremo:</p>
<pre>apt-get install nginx</pre>
<p>mentre per CentOS, Red Hat Linux Enterprise e Fedora digiteremo:</p>
<pre>yum install nginx</pre>
<p><strong>Caratteristiche HTTP di base</strong></p>
<ul>
<li>Gestione dei file statici, file di indice, e auto-indicizzazione</li>
<li>Reverse proxy con caching</li>
<li>Bilanciamento del carico</li>
<li>Tolleranza agli errori</li>
<li>Supporto SSL</li>
<li>Supporto FastCGI con il caching</li>
<li>Server virtuali basati su nome ed IP</li>
<li>Streaming FLV</li>
<li>Streaming MP4, utilizzando il modulo streaming MP4</li>
<li>Autenticazione di accesso nelle pagine web</li>
<li>Compressione gzip</li>
<li>Capacità di gestire più di 10000 connessioni simultanee</li>
<li>Riscrittura degli URL</li>
<li>Log personalizzato</li>
<li>include server-side</li>
<li>resistente agli attacchi di Slowloris</li>
<li>WebDAV</li>
</ul>
<p>Nel prossimo articolo inizieremo a vedere in modo dettagliato quali siano le migliori configurazioni.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/12/05/nginx-ecco-le-ragioni-per-cui-dovreste-usarlo/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/12/nginx_vs_apache.png?w=300" medium="image">
			<media:title type="html">nginx fast web server</media:title>
		</media:content>
	</item>
	</channel>
</rss>
