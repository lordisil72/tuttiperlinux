<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>load balancing &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/load-balancing-2/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Fri, 21 Dec 2018 09:55:09 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>load balancing &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>NGROK &#8211; reverse proxy server cross-platform</title>
		<link>https://tuttiperlinux.blog/2018/12/21/ngrok-reverse-proxy-server-cross-platform/</link>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Fri, 21 Dec 2018 09:55:09 +0000</pubDate>
				<category><![CDATA[Proxy]]></category>
		<category><![CDATA[Tips & Tricks]]></category>
		<category><![CDATA[WebServer]]></category>
		<category><![CDATA[blog]]></category>
		<category><![CDATA[cms]]></category>
		<category><![CDATA[load balancing]]></category>
		<category><![CDATA[ngrok]]></category>
		<category><![CDATA[proxy]]></category>
		<category><![CDATA[redirect]]></category>
		<category><![CDATA[tuttiperlinux]]></category>
		<category><![CDATA[virtual host]]></category>
		<category><![CDATA[virtualizzazione]]></category>
		<category><![CDATA[wordpress]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.blog/?p=1338</guid>

					<description><![CDATA[Lo sviluppo di siti e di Webb Application e&#8217;, al giorno d&#8217;oggi, uno dei core business piu&#8217; importanti per la maggior parte delle aziende in tutto il mondo, motivo per cui sono nati una grande quantita&#8217; di tool per agevolare i web developer durante tutte le operazioni di sviluppo, test e produzione. Molto spesso capita che non &#8230; <a href="https://tuttiperlinux.blog/2018/12/21/ngrok-reverse-proxy-server-cross-platform/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1340" style="width: 610px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1340" data-attachment-id="1340" data-permalink="https://tuttiperlinux.blog/2018/12/21/ngrok-reverse-proxy-server-cross-platform/ngrok-logo/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png" data-orig-size="1200,800" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ngrok mostrare un sito in locale" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=600" class="wp-image-1340 size-large" src="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=600&#038;h=400" alt="ngrok mostrare un sito in locale" width="600" height="400" srcset="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=600&amp;h=400 600w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=150&amp;h=100 150w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=300&amp;h=200 300w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=768&amp;h=512 768w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=1024&amp;h=683 1024w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png 1200w" sizes="(max-width: 600px) 100vw, 600px" /><p id="caption-attachment-1340" class="wp-caption-text">Ngrok Pubblica il tuo sito in localhost</p></div>
<p>Lo sviluppo di siti e di Webb Application e&#8217;, al giorno d&#8217;oggi, uno dei core business piu&#8217; importanti per la maggior parte delle aziende in tutto il mondo, motivo per cui sono nati una grande quantita&#8217; di tool per agevolare i web developer durante tutte le operazioni di sviluppo, test e produzione.</p>
<p>Molto spesso capita che non si abbia il tempo o anche il budget per gestire piu&#8217; ambienti di sviluppo, cosi ci si riduce per avere tutto il proprio ambiente [sviluppo / test / pre produzione] soltanto sul proprio pc.</p>
<p>Come fare quindi se c&#8217;e&#8217; bisogno di mostrare l&#8217;avanzamento del lavoro al cliente senza dover prima creare e/o aggiornare gli altri ambienti di test/pre-produzione??? &#8230;. e&#8217; per aiutare in questa pressante fase che e&#8217; nato un tool come ngrok.</p>
<p>Ngrok e&#8217; un reverse proxy server con cui e&#8217; possibile rendere &#8220;<strong>pubblico</strong>&#8221; un server locale, anche se e&#8217; collocato dietro un NAT od un Firewall, il tutto tramite secure tunnel. Quindi attraverso Ngrok si potra&#8217; implementare un personal cloud service direttamente dalla propria postazione di lavoro realizzando cosi uno stack LAMP/LEMP</p>
<p>&nbsp;</p>
<p><strong>INSTALLAZIONE<br />
</strong></p>
<pre class=" language-markup"><code class=" language-markup">mkdir ngrok
cd ngrok/
wget -c https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip
unzip ngrok-stable-linux-amd64.zip</code></pre>
<p>Dopo aver installato il pacchetto possiamo fare una prova, se ad esempio usate come web server Apache, potete farlo in questo modo;</p>
<pre class=" language-markup"><code class=" language-markup">sudo nano /var/www/html/index.html

</code>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h1&gt;Prova&lt;/h1&gt; &lt;p&gt;Test di Ngrock.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;</pre>
<p>Salviamo il file e ora possiamo avviare il tool puntandolo sulla porta su cui abbiamo in ascolto il nostro Web server:</p>
<div class="code-toolbar">
<pre class=" language-markup"><code class=" language-markup">ngrok http 80</code></pre>
<p>Una volta lanciato il comando ci apparira&#8217; qualcosa di simile:</p>
<pre>Session Status online Session Expires 7 hours, 53 minutes
Version 2.2.8 Region United States (us)
Web Interface http://127.0.0.1:4040
Forwarding http://44c9afca.ngrok.io -&gt; localhost:80
Forwarding https://44c9afca.ngrok.io -&gt; localhost:80</pre>
<p>Una volta avviato possiamo dunque iniziare ad usarlo anche tramite la comoda interfaccia Web:</p>
<div class="code-toolbar">
<pre class=" language-markup"><code class=" language-markup">http://localhost:4040</code></pre>
<p><img loading="lazy" data-attachment-id="1339" data-permalink="https://tuttiperlinux.blog/2018/12/21/ngrok-reverse-proxy-server-cross-platform/ngrok-localhost/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png" data-orig-size="835,504" data-comments-opened="0" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ngrok-dashboard" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=600" class="alignnone size-large wp-image-1339" src="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=600&#038;h=362" alt="ngrok localhost" width="600" height="362" srcset="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=600&amp;h=362 600w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=150&amp;h=91 150w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=300&amp;h=181 300w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=768&amp;h=464 768w, https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png 835w" sizes="(max-width: 600px) 100vw, 600px" /></p>
<p>Tornando alla descrizione del Tunnel appena creato, le voci a cui dobbiamo fare caso sono:</p>
<ul>
<li><strong>Web Interface</strong>: tramite questo indirizzo potrai accedere ad un’interfaccia web dove puoi monitorare tutte le attività associate all’url che hai appena creato. Questo vuol dire che potrai vedere quanti utenti si stanno collegando ed altre informazioni.</li>
<li><strong>Forwarding</strong>: questo è il link che dovrai fornire al tuo cliente. Hai entrambe le versioni, sia http che https. Lavorando in locale probabilmente userai quasi sempre l’http.</li>
<li><strong>HTTP Requests</strong>: In questa sezione vedrai in tempo reale tutte le richieste http che vengono fatte tramite il tuo link. Ti è utile per capire se qualcuno sta guardando il sito in un dato momento.</li>
</ul>
<p>Quindi dando al proprio cliente il link http://44c9afca.ngrok.io  quest&#8217;ultimo avra&#8217; accesso alla root web del localhost</p>
<p>Questo vuol dire che se stai utilizzando MAMP o XAMPP verrà servito il file<strong> index.php </strong>all’interno della tua cartella<strong> /htdocs</strong></p>
<p>Se invece utilizzi WAMP su Windows il tuo tunnel porterà gli utenti alla <strong>index.php </strong>della cartella<strong> www</strong></p>
</div>
<p>Per coloro che utilizzano un Virtual Host per gestire i tuoi progetti la procedura e&#8217;<br />
leggermente diversa ma pur sempre semplice; nella pratica bastera&#8217; aggiungere un solo<br />
parametro, come nell&#8217;esempio seguente:</p>
<pre><code>ngrok http -host-header=miosito.dev 80</code></pre>
<p>dove ovviamente al posto di &#8220;miosito.dev&#8221; metterete l’indirizzo del vostro in locale. ** WordPress per coloro che invece usano la piattaforma di WordPress si dovranno applicare altri accorgimenti per far in modo che il vostro cliente veda correttamente il sito. Questo perche&#8217; tutti gli url che creati da WordPress sono assoluti ovvero mostrano per esteso l’indirizzo di un determinato documento. Per poter effettuare questo tipo di modifica consiglio di utilizzare un comodo tool come <a href="https://wordpress.org/plugins/relative-url/" target="_blank" rel="noopener"><strong>Relative</strong> <strong>URL</strong></a> , un tool che fa gia parte dei plugin consigliati da WordPress, con il quale sara&#8217; possibile modificare URL da qualcosa come questo (esempio):</p>
<pre>http://localhost:8080/wp/2012/09/01/hello-world/</pre>
<p>in qualcos&#8217;altro come questo:</p>
<pre><code>/wp/2012/09/01/hello-world/</code></pre>
<p>Una volta effettuate tutte le modifiche del caso bisognera&#8217; aggiornare il file wp-config.php<br />
inserendo, prima della riga “/* i parametri dei re indirizzamenti, qualcosa del tipo:</p>
<pre><code>define('WP_SITEURL', 'http://' . $_SERVER['HTTP_HOST']);
define('WP_HOME', 'http://' . $_SERVER['HTTP_HOST']);
</code></pre>
<p>PS:<strong>Ricordatevi di disinstallare il plugin e rimuovere le righe di codice dal file wp-config.php quando metterete il sito online. </strong></p>
<p>Le configurazioni possibili con Ngrok sono davvero svariate e potete trovare tutto cio che non e&#8217; stato contemplato in questo articolo, direttamente sul sito del progetto <a href="https://ngrok.com/docs" target="_blank" rel="noopener"><strong>NGROK</strong></a></p>
</div>
]]></content:encoded>
					
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-logo.png?w=600" medium="image">
			<media:title type="html">ngrok mostrare un sito in locale</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2018/12/ngrok-localhost.png?w=600" medium="image">
			<media:title type="html">ngrok localhost</media:title>
		</media:content>
	</item>
		<item>
		<title>MaxScale &#8211; un proxy per i Database MariaDB e MySQL</title>
		<link>https://tuttiperlinux.blog/2015/12/14/maxscale-un-proxy-per-i-database-mariadb-e-mysql/</link>
					<comments>https://tuttiperlinux.blog/2015/12/14/maxscale-un-proxy-per-i-database-mariadb-e-mysql/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Mon, 14 Dec 2015 17:19:39 +0000</pubDate>
				<category><![CDATA[DB]]></category>
		<category><![CDATA[Proxy]]></category>
		<category><![CDATA[alta affidabilita]]></category>
		<category><![CDATA[cms]]></category>
		<category><![CDATA[haproxy]]></category>
		<category><![CDATA[load balancing]]></category>
		<category><![CDATA[mariadb]]></category>
		<category><![CDATA[maxscale]]></category>
		<category><![CDATA[mysql db]]></category>
		<category><![CDATA[mysql proxy]]></category>
		<category><![CDATA[proxy db]]></category>
		<category><![CDATA[replica master slave]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=1186</guid>

					<description><![CDATA[MaxScale è il nuovo database proxy server open source sviluppato da MariaDB Corporation Ab. MaxScale nasce con un concetto di proxy alla base, ma con una filosofia ed un approccio &#8220;database centrico&#8221; ed una architettura a plugin estremamente configurabile. Per chi si fosse perso i precedenti articoli riguardanti i Proxy Server, ricordiamo che, un proxy, &#8230; <a href="https://tuttiperlinux.blog/2015/12/14/maxscale-un-proxy-per-i-database-mariadb-e-mysql/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1187" style="width: 310px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1187" data-attachment-id="1187" data-permalink="https://tuttiperlinux.blog/2015/12/14/maxscale-un-proxy-per-i-database-mariadb-e-mysql/mariadb-maxscale/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg" data-orig-size="638,452" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="mariadb-maxscale" data-image-description="&lt;p&gt;Maxscale &#8211; Proxy per MariaDB &amp;amp; Mysql&lt;/p&gt;
" data-image-caption="&lt;p&gt;Maxscale &#8211; Proxy per MariaDB &amp;amp; Mysql&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=600" class="size-medium wp-image-1187" src="https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=300&#038;h=213" alt="Maxscale - Proxy per MariaDB &amp; Mysql" width="300" height="213" srcset="https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=300&amp;h=213 300w, https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=600&amp;h=426 600w, https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=150&amp;h=106 150w" sizes="(max-width: 300px) 100vw, 300px" /><p id="caption-attachment-1187" class="wp-caption-text">Maxscale &#8211; Proxy per MariaDB &amp; Mysql</p></div>
<p><strong>MaxScale</strong> è il nuovo <strong>database proxy server</strong> open source sviluppato da <a href="https://mariadb.com/">MariaDB Corporation Ab</a>.</p>
<p>MaxScale nasce con un concetto di proxy alla base, ma con una filosofia ed un approccio &#8220;database centrico&#8221; ed una architettura a plugin estremamente configurabile.</p>
<p>Per chi si fosse perso i precedenti articoli riguardanti i Proxy Server, ricordiamo che, un proxy, è un server che fa da intermediario in una connessione, ossia esso riceve le richieste da un client e le reindirizza verso altri server che sono i destinatari delle richieste. In altre parole un proxy funziona come un centralinista: riceve la chiamata del cliente  e la gira al primo operatore libero.<br />
Per capire meglio cosa e&#8217; in grado fare elenchiamo alcune delle sue funzionalità principali quali:</p>
<ul>
<li>controllo della disponibilità del Database (monitoring)</li>
<li>load balancing</li>
<li>analisi della query in ingresso per capire se indirizzarla su una specifica tipologia di server</li>
</ul>
<p>tutto questo, e molto altro ancora.</p>
<p>MaxScale si può inserire in modo trasparente tra l&#8217;applicativo e il server MySQL, esattamente come fa un proxy web tra il nostro browser e il sito che stiamo cercando di visitare.<br />
Grazie ad un proxy è possibile avere:</p>
<ul>
<li>Ridondanza: usando più di un database dietro al proxy, poiche&#8217; un solo server non fornisce l&#8217;affidabilità e l&#8217;alta disponibilità in caso di down di una macchina.</li>
<li>Diminuizione dei costi di infrastruttura: perché generalmente due server piccoli sono meno costosi che un unico server molto performante.</li>
</ul>
<p>Per migliorare la spiegazione ora vedremo due tipi di database proxy server:</p>
<p>I proxy di livello trasporto come <a href="http://tuttiperlinux.com/2015/02/22/haproxy-ed-il-bilanciamento-di-carico-e-servito/">HAProxy</a> (di cui abbiamo piu&#8217; volte parlato in altri articoli).<br />
I proxy di livello applicativo come <a href="http://tuttiperlinux.com/2015/06/12/maxscale-db-proxy-scalabile/">MaxScale</a><br />
HAProxy: un proxy efficiente, rapido e funzionale</p>
<p>Fino ad oggi tra i proxy più usati in ambito MySQL Cluster è l&#8217;HAProxy che lavora ad un livello più basso (livello 4: trasporto). HAproxy pero&#8217; non conosce nulla di MySQL e si occupa quindi soltanto di bilanciare le connessioni tra i server. Haproxy e&#8217; molto veloce, leggero ed efficente, tuttavia questo tipo di bilanciamento è fatto senza che il proxy sia a conoscenza di cosa sta smistando. Questo rende il sistema meno efficente poiché un server può ricevere molte richieste pesanti, mentre altri server possono essere scarichi. Quindi l&#8217;HAProxy non è la scelta vincente in tutti i casi.</p>
<p>MaxScale: e&#8217; un proxy che in configurazioni di questo tipo può fare cose incredibili</p>
<p>MaxScale lavora a livello più alto (livello 7: applicativo) e, monitorando i server riesce a capire cosa sta succedendo all&#8217;interno dell&#8217;infrastruttura. Conoscendo il protocollo MySQL può intervenire manipolando il traffico tra client e server. Ecco alcune delle sue principali funzionalità:</p>
<ul>
<li>Filtro delle query al database</li>
<li>Gestione del routing: instradamento delle richieste a uno o più database server</li>
<li>Modifica delle query al volo prima che raggiungano il database</li>
<li>Possibilità di nascondere la struttura interna dell&#8217;infrastruttura lasciando un singolo punto d&#8217;accesso.</li>
<li>Alta affidabilità e scalabilità del sistema</li>
<li>Possibilità di spostare un database dal server locale ad un server esterno senza modificare la configurazione delle applicazioni</li>
<li>Divide automaticamente le scritture sul server MASTER e le letture su uno o più database SLAVE.</li>
<li>MaxScale può fornire un Load Balacing delle connessioni senza bisogno di utilizzare applicazioni o CMS che prevedano questa funzionalità. Questo significa che CMS come Joomla! o WordPress possono trarre i benefici usando una replicazione Master/Slave per rendere scalabile il proprio sito.</li>
</ul>
<p>Caratteristiche di MaxScale</p>
<p>Il punto di forza di MaxScale è sicuramente la sua modularità che permette una notevole libertà adattandosi a molti casi d&#8217;uso. MaxScale è :</p>
<ul>
<li>Modulare: un sistema di moduli ne definisce le funzionalità</li>
<li>Estendibile: è possibile applicare più filtri anche in cascata</li>
<li>Flessibile: i moduli e i filtri possono essere aggiunti dinamicamente</li>
</ul>
<p>I moduli base di MaxScale</p>
<p>Ecco i 5 moduli che costituiscono il cuore di MaxScale:</p>
<ul>
<li><strong>Protocol</strong>: da la possibilità di utilizzare più protocolli es. MySQL client, http, telnet;<br />
I client si connettono a MaxScale anziché al database MySQL senza accorgersi della differenza. Possono usare le stesse librerie di connessione utilizzate fino ad ora: es. MySQL client o MariaDB client</li>
<li><strong>Authentication</strong>: il sistema di autenticazione permette ai client di accedere a MaxScale usando le credenziali presenti sui server di Backend;<br />
MaxScale non ha un sistema di autenticazione o un database di utenti. Vengono utilizzati gli stessi utenti presenti sui database di backend, caricati all&#8217;avvio dell&#8217;applicazione</li>
<li><strong>Monitor</strong>: legge la configurazione dello stato del sistema direttamente dai server di backend;<br />
Viene utilizzato per capire in ogni momento lo stato di tutti i database di backend collegati a MaxScale. In questo modo è possibile sapere qual&#8217;è il server Master e quanti Slave stanno replicando correttamentei dati. Il monitor può essere utilizzato per controllare un Galera Cluster.</li>
<li><strong>Router</strong>: smista le connessioni a uno o più database di backend;<br />
Dirige il traffico dal client ai server utilizzando una regola specifica denominata connection routing</li>
<li><strong>Filter e logging</strong>: i filtri permettono di modificare le query oppure di scrivere un file di log con tutte le richieste e le risposte ricevute;<br />
Tra i più potenti strumenti messi a disposizione di MaxScale ci sono sicuramente i filtri che permettono di effettuare operazioni avanzate sulle query senza modificare il comportamento dell&#8217;applicazione, 1) processando query SQL e risultati, 2) utilizzando una semplice regex, 3)  analizzando, modificando o rifiutando le query, 4) mettendo più filtri in cascata</li>
</ul>
<p>Non resta che testare di persona, magari con un ambiente ad hoc con Docker e Vagrant.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2015/12/14/maxscale-un-proxy-per-i-database-mariadb-e-mysql/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2015/12/mariadb-maxscale.jpg?w=300" medium="image">
			<media:title type="html">Maxscale - Proxy per MariaDB &#038; Mysql</media:title>
		</media:content>
	</item>
		<item>
		<title>Load Balancing Systems</title>
		<link>https://tuttiperlinux.blog/2015/12/02/load-balancing-systems/</link>
					<comments>https://tuttiperlinux.blog/2015/12/02/load-balancing-systems/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 02 Dec 2015 17:34:29 +0000</pubDate>
				<category><![CDATA[Load Balancing]]></category>
		<category><![CDATA[application server]]></category>
		<category><![CDATA[Citrix]]></category>
		<category><![CDATA[F5]]></category>
		<category><![CDATA[gmail]]></category>
		<category><![CDATA[haproxy]]></category>
		<category><![CDATA[ipvsadm]]></category>
		<category><![CDATA[layer4]]></category>
		<category><![CDATA[layer7]]></category>
		<category><![CDATA[load balancing]]></category>
		<category><![CDATA[OSI]]></category>
		<category><![CDATA[Radware]]></category>
		<category><![CDATA[ssl]]></category>
		<category><![CDATA[webserver]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=1176</guid>

					<description><![CDATA[Ormai Internet e&#8217; parte della vita di milioni di persone e&#8217; lo sara&#8217; sempre di piu&#8217;. Sono lontanissimi i tempi dei siti statici con qualche migliaio di accessi al mese o poco piu&#8217;, oggi quasi ogni tipologia di servizio offerto dalle aziende o dalla pubblica amministrazione, ha la gestione su di un portale Internet, dunque &#8230; <a href="https://tuttiperlinux.blog/2015/12/02/load-balancing-systems/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1177" style="width: 310px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1177" data-attachment-id="1177" data-permalink="https://tuttiperlinux.blog/2015/12/02/load-balancing-systems/load-balancer-new/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png" data-orig-size="2400,2400" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Load-Balancer" data-image-description="&lt;p&gt;Load Balancing Systems&lt;/p&gt;
" data-image-caption="&lt;p&gt;Load Balancing Systems&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=600" class="wp-image-1177 size-medium" src="https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=300&#038;h=300" alt="Load Balancing Systems" width="300" height="300" srcset="https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=300&amp;h=300 300w, https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=600&amp;h=600 600w, https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=150&amp;h=150 150w" sizes="(max-width: 300px) 100vw, 300px" /><p id="caption-attachment-1177" class="wp-caption-text">Load Balancing Systems</p></div>
<p>Ormai Internet e&#8217; parte della vita di milioni di persone e&#8217; lo sara&#8217; sempre di piu&#8217;. Sono lontanissimi i tempi dei siti statici con qualche migliaio di accessi al mese o poco piu&#8217;, oggi quasi ogni tipologia di servizio offerto dalle aziende o dalla pubblica amministrazione, ha la gestione su di un portale Internet, dunque la gestione degli accessi, al secondo, e&#8217; diventata la discriminante per valutare un ottimo servizio da uno scadente; si pensi alla fantastica operabilita&#8217; di portali come Facebook, Twitter o Gmail, solo per citarne alcuni, che permettono e gesticono l&#8217;accesso di milioni di utenti 24h senza praticamente disservizi o rallentamenti .</p>
<p>Ora dietro c&#8217;e&#8217; una mole di lavoro ingegneristico del software, dell&#8217;hardware, dell&#8217;architettura migliore, del DB piu&#8217; performante etc ma, prima che tutto cio&#8217; inizi ad operare l&#8217;utente dev&#8217;essere, per prima cosa, agganciato ed instradato verso il server (fisico o virtuale che sia) che accogliera&#8217; le sue operazioni (acquisti , home banking, pagamento bollette&#8230;), tutto cio verra&#8217; fatto dall&#8217;infrastruttura di Load Balancing, che puo&#8217; essere un fiore all&#8217;occhiello dell&#8217;azienda oppure trasformarsi in un Mega <strong>Point of Failure</strong>, quindi vediamo di spiegare meglio che cosa sono i Load Balancer e come operano.</p>
<p>Letteralmente “<strong>Load Balancing</strong>” significa bilanciare il carico di lavoro su più nodi dell’architettura.Viene spesso confuso come tecnica per ottenere l&#8217; High Availability (HA), ma pur condividendone alcuni mezzi, ha dei fini totalmente diversi.</p>
<p>In pratica il &#8220;bilanciatore di carico&#8221;, per chi non lo sapesse, è quel componente (di frontend) che prende in carico le connessioni in ingresso (quelle degli utenti per gli accessi POP/IMAP ad esempio) e le smista verso i server (backend) veri e propri che erogano i servizi (webserver, application server..). E’ sempre il bilanciatore che interviene quando un server di backend viene rimosso dal cluster, per manutenzione o interruzione, a dirottare il traffico verso i server rimasti attivi.</p>
<p>Uno degli errori più comuni per effettuare il Load Balancing è quello di prendere come riferimento il Load dei server, scrivendo sulle console delle nostre macchine il comando “uptime”, riceveremo come risposta un dato come questo</p>
<p>16:49 up 453 days, 12:17, 56 users, load averages: 0,59 0,46 0,47</p>
<p>dove gli ultimi tre numeri identificano il carico del server negli ultimi 1, 5 e 15 minuti rispettivamente.</p>
<p>Immaginiamo ora di aggiungere ulteriori nodi quando il carico di un server negli ultimi 5 minuti superera&#8217; il valore di 1,5. La nuova macchina aggiunta partirà con un carico pressoché a 0 e verrà invasa da centinaia di richieste fino a rischiarne la saturazione, e dovremo inoltre attendere altri 5 minuti prima che un nuovo bilanciamento possa intervenire.</p>
<p>Peccato che prima di quei 5 minuti il nostro nuovo server farà parecchia fatica a rispondere a tutte queste richieste, perdendo cosi di fatto parecchi utenti a causa di errori di pagina non trovata oppure di time out per la troppa attesa etc&#8230;.facendo perdere parecchi soldi all&#8217;azienda. Questo tipo di problema è chiamato “<strong>staleness</strong>”, e può essere aggirato con altre tecniche che non si basano su una metrica numerica.</p>
<p><strong>Come implementare il load balancing:</strong></p>
<p>Come scegliere quindi su quale server dirigere una richiesta?</p>
<p>La tecnica di Load Balaincing più semplice è detta <strong>Round Robin</strong>, il suo principio e&#8217; che ogni richiesta che viene effettuata viene smistata su un server differente, a rotazione.</p>
<p>In un cluster di 100 macchine, 100 richieste verranno distribuite su tutti 100 i servers a rotazione dal primo all’ultimo. Questa è una tecnica molto semplice da usare, e inclusa ad esempio già in Apache, ma si porta il limite che se un server è sovraccarico non avrà mail il tempo rientrare in una situazione di normalità che subito dopo dovra&#8217; gestire un&#8217;ennesima richiesta e cosi via.</p>
<p>La tecnica “<strong>Random</strong>” ci offre un modo elegante per distribuire le richieste; in pratica non si basa su nessuna metrica, ma per i puristi resta comunque fuori controllo poiche&#8217; offre comunque la possibilià (anche se randomica) di continuare a girare richieste verso server già sovraccarichi.</p>
<p>Una variante della tecnica “Random” è la “<strong>Weighted Random</strong>“, dove viene introdotta la variabile “potenza del server”, ossia i server più potenti avranno una possibilià più alta di ricevere richieste, rispetto ad hardware meno performante.</p>
<p>La tecnica “<strong>Predictive</strong>” invece è una variante del “Round Robin”, in questa metodologia vengono introdotte alcune variabili al normale ciclo per permettere di avere una ripartizione più accurata saltando ad esempio i server già troppo carichi. E’ una tecnica implementata a livello di Load Balancers hardware, e i produttori sono di solito restii a documentare gli algoritmi “Predictive”.</p>
<p>Resta scontato che, una volta scelta la tecnica preferita, dovremo prendere in considerazione anche altri problemi. Ora, ad esempio, proviamo ad uscire dal ragionamento di un singolo Load Balancer, e proviamo ad aumentare la posta ed a pensare in modalita&#8217; High Availability con almeno due bilanciatori dove il lavoro del primo verrà supportato o, in caso di problemi, preso in carico dal secondo, che redistribuirà il traffico secondo una sua logica.</p>
<p>Per l’utente finale (colui che naviga dal suo browser) non cambierà nulla, infatti il browser si connetterà ad un IP dove non ci sarà un webserver ad attenderlo, ma il Load Balancer. Il Load Balancer girerà quindi, seguendo il nostro metodo di allocazione scelto, la richiesta ad un webserver scarico pronto a risponderci.</p>
<p>Cosa fondamentale e&#8217; che i due, o più load balancer, devono essere in grado di parlarsi e condividere informazioni, così che entrambi sapranno che un dato server è da considerare sovraccarico o che un altro server sta per uscire dal pool.</p>
<p><strong>Come scegliere il giusto load balancing</strong></p>
<p>Scegliere il metodo di load balancing, e lo strumento col quale applicarlo, necessitano quindi di studi specifici sul tipo di traffico, e sull’architettura dell’applicazione che si vuole bilanciare, soprattutto quando entrano in gioco variabili come SSL.</p>
<p>L’SSL è basato sulla generazione di un certificato legato ad un IP, e in uno scenario dove abbiamo diversi IP virtuali che rigirano il traffico verso altri &#8220;nattati&#8221; diventa quantomeno improbabile poter gestire in modo corretto il certificato. Questo proprio perche&#8217; il certificato è usato per validare la reale identità del server web, quindi mettendoci in mezzo un load balancer otterremmo un “man in the middle” che invalidera&#8217; la connessione SSL.</p>
<p>L’unico modo diventa spostare la connessione SSL solo tra browser e Load balancer, inserendo il certificato sul VIP del sistema di Load Balancing e lasciando il traffico dopo il Load balancer in chiaro (anche se è sempre possibile attraverso una VPN ottenere maggiore sicurezza sui canali di comunicazione).</p>
<p>In sostanza, il Load balancing è un argomento semplice da capire, e probabilmente ancora più semplice da ottenere anche con hardware non dedicato, grazie alle diverse opportunità che il mondo Open Source ci regala.</p>
<p>Come sempre, il grosso del problema è strutturare l’applicazione nel suo complesso, incastrando i vari elementi affinché tutto il flusso dei dati sia ottimale.</p>
<p>La scelta del bilanciatore non e&#8217; facile, ce ne sono di diversi tipi, sia hardware che software e, molte volte, la loro bonta&#8217; non dipende dal prezzo che lo pagate ma dalla giusta scelta che farete a monte, di ottimizzazione del servizio che dovete erogare. Possiamo dire che molto spesso, in ambito Opensource la scelta ricade su <a href="http://www.linuxvirtualserver.org/whatis.html">LVS</a>, <a href="http://www.haproxy.org/">HAProxy</a>, <a href="http://tuttiperlinux.com/2014/08/06/catturare-il-traffico-di-rete/">Pound</a>&#8230;, mentre in ambiti piu&#8217; istituzionali (Banche, Assicurazioni etc) la scelta spesso ricade su <a href="https://f5.com/glossary/load-balancer/">F5</a>, <a href="https://www.citrix.it/products/netscaler-application-delivery-controller/overview.html">Citrix</a>, <a href="http://www.radware.com/Solutions/ApplicationDelivery/">Radware</a>&#8230;.</p>
<p>Personalmente sono un sostenitore di LVS, che ho usato spesso in grossi progetti, ma vediamo quali sono i suoi punti di forza confrontandolo con l&#8217;altro ottimo prodotto Open HAProxy.</p>
<p>LVS lavora in kernel-space (disponibile quindi solo per Linux) il che lo rende estremamente leggero e veloce, anche se limitato in termini di funzionalità. Haproxy è invece un software che gira in user-space, sicuramente più portabile (gira praticamente su qualsiasi Linux/Unix) ma anche più costoso in termini di risorse.</p>
<p>Per darvi un idea di quante poche risorse usa LVS, considerate che ogni connessione attiva occupa solo 128 bytes di memoria (nella tabella dove queste vengono memorizzate). Con circa 4GB di RAM sarete in grado di smistare qualcosa tipo 500.000 connessioni simultanee.</p>
<p>LVS lavora al layer 4 (vedi <a href="https://it.wikipedia.org/wiki/Open_Systems_Interconnection">Open Systems Interconnection</a>), mentre HAProxy lavora al layer 7 della pila OSI. Se questo da una parte è un vantaggio per haproxy, che può ispezionare anche il contenuto del pacchetto, di fatto si traduce in un maggiore carico a livello di CPU e quindi minore scalabilità.  In un bilanciatore di carico con LVS il carico del server sarà quasi sempre pari a 0.00, mentre con haproxy si manterrà intorno allo 0.50.</p>
<p>Sempre con LVS è possibile ottimizzare il consumo di banda dei singoli server che compongono il cluster. Se configurato in modalità “Direct Routing” (o LVS-TUN) il bilanciatore si farà carico solo del traffico in ingresso mentre saranno i singoli server di backend ad inviare il traffico di risposta ai client remoti. Con haproxy (o LVS configurato come NAT) tutto il traffico IN/OUT passa dal bilanciatore il che lo tiene maggiormente sotto stress e vi constringe a dimensionarlo in modo da poter sostenere un traffico di rete pari alla somma totale del traffico diretta verso l’intero cluster.</p>
<p>Non ultimo LVS puo&#8217; vantare il tool <strong>ipvsadm</strong>, questo ottimo tool aggiorna la tabella d’instradamento IPVS nel kernel. Ipvsadm consente di modificare la configurazione di LVS aggiungendo e rimuovendo servizi, modificando la modalita&#8217; di forwarding, paradigmi di bilanciamento, ecc. Il pacchetto ipvsadm non ha interfacce grafiche e segue il principio unix, <strong>fare una cosa sola e farla bene</strong>, quindi risponde al solo compito di avere uno strumento per il bilanciamento a livello 4.</p>
<p>Con ipvsadm è possibile selezionare un metodo per passare i pacchetti dal server LVS ai real server dove gira il servizio, i metodi principali sono:</p>
<p><strong>LVS-DR</strong> (direct routing) dove il MAC addresses nel pacchetto è cambiato ed il pacchetto indirizzatto verso il real server<br />
<strong>LVS-NAT</strong> basato sul network address translation (NAT)<br />
<strong>LVS-TUN</strong> (tunneling) where the packet is IPIP encapsulated and forwarded to the realserver.</p>
<p><span style="line-height:1.5;">Praticamente un bilanciatore di carico con LVS lo potete accendere, configurare e dimenticarvelo per anni.</span></p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2015/12/02/load-balancing-systems/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2015/12/load-balancer-new.png?w=300" medium="image">
			<media:title type="html">Load Balancing Systems</media:title>
		</media:content>
	</item>
		<item>
		<title>Catturare il traffico di rete</title>
		<link>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/</link>
					<comments>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 06 Aug 2014 22:41:38 +0000</pubDate>
				<category><![CDATA[Load Balancing]]></category>
		<category><![CDATA[back-end]]></category>
		<category><![CDATA[bilanciamento]]></category>
		<category><![CDATA[carico]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[load balancing]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[opensource]]></category>
		<category><![CDATA[pound]]></category>
		<category><![CDATA[rinetd]]></category>
		<category><![CDATA[servizi]]></category>
		<category><![CDATA[url]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=281</guid>

					<description><![CDATA[Redirect fai da te Molte volte vi capitera&#8217; (ed a me e&#8217; capitato piu&#8217; volte) di aver bisogno di gestire il traffico di rete ottimizzandolo, filtrandolo e redirezionandolo. Si pensi, ad esempio, ai test di sviluppo effettuati sulle molte VM in cui si deve tenere conto della quantita&#8217; di Server interessati e del carico di &#8230; <a href="https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg"><img data-attachment-id="282" data-permalink="https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/redirect/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg" data-orig-size="252,200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="redirect" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=252" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=252" class="alignleft size-full wp-image-282" src="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=600" alt="redirect" srcset="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg 252w, https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=150 150w" sizes="(max-width: 252px) 100vw, 252px"   /></a>Redirect fai da te </strong></h3>
<p>Molte volte vi capitera&#8217; (ed a me e&#8217; capitato piu&#8217; volte) di aver bisogno di gestire il traffico di rete ottimizzandolo, filtrandolo e redirezionandolo.<br />
Si pensi, ad esempio, ai test di sviluppo effettuati sulle molte VM in cui si deve tenere conto della quantita&#8217; di Server interessati e del carico di rete da gestire bilanciando quest&#8217;ultimo e gestendo le porte interessate.</p>
<p>In questo articolo illustrero&#8217; alcuni dei migliori tra quelli da me usati in ambito OpenSource sono, <strong>Rinetd,</strong> <strong>LVS</strong> e <strong>Pound</strong>, ma l&#8217;elenco potrebbe ancora allungarsi, magari per un seguito.</p>
<p><strong>PARTIAMO</strong></p>
<p><strong>rinetd</strong></p>
<p>E&#8217; il piu&#8217; semplice dei tre, dunque partiremo da questo; esso permette di ridirigere una destinazione TCP, definita attraverso una coppia <em>&lt;indirizzo-ip&gt;</em>:<em>&lt;numero-di-porta&gt;</em>, presso un&#8217;altra coppia di questi valori. Lo scopo di questo può essere semplicemente quello di dirigere una porta locale verso un&#8217;altra porta locale, oppure si può arrivare a intercettare il traffico IP che attraversa un <em>router</em> in modo da ridirigere alcune coppie di indirizzi e porte presso altre destinazioni.</p>
<p>Tutto è composto semplicemente da un <em>daemon</em>, <b><code>rinetd</code></b>, che si avvale di un file di configurazione, <code>/etc/rinetd.conf</code>, nel quale si indicano semplicemente le ridirezioni da applicare.</p>
<p>La presenza in funzione di <b><code>rinetd</code></b> è incompatibile con altri <em>daemon</em> che stanno in ascolto delle stesse porte che devono essere ridirette, anche se queste sono intese appartenere a <em>host</em> differenti.</p>
<p>Il programma rinetd è il demone che si occupa di ridirigere il traffico TCP in base a quanto contenuto nel file di configurazione <code class="file">/etc/rinetd.conf<br />
E' sufficiente avviarlo e, se il file di configurazione risultera'corretto, iniziare subito a lavorarci. All'avvio, dopo aver letto la configurazione, rinetd deve poter stare in ascolto dell'indirizzo da ridirigere e della porta relativa; qualunque sia l'indirizzo in questione, è necessario che non ci sia già un programma locale che fa la stessa cosa su quella stessa porta; per esempio, non si può tentare di ridirigere il servizio HTTP di un indirizzo qualunque, se questo è presente localmente.</code></p>
<p>Un esempio di configurazione del file rinetd.conf dovrebbe essere sufficiente a chiarire le idee su questo file. Supponiamo di voler dirottare il traffico diretto verso l&#8217;indirizzo IP 10.11.12.13 alla porta 80, in modo che questo vada verso l&#8217;indirizzo IP 192.168.1.7, alla porta 80.</p>
<pre>120.121.122.123 80 192.168.1.7 80</pre>
<p>L&#8217;indirizzo da ridirigere, può appartenere a un&#8217;interfaccia del nodo presso cui si trova in funzione il demone rinetd,<br />
oppure no, purché i pacchetti diretti a tale indirizzo transitino attraverso il nodo che attua la ridirezione.<br />
Se si vuole apprendere il funzionamento di rinetd senza disporre di una rete vera e propria, basta una direttiva di configurazione simile a quella seguente:</p>
<pre>localhost 8888 localhost html</pre>
<p>In questo modo, la porta locale 8888 viene ridiretta sulla porta del servizio HTTP (80). Se il servizio HTTP è attivo, si può verificare la ridirezione con un programma di navigazione qualunque, puntando all&#8217;URL</p>
<pre>http://localhost:8888</pre>
<p>Rispetto ai prossimi due tool rinetd non e&#8217; in grado di fungere anche come LoadBalancer.</p>
<hr />
<p><strong>ipvsadm</strong></p>
<p>Questo servizio aggiorna la tabella d&#8217;instradamento IPVS nel kernel. Il demone <strong><code class="command">lvs</code></strong> imposta e gestisce Load Balancer Add-On richiamando <strong><code class="command">ipvsadm</code></strong> per aggiungere, modificare e cancellare le voci all&#8217;interno della tabella d&#8217;instradamento IPVS. Inoltre ipvsadm fa parte del paccheto LVS  che è una soluzione di bilanciamento del carico avanzato per sistemi Linux.<br />
Si tratta di un progetto open source avviato da Wensong Zhang nel lontano 1998. La missione del progetto è di costruire un server ad alte prestazioni e ad alta disponibilità per Linux utilizzando tecnologie di clustering, offrendo una buona scalabilità, affidabilità e facilità di manutenzione. L’opera principale del progetto LVS è ora quello di sviluppare un software avanzato di bilanciamento del carico IP (IPVS), ed un software di bilanciamento a livello dell’applicazione (KTCPVS), ed i componenti di gestione dei cluster.</p>
<h3>Ipvs in pratica</h3>
<p>IPVS (IP Virtual Server) implementa un bilanciatore di carico a livello Layer 4 della rete. IPVS in esecuzione su un host si comporta come un sistema di bilanciamento del carico di fronte ad un insieme di server reali in cluster, può indirizzare le richieste per servizi basati si TCP/UDP ai veri server, e fa apparire i servizi dei server reali come un unico servizio virtuale su un unico indirizzo IP.</p>
<p>La componente IPVS è presente in tutti i recenti Kernel, per installare la componente in user-space utilizzate il vostro gestore di pacchetti, ad esempio in Ubuntu:</p>
<pre>aptitude install ipvsadm</pre>
<p>a questo punto si può creare uno script da far avviare al boot. Io di solito inserisco i comandi all’interno del file<br />
<strong>/etc/rc.local</strong>.</p>
<div>Prima di tutto dobbiamo <em>resettare</em> l’attuale configurazione con il comando:</div>
<pre>ipvsadm -C</pre>
<div>Dopodiché iniziamo a dare le regole con i comandi come nell’esempio qui sotto in cui diciamo che le chiamate TCP (parametro -t) all’indirizzo 192.168.10.100 sulla porta 5060 (quella per il protocollo SIP) debbano essere inoltrate alla stessa porta dell’indirizzo 192.168.10.250.  Per reindirizzare una chiamata UDP sostituire il -t con -u.</div>
<pre>ipvsadm -A -t 192.168.10.100:5060 -s rr</pre>
<p>ipvsadm -a -t 192.168.10.100:5060 -r 192.168.10.250:5060 -m</p>
<div id="_mcePaste">Naturalmente è possibile catturare il traffico su una porta e inoltrarla ad un’altra con un comando tipo questo:</div>
<div>ipvsadm -A -t 192.168.10.100:88 -s rr</div>
<div>ipvsadm -a -t 192.168.10.100:88 -r 192.168.10.250:80 -m</div>
<div>In questo caso non abbiamo fatto altro che prendere le chiamate alla porta 88 dell’indirizzo 192.168.10.100 e rinviarle al server web dell’IP 192.168.10.250 sulla normale porta 80</div>
<p><strong>Metodi di bilanciamento utilizzati da LVS</strong></p>
<p>In caso si desideri testare il funzionamento di <strong>LVS</strong> senza la necessita&#8217; di monitorare i servizi e possibile aggiungere e rimuovere nodi con il comando <code>ipvsadm</code>:<br />
<code><br />
ipvsadm -C<br />
ipvsadm -A -t 10.2.1.164:8080 -s lc<br />
ipvsadm -a -t 10.2.1.164:8080 -r 10.2.1.166 -g<br />
ipvsadm -a -t 10.2.1.164:8080 -r 10.2.1.165 -g<br />
</code><br />
Le opzioni utilizzate nelle linee di comando di ipvsadm per l&#8217;esempio riportato sono le seguenti:</p>
<p>&#8211; <strong>-C</strong>, <strong>&#8211;clear</strong>: cancella la tabella del virtual server.<br />
&#8211; <strong>-A</strong>, <strong>&#8211;add-service</strong>: crea un servizio virtuale.<br />
&#8211; <strong>-a</strong>, <strong>&#8211;add-server</strong>: aggiunge un nodo ad un servizio virtuale.<br />
&#8211; <strong>-t</strong>, <strong>&#8211;tcp-service</strong>: specifica indirizzo ip e numero di porta tcp del servizio virtuale.<br />
&#8211; <strong>-s</strong>, <strong>&#8211;scheduler</strong>: specifica l&#8217;algoritmo di bilanciamento<br />
&#8211; <strong>-r</strong>, <strong>&#8211;real-server</strong>: specifica l&#8217;indirizzo ip del nodo reale<br />
&#8211; <strong>-g</strong>, <strong>&#8211;gatewaying</strong>: indica il metodo di forwarding direct routing (<strong>LVS-DR</strong>)</p>
<p><strong>** algoritmi per il bilanciamento che possiamo usare con LVS</strong>.</p>
<p><strong>Statici</strong>:</p>
<p>&#8211; Round Robin</p>
<p>&#8211; Weighted Round Robin</p>
<p>&#8211; Destination Hashing</p>
<p>&#8211; Source Hashing</p>
<p><strong>Dinamici</strong>:</p>
<p>&#8211; Least-Connection</p>
<p>&#8211; Weighted least-connection</p>
<p>&#8211; Never queue</p>
<p>&#8211; Locality-based least-connection</p>
<p>&#8211; Locality-based least-connection with replication scheduling</p>
<p>&#8211; Shortest expected delay</p>
<hr />
<p><strong>pound<br />
</strong></p>
<p>Pound è un proxy server di bilanciamento del carico inverso. Accetta richieste da HTTP / HTTPS clienti e li distribuisce a uno o più server web. Le richieste HTTPS vengono decifrati e passati al back-end come semplice protocollo HTTP.</p>
<p>Se più di un server back-end è definita, Pound sceglie uno di loro a caso, sulla base delle priorità definite. Per impostazione predefinita, Pound tiene traccia di associazioni tra client e server back-end (sessioni).</p>
<p>General Principles</p>
<p>In generale, Pound ha bisogno di tre tipi di oggetti definiti, al fine di funzione: ascoltatori , i servizi e back-end .</p>
<p><strong>Ascoltatori</strong><br />
Un ascoltatore è una definizione di come Pound riceve le richieste dai client (browser). Due tipi di ascoltatori può essere definito: normale connessione HTTP ascoltatori e HTTPS (HTTP su SSL / TLS) ascoltatori . Per lo meno un ascoltatore deve definire l&#8217;indirizzo e la porta per l&#8217;ascolto su, con ulteriori requisiti per HTTPS ascoltatori .</p>
<p><strong>Servizi</strong><br />
Un servizio è la definizione di come le domande trovano risposta. Il servizio può essere definito all&#8217;interno di un ascoltatore o al livello superiore (globale). Quando viene ricevuta una richiesta Pound tenta di far corrispondere a ciascun servizio , a sua volta, a partire dai servizi definiti nel ascoltatore stesso e, se necessario, di proseguire con l&#8217; servizi definiti a livello globale. I servizi possono definire le proprie condizioni al quale le domande si può rispondere: in genere si tratta certo URL (solo foto, o un certo percorso) o intestazioni specifiche (come ad esempio l&#8217;intestazione Host). Un servizio può anche definire una sessione meccanismo: se definito le richieste future da un determinato cliente sarà sempre la stessa risposta da parte di back-end .</p>
<p><strong>Back-end</strong><br />
Il back-end sono i server reale per il contenuto richiesto. Di per sé, Pound fornisce nessuna risposta &#8211; tutti i contenuti devono essere ricevuti da un vero e proprio &#8220;web server&#8221;. Il back-end definisce come il server dovrebbe essere contattato.</p>
<p>Tre tipi di back-end può essere definito: un &#8220;regolare&#8221; back-end che riceve le richieste e le risposte restituisce, un &#8220;redirect&#8221; back-end in questo caso, Pound risponde con una risposta redirect, senza l&#8217;accesso a qualsiasi back-end a tutti , o una &#8220;emergenza&#8221; back-end che sarà usato solo se tutti gli altri backend sono &#8220;morti&#8221;.</p>
<p>Multiple back-end può essere definito all&#8217;interno di un servizio , nel qual caso Pound sarà bilanciamento del carico tra i disponibili back-end .</p>
<p>Se un back-end non riesce a rispondere, sarà considerato &#8220;morto&#8221;, nel qual caso Pound si ferma l&#8217;invio di richieste ad esso. Dead indietro _ e NDS sono periodicamente controllate per la disponibilità, e una volta che rispondono ancora sono &#8220;resurected&#8221; e le richieste sono inviati di nuovo la loro strada. Se non back-end sono disponibili (nessuno è stato definito, o sono tutti &#8220;morti&#8221;), allora Pound risponderà con &#8220;503 Servizio non disponibile&#8221;, senza verificare ulteriori servizi .</p>
<p>Il collegamento tra Pound e il back end- è sempre via HTTP, a prescindere dal protocollo utilizzato tra Pound e il cliente.</p>
<p><strong>Installazione </strong></p>
<pre>sudo apt-get install pound</pre>
<p>La gestione completa del servizio avviene tramite la configurazione del file <strong>/etc/pound/pound.cfg</strong><br />
<strong>Esempio 1:</strong></p>
<p><strong>Semplice configurazione HTTP Proxy </strong><br />
Supponiamo di forwardare le richieste http che arrivano dall”IP pubblico 202.54.10.5 all’IP sulla LAN 192.168.1.5 su cui è configurato un web server Apache sulla porta 8080.<br />
Editiamo il file di configurazione di pound di una distro Debian/Ubuntu:</p>
<p>vim /etc/pound/pound.cfg</p>
<p>Questo è l’aspetto del file:</p>
<pre>ListenHTTP
Address  202.54.10.5
Port          80
Service
BackEnd
Address  192.168.1.5
Port           8080
End
End
End</pre>
<p>Salvare e chiudere il file e restartare Pound:</p>
<p>/etc/init.d/pound restart</p>
<p><strong>Esempio 2</strong><br />
<strong>Semplice configurazione HTTP &amp; HTTPS Proxy<br />
</strong>In questo esempio vediamo come “proxare” una richiesta http e https dallo stesso IP pubblico 202.54.10.5 a due web server 192.168.1.5 e 192.168.1.6, entrambi sulla porta 80:</p>
<pre>ListenHTTP
Address  202.54.10.5
Port          80
End

ListenHTTPs
Address   202.54.10.5
Port           443
Cert           “/etc/ssl/local.server.pem” -–&gt;percorso certificato ssl
End

Service
BackEnd
Address     192.168.1.5
Port              80
Priority       1
Backend
Address     192.168.1.6
Port              80
Priority       3
End
End</pre>
<p>Salviamo il file di configurazione e restartiamo pound.</p>
<p>In questo esempio le richieste alla porta 80 all’ ip 202.54.10.5  vengono inoltrate alla porta 80 del webserver 192.168.1.5, mentre le richieste alla porta 443 dall’ ip 202.54.10.5 vengono inoltrate alla porta 80 del web server 192.168.1.6  e in questo caso pound gestisce il certificato ssl, che è possibile generarsi senza alcuna modifica nel backend del web server, che continua a gestire chiamate in http.</p>
<p><strong>PS:</strong> e&#8217; possibile inoltre impostare una priorità di inoltro del traffico differente, nel caso si disponga di più server web, cosi&#8217; come indicato dalla voce &#8220;Priority&#8221; presente nella configurazione del secondo esempio; minore è la cifra, maggiore sarà la priorità assegnata al server.</p>
<p>Buon divertimento !</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg" medium="image">
			<media:title type="html">redirect</media:title>
		</media:content>
	</item>
	</channel>
</rss>
