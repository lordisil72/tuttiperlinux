<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>honeypot &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/honeypot/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Mon, 30 Jan 2017 13:51:36 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>honeypot &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Difenditi con ARTILLERY</title>
		<link>https://tuttiperlinux.blog/2017/01/30/1296/</link>
					<comments>https://tuttiperlinux.blog/2017/01/30/1296/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Mon, 30 Jan 2017 13:51:11 +0000</pubDate>
				<category><![CDATA[Networking]]></category>
		<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[alerting]]></category>
		<category><![CDATA[artillery]]></category>
		<category><![CDATA[brute force]]></category>
		<category><![CDATA[firewall]]></category>
		<category><![CDATA[git]]></category>
		<category><![CDATA[github]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[iptables]]></category>
		<category><![CDATA[monitoring]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[security]]></category>
		<category><![CDATA[social engineering toolkit]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=1296</guid>

					<description><![CDATA[In questo articolo parleremo di un tool che si pone come interessante aiuto verso la sicurezza delle nostre macchine in rete, il suo nome e&#8217; Artillery , esso è un interessante software scritto interamente in python. La cosa molto interessante di questo tool e&#8217; che lo possiamo intendere come una combinazione tra un honeypot, un tool &#8230; <a href="https://tuttiperlinux.blog/2017/01/30/1296/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_1297" style="width: 257px" class="wp-caption alignnone"><img loading="lazy" aria-describedby="caption-attachment-1297" data-attachment-id="1297" data-permalink="https://tuttiperlinux.blog/2017/01/30/1296/project-artillery/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png" data-orig-size="284,345" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="project-artillery" data-image-description="&lt;p&gt;Artillery Honeypot All-in-one&lt;/p&gt;
" data-image-caption="&lt;p&gt;Artillery Honeypot All-in-one&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png?w=247" data-large-file="https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png?w=284" class="size-medium wp-image-1297" src="https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png?w=247&#038;h=300" alt="Artillery Honeypot All-in-one" width="247" height="300" srcset="https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png?w=247&amp;h=300 247w, https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png?w=123&amp;h=150 123w, https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png 284w" sizes="(max-width: 247px) 100vw, 247px" /><p id="caption-attachment-1297" class="wp-caption-text">Artillery Honeypot All-in-one</p></div>
<p>In questo articolo parleremo di un tool che si pone come interessante aiuto verso la sicurezza delle nostre macchine in rete, il suo nome e&#8217; <strong>Artillery </strong>, esso è un interessante software scritto interamente in python. La cosa molto interessante di questo tool e&#8217; che lo possiamo intendere come una combinazione tra un honeypot, un tool di monitoraggio, ed un sistema di alerting. Uahoooo, tutto in un&#8217;unico strumento&#8230;&#8230;.</p>
<p>I principi di funzionamento si caratterizzano dal fatto che in presenza di determinate attività di networking esso si comporta parzialmente come un honeypot, adottando anche manovre evasive e, contemporaneamente monitorizza il cambiamento di file sensibili; in entrambi i casi avvisando di quanto riscontrato i destinatari designati.<br />
Artillery si pone in ascolto su di un certo numero di porte di uso comune (peraltro configurabile, tramite la variabile PORTS), e qualora riceva una richiesta di connessione per uno qualsiasi dei servizi fasulli, blocca in modo permanente l’indirizzo IP sorgente aggiungendo una relativa regola con target DROP a iptables.</p>
<p><strong>Artillery può essere anche usato per prevenire attacchi di tipo brute force<br />
</strong><br />
L’ installazione ed il lancio di Artillery sono molto semplici: una volta effettuato il download via <strong>git</strong>, occorre lanciare uno script installer, editare un file di configurazione (&#8220;all&#8217;inizio questo passaggio sara&#8217; meglio farlo su macchina virtuale per fare pratica della configurazione delle regole&#8221;) e poi mandarlo in esecuzione:</p>
<p># cd /opt<br />
# <code>apt-get update &amp;&amp; apt-get install git [solo se ancora non avete installato il pacchetto git]<br />
# git clone https://github.com/trustedsec/artillery/ artillery/<br />
# cd artillery<br />
</code># sudo ./setup.py</p>
<p>Welcome to the Artillery installer. Artillery is a honeypot, file monitoring, and overall security tool used to protect your nix systems.</p>
<p>Written by: Dave Kennedy (ReL1K)</p>
<p>Do you want to install Artillery and have it automatically run when you restart [y/n]: y<br />
[*] Beginning installation. This should only take a moment.<br />
[*] Adding artillery into startup through init scripts..<br />
[*] Triggering update-rc.d on artillery to automatic start&#8230;<br />
Do you want to keep Artillery updated? (requires internet) [y/n]: y<br />
[*] Checking out Artillery through github to /var/artillery<br />
Cloning into &#8216;/var/artillery&#8217;&#8230;<br />
remote: Counting objects: 876, done.<br />
remote: Total 876 (delta 0), reused 0 (delta 0), pack-reused 876<br />
Receiving objects: 100% (876/876), 207.83 KiB | 293.00 KiB/s, done.<br />
Resolving deltas: 100% (568/568), done.<br />
Checking connectivity&#8230; done.<br />
[*] Finished. If you want to update Artillery go to /var/artillery and type &#8216;git pull&#8217;<br />
Would you like to start Artillery now? [y/n]: y<br />
Starting Artillery&#8230; Ok<br />
[*] Installation complete. Edit /var/artillery/config in order to config artillery to your liking..</p>
<p>Durante il processo di installazione verranno poste, come potete leggere qui sopra, alcune domande:<br />
Do you want to install Artillery and have it automatically run when you restart [y/n]:<br />
Do you want to keep Artillery updated? (requires internet) [y/n]:<br />
Would you like to start Artillery now? [y/n]:</p>
<p>Artillery verrà installato come servizio sotto /etc/init.d/<br />
E’ sempre consigliabile leggere con attenzione prima d&#8217; impostare il file di configurazione.<br />
In ogni caso, una volta effettuate delle modifiche alla configurazione, si può impartire e renderle immediatamente operanti:<br />
# python restart_server.py</p>
<p>Fate attenzione a non commettere l’errore di editare invece i files risultanti dal download via git. Una volta che che lo script di installazione sia stato eseguito, per modificarne la configurazione posizionatevi piuttosto nella directory /var/artillery.</p>
<p>Il contenuto del file <strong>config</strong> è piuttosto chiarificatore delle funzionalità del software:<br />
# determina se attivare l&#8217;attività di monitoraggio dell&#8217;integrità di files sensibili<br />
MONITOR=YES<br />
#<br />
# le directories da monitorare, se ne possono ancora aggiungere &#8220;/root&#8221;,&#8221;/var/&#8221;, ecc.<br />
MONITOR_FOLDERS=&#8221;/var/www&#8221;,&#8221;/etc/&#8221;<br />
#<br />
# frequenza del controllo in secondi.<br />
MONITOR_FREQUENCY=60<br />
#<br />
# esclusione dal controllo per certe directories o files, ad esempio: /etc/passwd,/etc/hosts.allow<br />
EXCLUDE=<br />
#<br />
# determina se attivare l&#8217;attività di HONEYPOT<br />
HONEYPOT=YES<br />
#<br />
# ban automatico HONEYPOT<br />
HONEYPOT_BAN=YES<br />
#<br />
# WHITELIST di indirizzi IP non vincolati dalle regole di controllo<br />
WHITELIST_IP=127.0.0.1,localhost<br />
#<br />
# PORTS su cui attivare il monitoring<br />
PORTS=&#8221;135,445,22,1433,3389,8080,21,5900,25,53,110,1723,1337,10000,5800,44443&#8243;<br />
#<br />
# determina se attivare l&#8217;alerting via email<br />
EMAIL_ALERTS=OFF<br />
#<br />
# username SMTP<br />
USERNAME=&#8221;thisisjustatest@gmail.com&#8221;<br />
#<br />
# password SMTP<br />
PASSWORD=&#8221;pass&#8221;<br />
#<br />
# destinatario<br />
SMTP_TO=&#8221;testing@test.com&#8221;<br />
#<br />
# server per l&#8217;invio, per default gmail<br />
SMTP_ADDRESS=&#8221;smtp.gmail.com&#8221;<br />
#<br />
# Porta SMTP per l&#8217;invio. Di default è quella gmail con TTLS<br />
SMTP_PORT=&#8221;587&#8243;<br />
#<br />
# Indirizzo EMAIL su cui ricevere gli ALERTS<br />
ALERT_USER_EMAIL=&#8221;user@whatever.com&#8221;<br />
#<br />
# determina se l&#8217;invio delle email di alerting debba avvenire seguendo una certa frequenza. Se impostato a off, gli alerts<br />
# verranno inviati automaticamente in tempo reale (può significare un mucchio di spam)<br />
EMAIL_TIMER=ON<br />
#<br />
# la frequenza con la quale saranno inviati gli ALERTS per email (per default ogni 10 minuti)<br />
EMAIL_FREQUENCY=600<br />
#<br />
# Attivazione del monitoraggio dei tentativi BRUTE FORCE contro SSH<br />
SSH_BRUTE_MONITOR=ON<br />
#<br />
# Quanti tentativi prima del BAN<br />
SSH_BRUTE_ATTEMPTS=4<br />
#<br />
# Per effettuare degli aggiornamenti automatici<br />
AUTO_UPDATE=OFF<br />
#<br />
# ANTI DOS imposta la macchina a limitare le connessioni, e va impostato ad OFF nel caso non lo si intenda utilizzare<br />
ANTI_DOS=ON<br />
#<br />
# Le porte dotate di protezione ANTI-DOS<br />
ANTI_DOS_PORTS=80,443<br />
#<br />
# I parametri che limitano le connessioni come misura anti DOS<br />
ANTI_DOS_THROTTLE_CONNECTIONS=50<br />
ANTI_DOS_LIMIT_BURST=200<br />
#</p>
<p>Artillery ha un set di porte (comuni o comunemente attaccate) preimpostato sulle quali si pone in ascolto.<br />
A rivelarle basta un semplice:</p>
<p># netstat -antp |grep LISTEN<br />
tcp 0 0 0.0.0.0:21 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:53 0.0.0.0:* LISTEN 827/dnsmasq<br />
tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 637/sshd<br />
tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN 706/cupsd<br />
tcp 0 0 0.0.0.0:1433 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:1337 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:25 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:90 0.0.0.0:* LISTEN 734/nginx -g daemon<br />
tcp 0 0 0.0.0.0:44443 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:1723 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:47323 0.0.0.0:* LISTEN 616/rpc.statd<br />
tcp 0 0 0.0.0.0:445 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:3389 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:135 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:5800 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN 1089/mysqld<br />
tcp 0 0 0.0.0.0:5900 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:110 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:111 0.0.0.0:* LISTEN 606/rpcbind<br />
tcp 0 0 0.0.0.0:10000 0.0.0.0:* LISTEN 2428/python<br />
tcp 0 0 0.0.0.0:8080 0.0.0.0:* LISTEN 2428/python<br />
tcp6 0 0 :::53 :::* LISTEN 827/dnsmasq<br />
tcp6 0 0 :::22 :::* LISTEN 637/sshd<br />
tcp6 0 0 ::1:631 :::* LISTEN 706/cupsd<br />
tcp6 0 0 :::46327 :::* LISTEN 616/rpc.statd<br />
tcp6 0 0 :::90 :::* LISTEN 734/nginx -g daemon<br />
tcp6 0 0 :::111 :::* LISTEN 606/rpcbind<br />
tcp6 0 0 :::80 :::* LISTEN 1153/apache2<br />
&#8230;</p>
<p><strong>P.S.</strong>: L’esclusione dell’indirizzo IP che non riesca ad autenticarsi validamente viene effettuata attraverso il controllo del file /var/log/auth.log (per le distribuzioni basate su Debian).</p>
<p>Il tool e&#8217; potente ed altamente configurabile; non rimane che dare un&#8217;occhiata alla configurazione e fare qualche prova, magari all&#8217;inizio giocando con qualche servizio aperto su di una VM.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2017/01/30/1296/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2017/01/project-artillery.png?w=247" medium="image">
			<media:title type="html">Artillery Honeypot All-in-one</media:title>
		</media:content>
	</item>
		<item>
		<title>Firewall apriamo un passaggio segreto</title>
		<link>https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/</link>
					<comments>https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 24 Sep 2014 08:58:29 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[fwknop]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[iptables]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[payload]]></category>
		<category><![CDATA[portknoking]]></category>
		<category><![CDATA[replay-attack]]></category>
		<category><![CDATA[spa]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[tcp-ip]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=594</guid>

					<description><![CDATA[Port-knoking &#8211; II Episodio Poco tempo fa abbiamo affrontato il concetto di sicurezza utilizzando la tecnologia del port-knoking . Oggi affronteremo una seconda metodologia legata al port knoking. Facciamo un passo indietro considerando il firewall il miglior sistema di difesa in nostro possesso. Il port-knoking e&#8217; in pratica una tecnica di autorizzazione che agisce sul firewall &#8230; <a href="https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg"><img loading="lazy" data-attachment-id="595" data-permalink="https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/fwknop_spa/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg" data-orig-size="750,367" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fwknop_spa" data-image-description="&lt;p&gt;Portknoking con Fwknop&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=600" class="alignleft size-medium wp-image-595" src="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=300&#038;h=146" alt="fwknop_spa" width="300" height="146" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=298&amp;h=146 298w, https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=597&amp;h=292 597w, https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=150&amp;h=73 150w" sizes="(max-width: 300px) 100vw, 300px" /></a>Port-knoking &#8211; II Episodio</strong></h3>
<p>Poco tempo fa abbiamo affrontato il concetto di sicurezza utilizzando la tecnologia del <strong>port-knoking </strong>. Oggi affronteremo una seconda metodologia legata al port knoking.</p>
<p>Facciamo un passo indietro considerando il firewall il miglior sistema di difesa in nostro possesso. Il port-knoking e&#8217; in pratica una tecnica di autorizzazione che agisce sul firewall e che puo&#8217; essere realizzato con diverse metodologie; la &#8220;bussata&#8221; dipendera&#8217; dal software di port-knoking utilizzato, ma in tutti i casi si compone di pacchetti TPC/IP appositamente forgiati dall&#8217;utente.</p>
<p>Le tipologie piu&#8217; frequenti sono due:</p>
<ul>
<li><strong>sequenza</strong> affinche&#8217; l&#8217;utente venga riconosciuto , il client deve inviare alcuni pacchetti secondo una sequenza creata al momento della configurazoine su diverse porte TCP o UDP;</li>
<li><strong>payload</strong> tutto il necessario per il riconoscimento dell&#8217;utente e&#8217; contenuto nel payload dei pacchetti</li>
</ul>
<p>a) la prima tipologia e&#8217; di facile realizzazione e utilizzo, ma e&#8217; relativamente fragile perche&#8217; basta uno sniffer di pacchetti per ascoltare la sequenza la sequenza inviata al server, replicarla e ottenere cosi&#8217; l&#8217;accesso;</p>
<p>b) se il nostro desiderio di sicurezza e&#8217; piu&#8217; paranoico, allora soltanto il port-knoking basato sui payload potranno soddisfarci, inqunato questi sono al sicuro dai tentativi di replay-attack.</p>
<h3><strong>PARANOIA</strong></h3>
<p>Il mondo e&#8217; bello ma e&#8217; pericoloso, se questo e&#8217; assodato anche per voi possiamo passare alla visione piu&#8217; paranoica per provare una nuova configurazione tramite il software <strong>fwknop</strong>, un sistema di port-knoking che pone la sua forza nel criptare i payload del pacchetto di autorizzazione.</p>
<p><strong>Fwknop</strong> va oltre al semplice sistema di port-knoking, esso in realta&#8217; e&#8217; il prototipo di una nuova tecnologia chiamata : <strong>Single Packet Authorization </strong>o (<strong>SPA</strong>) che si differenzia proprio per la possibilita&#8217; di autorizzare l&#8217;utente utilizzando un&#8217;unico pacchetto TCP/IP.</p>
<p><strong>SPA</strong> si comporta alla stessa maniera del port-knoking, solo che  invia un singolo pacchetto criptato verso il server di destinazione.<br />
Questo comporta una migliore velocità nell’accedere al servizio che decidiamo di nascondere (esempio SSH), ed un maggiore livello di discrezione sulla rete (al contrario il Port Knocking classico può essere scambiato per un tentativo di port scanning da un IDS) e soprattutto protegge dai tentativi di connessioni replicate ( il singolo pacchetto criptato viene creato tutte le volte con valore casuale e non può essere riutilizzato!).</p>
<p><strong><em>Fwknop è composto da un client ed un server</em></strong>.<br />
Il demone fwknopd installato sul server sniffa le connesioni che arrivano sull’interfaccia di rete tramite la libreria libpcap, appena riceve dal client il pacchetto criptato e firmato con la chiave giusta abilita la connessione dell’indirizzo IP sorgente verso il servizio prestabilito (iptables).<br />
Una volta inviato il pacchetto tramite il client fwknop si ha un lasso di tempo per stabilire la connessione verso il servizio protetto (di default 30 sec.), sfiorata questa tempistica il server chiude la connessione.</p>
<p><strong>INSTALLAZIONE</strong></p>
<pre>sudo apt-get install fwknop-server libpcap-dev

sudo apt-get install fwknop-client</pre>
<p>Oltre ai pacchetti vanno inserite due regole iptables fondamentali per il funziomaneto di fwknop:</p>
<div>
<pre><strong>iptables -I INPUT 1 -i eth0 -p tcp --dport 22 -j DROP
iptables -I INPUT 1 -i eth0 -p tcp --dport 22 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</strong></pre>
</div>
<p>La prima blocca tutte le connessioni in entrata per il servizio SSH, la seconda invece accetta le connessioni già stabilite (questa servirà quando fwknop server ci autorizzerà a collegarsi verso il demone ssh).<br />
ATTENZIONE!!!<br />
Così facendo chiuderete tutte le connessioni verso ssh, accertatevi di poter accedere al server<br />
dalla console locale o abilitate la connessione a un singolo ip.<br />
Esempio:</p>
<pre><strong>iptables -I INPUT -i eth0 -s 3.3.3.3 -p tcp --dport 22 -j ACCEPT

</strong></pre>
<p>In questo caso le configurazioni sul server remoto le eseguirò da una connessione con ip 3.3.3.3 , che avra&#8217; libero accesso.</p>
<h3>Configurazione fwknop server/client</h3>
<p>Immaginiamo lo scenario:</p>
<p>ServerSPA: 2.2.2.2</p>
<p>ClientSPA: 1.1.1.1</p>
<p>UserClientSPA: pippo</p>
<p><strong>***</strong> Geneare le chiavi sul client e prenderne nota:</p>
<pre>pippo@clientspa:~$ <strong>fwknop -A tcp/22 -D 2.2.2.2 --key-gen --use-hmac --save-rc-stanza</strong>
[*] Creating initial rc file: /home/pippo/.fwknoprc.
[+] Wrote Rijndael and HMAC keys to rc file: /home/pippo/.fwknoprc
pippo@clientspa:~$
pippo@clientspa:~$ <strong>grep KEY /home/pippo/.fwknoprc</strong>
KEY_BASE64                  NPhe11+ORlK1Yfr4ipzW+ngQxzRt8kjI6UTDXLZYSv0=
HMAC_KEY_BASE64             SypMEUIhiAKTjeHlHoWR5dfu7hrLVvLnoIXINPbGTOowST1vUIs+tOtMc/XlKl6+JcVw7qc2jrpqmKujZxvnqw==
pippo@clientspa:~$

</pre>
<p><strong>***</strong> Creare sul serverspa (2.2.2.2) il file “<strong>/etc/fwknop/access.conf</strong>” inserendo le chiavi del client:</p>
<pre>SOURCE                     ANY
REQUIRE_SOURCE_ADDRESS     Y
KEY_BASE64                  NPhe11+ORlK1Yfr4ipzW+ngQxzRt8kjI6UTDXLZYSv0=
HMAC_KEY_BASE64             SypMEUIhiAKTjeHlHoWR5dfu7hrLVvLnoIXINPbGTOowST1vUIs+tOtMc/XlKl6+JcVw7qc2jrpqmKujZxvnqw==</pre>
<p><strong>***</strong> Controllare che sul file di configurazione del serverspa (2.2.2.2) sia configurata l’interfaccia di rete (WAN) corretta su cui fwknopd starà in ascolto:</p>
<pre>[root@serverspa]# <strong>grep PCAP_INTF /etc/fwknop/fwknopd.conf</strong>
# the PCAP_INTF setting.
PCAP_INTF                   eth0;</pre>
<p><strong>***</strong>  Far partire il demone fwknop sul serverspa (2.2.2.2):</p>
<pre>[pippo@serverspa]$ <strong>sudo /etc/init.d/fwknop-server start</strong>
Avvio di fwknopd:                                          [  OK  ]
[pippo@serverspa]$</pre>
<p><strong>Test di connessione</strong></p>
<p>Controllare che il serverspa (2.2.2.2) blocchi di default le connessioni verso il servizio SSH:</p>
<pre>pippo@<strong>clientspa</strong>:~$ <strong>nmap 2.2.2.2 -p22</strong>

Starting Nmap 6.40 ( http://nmap.org ) at 2014-04-30 23:21 CEST
Nmap scan report for 2.2.2.2
Host is up (0.0011s latency).
PORT   STATE    SERVICE
22/tcp <strong>filtered</strong> ssh

Nmap done: 1 IP address (1 host up) scanned in 1.97 seconds</pre>
<p><strong>***</strong> Spedire il pacchetto SPA al serverspa ed abilitare l’accesso SSH al clientspa:</p>
<p>pippo@clientspa:~$ <strong>fwknop -n 2.2.2.2 -a 1.1.1.1 # </strong>in assenza di ip statico 1.1.1.1 dovrà essere sempre sostituito dall&#8217;ip pubblico assegnato dal vostro ISP.</p>
<p>&nbsp;</p>
<p><strong>***</strong> Collegarsi dal clientspa verso il serverspa tramite ssh client <strong>entro 30 secondi</strong> :</p>
<pre>pippo@clientspa:~$ <strong>fwknop -n 2.2.2.2 -a 1.1.1.1</strong>
pippo@clientspa:~$ <strong>ssh root@2.2.2.2</strong>
root@2.2.2.2's password:
Last login: Wed Apr 30 23:06:51 2014 from 5.5.5.5
[root@serverspa ~]#</pre>
<p><strong>Conclusioni</strong></p>
<p>Fwknop non puo&#8217; garantire una sicurezza assoluta (come nessun altro software) ma integrato nel vostro sistema insieme ad altri tool puo&#8217; aumentarne notevolmente il livello.</p>
<p>Pro:</p>
<ul>
<li>Protegge i servizi da eventuali 0-day</li>
<li>Riduce i tempi di risposta del Port Knocking</li>
<li>Cripta il playload</li>
<li>Disponibilità del client per vari dispositivi</li>
</ul>
<p>Contro:</p>
<ul>
<li>Non è utilizzabile con tutti i servizi (soprattutto quelli pubblici a cui devono accedere qualsiasi utente)</li>
<li>Devi sempre avere un client disponibile</li>
</ul>
<p>&nbsp;</p>
<p>*** Leggi anche <a title="Sicurezza con il PortKnocking" href="http://tuttiperlinux.com/2014/08/30/sicurezza-con-il-portknocking/">Portknoking</a> &amp; <a title="Sicurezza – Honeypot SSH" href="http://tuttiperlinux.com/2014/09/03/sicurezza-honeypot-ssh/">Honeypot SSH</a></p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=300" medium="image">
			<media:title type="html">fwknop_spa</media:title>
		</media:content>
	</item>
		<item>
		<title>Sicurezza &#8211; Honeypot SSH</title>
		<link>https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/</link>
					<comments>https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 03 Sep 2014 12:43:20 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[authbind]]></category>
		<category><![CDATA[bruteforce]]></category>
		<category><![CDATA[debian]]></category>
		<category><![CDATA[firewall]]></category>
		<category><![CDATA[framework]]></category>
		<category><![CDATA[honeyd]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[kippo]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[sudoers]]></category>
		<category><![CDATA[ubuntu]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=476</guid>

					<description><![CDATA[Un Honeypot SSH con Kippo Chiunque abbia un minimo di esperienza nel mettere a punto server rivolti verso Internet conosce bene la quantità di scansioni e di attacchi automatizzati che si possono ricevere in brevissimo tempo, a volte nel momento stesso in cui ci si collega in Rete. Molti scanner non sono sofisticati e si &#8230; <a href="https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png"><img data-attachment-id="477" data-permalink="https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/kippo-300x86/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png" data-orig-size="300,86" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Kippo honeypot" data-image-description="&lt;p&gt;Kippo SSH Honeypot &lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=300" class="alignleft size-full wp-image-477" src="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=600" alt="Kippo honeypot" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png 300w, https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=150 150w" sizes="(max-width: 300px) 100vw, 300px"   /></a>Un Honeypot SSH con Kippo</strong></h3>
<p>Chiunque abbia un minimo di esperienza nel mettere a punto server rivolti verso Internet conosce bene la quantità di <strong>scansioni e di attacchi automatizzati che si possono ricevere</strong> in brevissimo tempo, a volte nel momento stesso in cui ci si collega in Rete.</p>
<p>Molti scanner non sono sofisticati e si limitano a cercare porte<strong> ssh</strong> aperte per tentare un <strong>bruteforce</strong> e, in caso di successo, passare il controllo ad un attaccante umano (un cracker non un hacker).</p>
<p>Come descritto in un precedente articolo &#8220;<a title="Sicurezza con il PortKnocking" href="http://tuttiperlinux.com/2014/08/30/sicurezza-con-il-portknocking/"><strong>Sicurezza con il PortKnocking</strong></a>&#8221; , i passi da fare per mettersi al sicuro non sono mai abbastanza ed inparticolare alcuni servizi vanno completamente blindati anche solo per evitare enormi moli di log del firewall, solo per i tentativi di login al servizio SSH; proprio per questi motivi un ottimo esercizio e&#8217; quello di creare un honeypot partendo da quest&#8217;ultimo servizio.</p>
<p>In questo contesto si colloca <a href="http://code.google.com/p/kippo">Kippo</a>: un <strong>honeypot</strong> che simula un <strong>server ssh vulnerabile</strong> il cui obiettivo è quello di impegnare un attaccante e registrarne i movimenti. E&#8217; un tool open source scritto in Python progettato quindi per registrare attacchi di tipo bruteforce e, soprattutto, l&#8217;intera interazione shell effettuata dall&#8217; attaccante. In pratica quando un utente malintenzionato cercherà di entrare nel vostro sistema si troverà davanti un finto sistema che registrerà tutte le sue attività.</p>
<p>Kippo nel tempo si è guadagnato una certa popolarità dovuta alla sua semplicità d’uso, portabilità e al fatto che permette di <strong>riprodurre i log degli attacchi registrati</strong>.</p>
<h2>Installazione</h2>
<p>Kippo è programmato in <a href="http://www.html.it/guide/guida-python/" target="_blank">Python</a> e si basa sul framework Twisted, è necessario quindi un interprete python almeno alla versione 2.5.</p>
<p>I requisiti sono i seguenti:</p>
<ul>
<li>Python 2.5+</li>
<li>Twisted 8.0+</li>
<li>PyCrypto</li>
<li>Zope Interface</li>
</ul>
<p>come prima cosa bisogna cambiare la porta del server SSH per fare questo basta aprire e modificare il file sshd_config:</p>
<h5># vim /etc/ssh/sshd_config</h5>
<p>e sostituire la porta 22 con un’altra a vostra scelta,</p>
<p>Dopo aver modificato il parametro Port 22 con un altro (es. 2443) riavviare il servizio con il commando:</p>
<h5><strong> </strong># /etc/init.d/ssh restart</h5>
<p>Una volta sistemato questo piccolo dettaglio, bisogna installare tutti i pacchetti necessari per il corretto funzionamento di Kippo:</p>
<p>Prima di mettere in esecuzione l&#8217; honeypot occorre configurarlo agendo sui parametri nel file <code>kippo.cfg</code>.</p>
<p>Le principali opzioni sono le seguenti:</p>
<ul>
<li><strong><code>ssh_addr</code></strong>: l’indirizzo dell’interfaccia su cui vogliamo mettere kippo in ascolto (di default su tutte)</li>
<li><strong><code>ssh_port</code></strong>: il numero della porta</li>
<li><strong><code>password</code></strong>: la password per collegarsi all&#8217; honeypot, di default è <code>123456</code> che statisticamente è la password più comune che si può trovare. Se impostiamo una password <em>difficile</em> rischiamo di far fallire un attacco brute force! e ci perdiamo il bello del divertimento.</li>
<li><strong><code>[database_mysql]</code></strong>: parametri per loggare tutta l’attività di kippo su un db mysql. Di default questa opzione non è attiva.</li>
</ul>
<p>Su Linux per motivi di sicurezza kippo <strong>non</strong> può essere eseguita <strong>come</strong> <strong>root</strong> e quindi non può mettersi direttamente in ascolto sulle porte basse del sistema (&lt; 1024) tra cui anche quella di default del server ssh (la porta 22).</p>
<p>Per reindirizzare la porta 22 sulla porta in cui abbiamo messo in ascolto la honeypot dobbiamo impostare un reindirizzamento con il firewall di sistema. L’impostazione corretta dipende dal firewall che state usando sul vostro server e dalla tipologia della rete.</p>
<p>Ad esempio con iptables:</p>
<pre>iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 22 -j REDIRECT --to-port 2443</pre>
<p>oppure usando l&#8217;ottimo tool <strong>rinetd</strong>, come spiegato enll&#8217;articolo &#8220;<strong><a title="Catturare il traffico di rete" href="http://tuttiperlinux.com/2014/08/06/catturare-il-traffico-di-rete/">Catturare il traffico di rete</a></strong>&#8220;.</p>
<h5>Installiamo i pacchetti</h5>
<pre># apt-get install python-dev openssl python-openssl python-pyasn1 python-twisted</pre>
<p>Visto che la porta 22 (che kippo dovrà monitorare) può essere utilizzata solo dall&#8217; utente root e per ragioni di sicurezza non è consigliato usare kippo come utente root bisogna installare un altra piccola applicazione, <strong>Authbind</strong>, che ci permetterà di eseguire kippo sulla porta 22:</p>
<h5><strong># apt-get install authbind</strong></h5>
<p>Ora creiamo un altro utente (non-root) che useremmo per eseguire kippo (non è vietato eseguire kippo come root ma per ragioni di sicurezza è consigliato usare un utente apposito):</p>
<h5># adduser kippo</h5>
<p>e aggiungiamolo alla lista dei sudoers:</p>
<p><strong> # vim /etc/sudoers</strong></p>
<p>aggiungendo la seguente stringa nel file:</p>
<h5>kippo ALL=(ALL:ALL) ALL</h5>
<p>(sotto l’utente root)</p>
<p><strong> </strong>Non ci resta che dare all&#8217; utente kippo i privilegi per usare la porta 22:</p>
<h5># touch /etc/authbind/byport/22<br />
# chown kippo:kippo /etc/authbind/byport/22<br />
# chmod 777 /etc/authbind/byport/22</h5>
<p>Ora non ci resta che cambiare utente ed entrare nel sistema con l’utente kippo, una volta cambiato utente siamo pronti a scaricare kippo (verificare sul sito del progetto per nuove versioni):</p>
<h5># wget <a href="https://kippo.googlecode.com/files/kippo-0.8.tar.gz" rel="nofollow">https://kippo.googlecode.com/files/kippo-0.8.tar.gz</a> /home/&lt;utente xxx&gt;/Downloads/</h5>
<p>estraiamo i file:</p>
<h5># tar -zxvf kippo-0.8.tar.gz -C /opt/</h5>
<p>ora ci spostiamo nella cartella del programma e modifichiamo il file kippo.cfg inserendo la porta 22 come target (di default è impostata la 2222) con la porta da voi prescelta, tipo la 2443.</p>
<h5><strong># vim kippo.cfg</strong></h5>
<p>ed in fine modifichiamo il file start.sh:</p>
<h5><strong># vim start.sh</strong></h5>
<p>sostituendo la stringa:</p>
<h5><strong>twistd -y kippo.tac -l log/kippo.log &#8211;pidfile kippo.pid</strong></h5>
<p>con:</p>
<h5><strong>authbind &#8211;deep twistd -y kippo.tac -l log/kippo.log &#8211;pidfile kippo.pid</strong></h5>
<p>ora non ci resta che eseguire il programma con:</p>
<h5><strong># ./start.sh</strong></h5>
<p>&#8230;&#8230; e qualsiasi tentativo di connettersi alla porta 22 del sistema sarà registrato da Kippo e file di log verranno archiviati nella cartella corrispondente. Kippo rimane in esecuzione in background e aspetta che qualche attaccante si faccia vivo.</p>
<p>Quando finalmente riusciremo a <strong>registrare un attacco</strong> (e solitamente è questione di solo poche ore!) l’honeypot si occuperà di registrare ogni movimento.</p>
<p>Nella cartella <code><strong>log</strong>/</code> verranno salvati i log interattivi delle sessioni registrate e in quella <code><strong>dl</strong>/</code> verranno salvati i file e gli eseguibili che gli ignari attaccanti tenteranno di scaricare sul server (di solito rootkit, malware generici, etc)</p>
<p>Il divertimento, una volta collezionati un po di log interattivi, è quello di riprodurli con il <code>playlog</code> che è una utilità che permette di <strong>riprodurre i log come se fossero un video</strong>.</p>
<p>Il programma si trova nella cartella <code>utils/</code>, per eseguirlo (da linea di comando):</p>
<pre>python playlog.py /path/to/xxx.log

</pre>
<h2>Statistiche</h2>
<p>Quando si ha una honeypot funzionante a pieno regime può risultare scomodo controllare periodicamente i log per capire il numero di attacchi ricevuti, la durata e altre informazioni utili.</p>
<p>Per facilitarci le cose possiamo affidarci a un programma come <a href="http://bruteforce.gr/kippo-graph">Kippo Graph</a> che si occupa di generare statistiche dettagliate e farci risparmiare del tempo prezioso.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png" medium="image">
			<media:title type="html">Kippo honeypot</media:title>
		</media:content>
	</item>
		<item>
		<title>Sicurezza con il PortKnocking</title>
		<link>https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/</link>
					<comments>https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sat, 30 Aug 2014 22:33:36 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[firewall]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[ip]]></category>
		<category><![CDATA[iptables]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[port knocking]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[stealth]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=461</guid>

					<description><![CDATA[Mi e&#8217; capitato spesso di dover configurare firewall per proteggere i Server di mia competenza e molte volte capita l&#8217;esigenza di dover tenere aperto un accesso dall&#8217;esterno, per poter operare in qualunque momento o per qualunque motivo. Ovviamente questo ci potrebbe esporre facilmente alla possibilita&#8217; di venire attaccati; che cosa fare in questi casi ??? &#8230; <a href="https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png"><img loading="lazy" data-attachment-id="462" data-permalink="https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/portknocking/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png" data-orig-size="320,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="portknocking" data-image-description="&lt;p&gt;Port-Knocking&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=320" class="alignleft size-medium wp-image-462" src="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300&#038;h=225" alt="portknocking" width="300" height="225" srcset="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300&amp;h=225 300w, https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=150&amp;h=113 150w, https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png 320w" sizes="(max-width: 300px) 100vw, 300px" /></a>Mi e&#8217; capitato spesso di dover configurare firewall per proteggere i Server di mia competenza e molte volte capita l&#8217;esigenza di dover tenere aperto un accesso dall&#8217;esterno, per poter operare in qualunque momento o per qualunque motivo. Ovviamente questo ci potrebbe esporre facilmente alla possibilita&#8217; di venire attaccati; che cosa fare in questi casi ??? Beh! le possibili soluzioni sono davvero tante, tante quanto la fantasia di chi le studia; in questo articolo quindi descrivero&#8217; semplicemente un mio modo personale di arginare tale possibile pericolo.</p>
<p><strong>* Il primo</strong> suggerimento e&#8217; quello di spostare il servizio SSH dalla porta 22 ad una di vostra preferenza, stando ben attenti a non usare possibili porte utilizzabili da altri servizi web.</p>
<p><strong>* Il secondo</strong> suggerimento e&#8217; quello di creare un servizio di <a href="http://it.wikipedia.org/wiki/Honeypot">Honeypot</a> (tipo <em>honeyd a bassa interazione, oppure come honeynet ad alta interazione</em>) , da tenere in ascolto sulla porta standard (la 22) dell&#8217;SSH, cosi&#8217; che i male intenzionati trovino la porta attiva e nel tentativo di attaccarvi perdano tempo e si ritrovino successivamente all&#8217;interno di servizi fasulli.</p>
<p><strong>* Il terzo</strong> suggerimento e&#8217; quello di utilizzare la tecnica del port-knocking per poter gestire a proprio piacimento ogni accesso in SSH attivando e disattivando tramite una sequenza di caratteri che solo voi conoscete e che potrete cambiare a piacimento.</p>
<h3><strong>PORTKNOCKING</strong></h3>
<p>Iniziamo col dire che cosa e&#8217; questa tecnica: le tecniche di <strong>Port knocking</strong> permettono di aumentare considerevolmente la sicurezza di un server che deve garantire alcuni servizi non permanenti attraverso IP pubblici. Se s&#8217;inviano dei pacchetti a delle porte prestabilite sulle quali il demone è in ascolto e nel caso la sequenza sia corretta, questi attiverà un comando che potrà eseguire delle regole di <strong>iptables </strong>che apriranno le porte necessarie alla connessione. Il vantaggio è notevole in quanto il server potrebbe rimanere sempre in <em>stealth</em> <em>mode</em> e aprire le porte per un determinato servizio solo in caso di necessità.</p>
<p>Innanzitutto per poter utilizzare il portknocking e&#8217; necessario che il firewall sia attivo e funzionante, ora posiamo installare il pacchetto software</p>
<p>sudo apt-get install knockd</p>
<h3 id="Configurazione_knockd">Configurazione knockd</h3>
<ol type="0">
<li>
<p class="line862">Per fare in modo che il demone parta all&#8217;avvio del computer modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/default/knockd</tt> in questo modo: <span id="line-14" class="anchor"></span><span id="line-15" class="anchor"></span><span id="line-16" class="anchor"></span></p>
<pre><span id="line-1" class="anchor"></span>START_KNOCKD=1</pre>
<p>&nbsp;</li>
<li class="gap">
<p class="line862">Sempre nel medesimo file <tt>/etc/default/knockd</tt> modificare con un editor di testo a piacimento, e con i privilegi di amministrazione indicando su quale interfaccia il demone dovrà rimanere in ascolto: <span id="line-19" class="anchor"></span><span id="line-20" class="anchor"></span><span id="line-21" class="anchor"></span></p>
<pre><span id="line-1-1" class="anchor"></span>KNOCKD_OPTS="-i eth0"</pre>
<p>&nbsp;</li>
</ol>
<h3 id="Configurazione_knockd.conf_per_l.27apertura_di_una_sola_porta">Configurazione knockd.conf per l&#8217;apertura di una sola porta</h3>
<p class="line862">Modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/knockd.conf</tt> impostandolo come segue: <span id="line-25" class="anchor"></span><span id="line-26" class="anchor"></span></p>
<pre><span id="line-1-2" class="anchor"></span>[options]
<span id="line-2" class="anchor"></span>        logfile = /var/log/knockd.log
<span id="line-3" class="anchor"></span>
<span id="line-4" class="anchor"></span>[openSSH]
<span id="line-5" class="anchor"></span>        sequence    = 7000,8000,9000
<span id="line-6" class="anchor"></span>        # Questa è la sequenza delle porte sulle quali knockd rimarrà in ascolto. Di default il protocollo è TCP.
<span id="line-7" class="anchor"></span>        # Quali e quante porte usare è discrezionale.
<span id="line-8" class="anchor"></span>
<span id="line-9" class="anchor"></span>        # sequence   = 7000:udp,8000:tcp,9000:udp
<span id="line-10" class="anchor"></span>        # Esempio con sequenza con porte miste udp/tcp
<span id="line-11" class="anchor"></span>
<span id="line-12" class="anchor"></span>        seq_timeout = 30
<span id="line-13" class="anchor"></span>        #Tempo di attesa massimo per completare la sequenza.
<span id="line-14" class="anchor"></span>
<span id="line-15" class="anchor"></span>        command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
<span id="line-16" class="anchor"></span>        # Quando la sequenza verrà accettata verrà inserita una regola che aprirà la porta SSH standard.
<span id="line-17" class="anchor"></span>
<span id="line-18" class="anchor"></span>        tcpflags    = syn
<span id="line-19" class="anchor"></span>        # Ulteriore filtro, sul tipo di flag del pacchetto inviato alla sequenza di porte.
<span id="line-20" class="anchor"></span>        
<span id="line-21" class="anchor"></span>[closeSSH]
<span id="line-22" class="anchor"></span>        sequence    = 9000,8000,7000
<span id="line-23" class="anchor"></span>        # Questa è un'altra sequenza di porte sulle quali knockd rimarrà in ascolto.
<span id="line-24" class="anchor"></span>
<span id="line-25" class="anchor"></span>        seq_timeout = 30
<span id="line-26" class="anchor"></span>
<span id="line-27" class="anchor"></span>        command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
<span id="line-28" class="anchor"></span>        # Quando la sequenza verrà accettata verrà inserita una regola che cancellerà quella creata in precedenza.
<span id="line-29" class="anchor"></span>
<span id="line-30" class="anchor"></span>        tcpflags    = syn
<span id="line-31" class="anchor"></span>        # Ulteriore filtro, sul tipo di flag del pacchetto inviato alla sequenza di porte.</pre>
<p class="line874">La variabile «%IP%» passa alla regola di iptables l&#8217;indirizzo che ha effettuato la richiesta di connessione, in questo caso verrà permessa l&#8217;apertura della porta SSH discriminando solo l&#8217;IP validato. <span id="line-61" class="anchor"></span><span id="line-62" class="anchor"></span></p>
<h3 id="Configurazione_per_l.27apertura_di_una_sola_porta.2C_per_soli_esperti">Configurazione per l&#8217;apertura di una sola porta, per soli esperti</h3>
<p class="line862">Un&#8217;altra possibilità per usare il demone knockd, e&#8217; utilizzabile <strong>solo se il firewall sul server è configurato per accettare le connessioni &#8220;established&#8221; e &#8220;related&#8221;</strong> alla porta che si vuole aprire (es ssh, 22) è di chiudersi subito dietro la porta appena aperta, per evitare che, restando &#8220;aperta&#8221;, qualche malintenzionato tenti un brute-force al servizio, lanciando uno script anzichè impostando delle regole sul firewall. <span id="line-64" class="anchor"></span><span id="line-65" class="anchor"></span></p>
<p class="line862">Per questo scopo il file <tt>/etc/knockd.conf </tt>può ad esempio essere modificato, con un editor di testo a piacimento, e con i privilegi di amministrazione, come segue : <span id="line-66" class="anchor"></span><span id="line-67" class="anchor"></span></p>
<pre><span id="line-1-3" class="anchor"></span>[options]
<span id="line-2-1" class="anchor"></span>        logfile = /var/log/knockd.log
<span id="line-3-1" class="anchor"></span>
<span id="line-4-1" class="anchor"></span>[openSSH]
<span id="line-5-1" class="anchor"></span>        sequence    = 7000,8000,9000
<span id="line-6-1" class="anchor"></span>        seq_timeout = 30
<span id="line-7-1" class="anchor"></span>        start_command     = /etc/init.d/ssh start
<span id="line-8-1" class="anchor"></span>        tcpflags    = syn
<span id="line-9-1" class="anchor"></span>
<span id="line-10-1" class="anchor"></span>        cmd_timeout = 5
<span id="line-11-1" class="anchor"></span>        stop_command     = /etc/init.d/ssh stop
<span id="line-12-1" class="anchor"></span>        # Dopo cmd_timeout secondi, viene eseguito il comando stop_command</pre>
<p class="line862">Ricordiamo ancora che <strong>è indispensabile</strong> che il firewall sul server accetti le connessioni &#8220;related&#8221; ed &#8220;established&#8221; altrimenti la sezione &#8220;stop_command&#8221;, appena sarà eseguita, vi chiuderà la connessione SSH senza quindi avere possibilità di connettervi al server! <span id="line-82" class="anchor"></span><span id="line-83" class="anchor"></span></p>
<pre><span id="line-1-4" class="anchor">tuttiperlinux</span>@server:~# iptables -nL | grep ":22"
<span id="line-2-2" class="anchor"></span>
<span id="line-3-2" class="anchor"></span>ACCEPT     tcp  --  0.0.0.0/0    0.0.0.0/0           tcp dpt:22
<span id="line-4-2" class="anchor"></span>ACCEPT     tcp  --  0.0.0.0/0    0.0.0.0/0           tcp spt:22 dpts:513:65535 state RELATED,ESTABLISHED
<span id="line-5-2" class="anchor"></span>ACCEPT     tcp  --  0.0.0.0/0    0.0.0.0/0           tcp spts:1024:65535 dpt:22 flags:0x17/0x02 state RELATED,ESTABLISHED
<span id="line-6-2" class="anchor"></span>ACCEPT     udp  --  0.0.0.0/0    0.0.0.0/0           udp dpt:22 state ESTABLISHE
<span id="line-7-2" class="anchor"></span></pre>
<h3 id="Configurazione_knockd.conf_per_l.27apertura_di_pi.2BAPk_porte">Configurazione knockd.conf per l&#8217;apertura di più porte</h3>
<p class="line874">Nell&#8217;esempio sopra esposto si è visto come aprire una sola porta. Se l&#8217;esigenza fosse però quella di aprirne di più procedere creando più sessioni «[openServizio]» e «[closeServizio]». Questo sistema risulta però scomodo per ovvi motivi, per ottenere lo stesso risultato è consigliato usare degli script. <span id="line-94" class="anchor"></span><span id="line-95" class="anchor"></span></p>
<p class="line862">Modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/knockd.conf</tt> impostandolo come segue: <span id="line-96" class="anchor"></span><span id="line-97" class="anchor"></span></p>
<pre><span id="line-1-5" class="anchor"></span>[options]
<span id="line-2-3" class="anchor"></span>        logfile = /var/log/knockd.log
<span id="line-3-3" class="anchor"></span>
<span id="line-4-3" class="anchor"></span>[open]
<span id="line-5-3" class="anchor"></span>        sequence    = 7000,8000,9000
<span id="line-6-3" class="anchor"></span>        seq_timeout = 30
<span id="line-7-3" class="anchor"></span>        tcpflags    = syn
<span id="line-8-2" class="anchor"></span>        command     = sh /etc/open_ports %IP%
<span id="line-9-2" class="anchor"></span>
<span id="line-10-2" class="anchor"></span>
<span id="line-11-2" class="anchor"></span>[close]
<span id="line-12-2" class="anchor"></span>        sequence    = 9000,8000,7000
<span id="line-13-1" class="anchor"></span>        seq_timeout = 30
<span id="line-14-1" class="anchor"></span>        tcpflags    = syn
<span id="line-15-1" class="anchor"></span>        command     = sh /etc/close_ports %IP%</pre>
<p class="line874">In questo caso invece di eseguire direttamente iptables si richiamano due script passando il parametro «%IP%» alla variabile speciale «$1». <span id="line-116" class="anchor"></span><span id="line-117" class="anchor"></span></p>
<h3 id="Esempio_di_script_open_ports">Esempio di script open_ports</h3>
<p class="line862">Modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/open_ports</tt> impostandolo come segue: <span id="line-119" class="anchor"></span><span id="line-120" class="anchor"></span></p>
<pre><span id="line-1-6" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 22 -j ACCEPT
<span id="line-2-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 21 -j ACCEPT
<span id="line-3-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 631 -j ACCEPT
<span id="line-4-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 5125 -j ACCEPT
<span id="line-5-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 5126 -j ACCEPT
<span id="line-6-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 8888 -j ACCEPT
<span id="line-7-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 10000 -j ACCEPT
<span id="line-8-3" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 81 -j ACCEPT</pre>
<h3 id="Esempio_di_script_close_ports">Esempio di script close_ports</h3>
<p class="line862">Modificare con un editor di testo a piacimento,  e con i privilegi di amministrazione il file <tt>/etc/close_ports</tt> impostandolo come segue: <span id="line-134" class="anchor"></span><span id="line-135" class="anchor"></span></p>
<pre><span id="line-1-7" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 22 -j ACCEPT
<span id="line-2-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 21 -j ACCEPT
<span id="line-3-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 631 -j ACCEPT
<span id="line-4-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 5125 -j ACCEPT
<span id="line-5-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 5126 -j ACCEPT
<span id="line-6-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 8888 -j ACCEPT
<span id="line-7-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 10000 -j ACCEPT
<span id="line-8-4" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 81 -j ACCEPT

</pre>
<h3 id="Connessione">Esempio di una connessione</h3>
<p class="line874">Per effettuare la connessione digitare il seguente comando all&#8217;interno di una finestra di terminale: <span id="line-168" class="anchor"></span><span id="line-169" class="anchor"></span></p>
<pre><span id="line-1-9" class="anchor"></span>./knock -v &lt;ip_host&gt; port1 port2 port3 port...</pre>
<p>Ora non resta altro che fare pratica e pratica ma sono sicuro che il portknocking vi dara&#8217; tanta soddisfazione.</p>
<p>Leggete anche l&#8217;articolo sulla sicurezza inerente <a title="Metasploit Framework" href="http://tuttiperlinux.com/2014/08/29/metasploit-framework/">Metasploit Framework</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300" medium="image">
			<media:title type="html">portknocking</media:title>
		</media:content>
	</item>
	</channel>
</rss>
