<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>ssh &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/ssh/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Mon, 19 Jan 2015 07:59:14 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>ssh &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Ansible per l’automazione IT ed il Configuration Management</title>
		<link>https://tuttiperlinux.blog/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/</link>
					<comments>https://tuttiperlinux.blog/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Tue, 13 Jan 2015 12:49:52 +0000</pubDate>
				<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[WebServer]]></category>
		<category><![CDATA[aws]]></category>
		<category><![CDATA[cfengine]]></category>
		<category><![CDATA[chef]]></category>
		<category><![CDATA[configuration management]]></category>
		<category><![CDATA[devops]]></category>
		<category><![CDATA[ec2]]></category>
		<category><![CDATA[google engine]]></category>
		<category><![CDATA[handlers]]></category>
		<category><![CDATA[linux blog in italiano]]></category>
		<category><![CDATA[modules]]></category>
		<category><![CDATA[open source]]></category>
		<category><![CDATA[playbook]]></category>
		<category><![CDATA[puppet]]></category>
		<category><![CDATA[ruby]]></category>
		<category><![CDATA[salstack]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[tasks]]></category>
		<category><![CDATA[yaml]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=920</guid>

					<description><![CDATA[Ansible e’ un tool di Configuration Management ed IT Automation che sta riscuotendo un notevole successo tra gli addetti ai lavori in virtu’ della sua immediatezza, della sua semplicita’ di utilizzo e del superamento delle limitazioni della tipica configurazione basata su &#8220;server &#38; agent&#8221;. Che cos’e’ Ansible Ansible quindi e’ un tool di Configuration Management ed &#8230; <a href="https://tuttiperlinux.blog/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_921" style="width: 310px" class="wp-caption alignleft"><img loading="lazy" aria-describedby="caption-attachment-921" data-attachment-id="921" data-permalink="https://tuttiperlinux.blog/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/ansible_diagram/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg" data-orig-size="788,436" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="ANSIBLE_DIAGRAM" data-image-description="&lt;p&gt;Ansible e l’automazione IT&lt;/p&gt;
" data-image-caption="&lt;p&gt;Ansible e l’automazione IT&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=600" class="size-medium wp-image-921" src="https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=300&#038;h=166" alt="Ansible e l’automazione IT" width="300" height="166" srcset="https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=300&amp;h=166 300w, https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=600&amp;h=332 600w, https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=150&amp;h=83 150w" sizes="(max-width: 300px) 100vw, 300px" /><p id="caption-attachment-921" class="wp-caption-text">Ansible e l’automazione IT</p></div>
<p><strong>Ansible</strong> e’ un tool di <strong>Configuration Management</strong> ed <strong>IT Automation</strong> che sta riscuotendo un notevole successo tra gli addetti ai lavori in virtu’ della sua immediatezza, della sua semplicita’ di utilizzo e del superamento delle limitazioni della tipica configurazione basata su &#8220;server &amp; agent&#8221;.</p>
<h4><strong>Che cos’e’ Ansible</strong></h4>
<p><a href="http://www.ansible.com/home">Ansible</a> quindi e’ un tool di Configuration Management ed IT Automation che rientra nella sfera degli strumenti tipici del metodo <a href="https://it.wikipedia.org/wiki/Devops"><strong>DevOps</strong></a>.</p>
<p>DevOps e&#8217; un movimento nato per abbattere il muro di gomma che nel corso degli anni si e’ innalzato tra Developer e Sysadmin. Per usare un’analogia, DevOps e’ una cultura che ha lo scopo di creare una pipeline (in pratica un ponte di comunicazione) tra sviluppatori ed amministratori di sistema.</p>
<p><strong>L’obiettivo</strong> e’ uno solo: aumentare costantemente la soddisfazione del cliente producendo ed erogando software allo stato dell’arte con continue release correttive.</p>
<p>Per raggiungere un obiettivo cosi’ ambizioso e’ importante poter contare non solo sulle persone ma anche sugli strumenti. Cosi’ sono nati tool agili ed intuitivi che hanno lo scopo di automatizzare lo sviluppo, il testing e la configurazione di server ed applicazioni. Questa famiglia di tool per il Configuration Management comprende gia diversi nomi blasonati come ad esempio <strong>Puppet</strong>, <strong>Chef</strong>, <strong>Saltstack</strong> e <strong>CFEngine</strong>.</p>
<h4>Configuration Management in breve</h4>
<p>Il Configuration Management e’ un processo utilizzato per definire la configurazione delle applicazioni web e dei server in modo consistente, possibilmente sotto controllo di versione. Con il Configuration Management e’ possibile definire a priori come dovra’ essere configurato il server X o l’applicazione Y. Il tutto in linguaggio sorgente o sotto forma di meta-linguaggio.</p>
<p>I tool di <strong>Configuration Management</strong> leggono le configurazioni a partire da un file sorgente ed applicano le stesse su uno o piu’ server, in modo <strong>automatico</strong> e prevedibile.</p>
<p>Esempio:</p>
<pre>inizio configurazione
1 assicurati che apache2 sia installato
2 assicurati che php5 sia installato
3 assicurati che mysql sia installato
fine configurazione</pre>
<p>Un tool di Configuration Management puo’ leggere queste istruzioni ed applicarle su uno o piu’ server. In questo modo l’operatore puo’ replicare la stessa configurazione su decine di server oppure ricostruire la stessa in pochi secondi quando uno o piu’ server vengono messi fuori uso.</p>
<h4>Ansible, un po’ di storia</h4>
<p>Lanciato nel 2012, <strong>Ansible </strong> nasce da un’idea di <a title="Michael De Haan Ansible" href="http://www.linkedin.com/in/michaeldehaan" target="_blank">Michael de Haan</a>, creatore tra l’altro di <a title="Cobbler" href="http://www.cobblerd.org/" target="_blank">Cobbler</a>. De Haan un bel giorno sente la necessita’ di scrivere un software che potesse <span style="color:#000000;"><a style="color:#000000;" title="The origins of Ansible" href="http://blog.ansibleworks.com/2013/12/08/the-origins-of-ansible/" target="_blank">semplificare all’ennesima potenza</a></span> le attivita’ di Configuration Management ed Automazione IT.</p>
<p>Fino a quel momento il panorama del Configuration Management era dominato da <strong>Puppet</strong> e <strong>Chef</strong> (che comunque mantengono e sicuramente manterranno  anche in futuro quote di mercato molto vaste). Ma seppure ottimi, sia Puppet che Chef hanno alcuni punti deboli, che fanno storcere il naso ai Sysadmin piu’ esigenti:</p>
<p>* Puppet e Chef funzionano principalmente in modalita’ server – agent</p>
<p>* Chef richiede anche la conoscenza del linguaggio Ruby</p>
<p>Anche se non si tratta di limitazioni insormontabili ci sono comunque alcuni svantaggi in questo tipo di approccio.</p>
<p>Prima di tutto non sempre e’ possibile installare un agent sul server di destinazione, poiche&#8217; un agent e’ comunque un piccolo software che rimane in esecuzione permanente su uno o piu’ server ed ha lo scopo di attendere comandi e configurazioni impartite dal server master.</p>
<p>Sia Chef che Puppet utilizzano questo approccio che spesso non e’ possibile mettere in pratica.</p>
<p>Pensiamo ad esempio ad ambienti server che per ragioni di conformita’ o sicurezza non possono ospitare agenti o software estranei oppure a quei server con un discreto numero di anni sulle spalle, dove l’installazione di una versione aggiornata di Ruby (richiesta, ad esempio, da Puppet) potrebbe causare effetti imprevedibili.</p>
<h4>I vantaggi di Ansible</h4>
<p>Perche’ dunque adottare Ansibile ?<br />
Se sei un Sysadmin o un Developer potrai trarre sicuramente grande beneficio dall’uso di questo tool: con Ansible non e’ mai stato cosi’ semplice definire lo stato di un server e delle tue applicazioni web.<br />
Con Ansible quindi il risparmio di tempo e di codice e’ notevole rispetto a Puppet o Chef.</p>
<h4>Curva di apprendimento bassa</h4>
<p>Dalla lettura della documentazione alla scrittura dei primi Playbooks il passo sara&#8217; breve, ed in pochi minuti vi sara&#8217; possibile iniziare a lavorare con Ansible senza dover penare con configurazioni di server Master e agenti vari.</p>
<h4>Non sono richieste capacita’ di coding</h4>
<p>Puppet e Chef nascono entrambi da un team di sviluppatori follemente innamorati di Ruby. Per la definizione dello stato dei server e delle configurazioni Puppet adotta un linguaggio simile al codice Ruby mentre per definire lo stato di un server con Chef e’ addirittura essenziale conoscere il linguaggio, invece <strong>Ansible supera</strong> completamente questa limitazione.</p>
<p>In Ansible ad esempio e’ possibile definire che il server X dovra’ contenere Apache con due righe:<br />
es:</p>
<pre>Install Httpd
yum: name=httpd state=latest</pre>
<p>Come si puo&#8217; notare, a differenza di Puppet, Chef e Saltstack, Ansible non ha bisogno di nessun agente per applicare le configurazioni su un server. Ansible utilizza di default il trasporto <strong>SSH</strong>: questo elimina la necessita’ di installare software estraneo sui nodi.</p>
<h4>Modulare e Open Source</h4>
<p>Ansible e’ composto da numerosi moduli. Per analogia i <a href="http://docs.ansible.com/modules.html" target="_blank">moduli di Ansible </a>hanno la stessa funzione delle risorse in Puppet. Ogni modulo svolge delle funzioni ben precise e gestisce un singolo aspetto di ogni sistema. Questa architettura consente di espandere Ansible praticamente all’infinito, senza contare che i moduli possono essere scritti in qualsiasi linguaggio di programmazione. Inoltre Ansible e’ Open Source e la comunita’ continua a crescere rapidamente.</p>
<h4>Ansible, i concetti chiave</h4>
<p>Prima di terminare con questa introduzione su Ansible vediamo quali sono i concetti chiave ed i componenti che ruotano attorno a questo software.</p>
<h4>Ansible: l’inventario</h4>
<p>L’inventario e’ una lista di server sui quali Ansible applica, a comando, le configurazioni di sistema e le istruzioni di automazione. L’inventario di solito e’ contenuto all’interno del file <strong>/etc/ansible/hosts</strong> anche se e’ possibile specificare una posizione a piacere.</p>
<p>All’interno dell’inventario l’operatore puo’ specificare la lista dei server “bersaglio”. E&#8217; chiaramente obbligatorio che ogni server abbia una corrispondenza DNS anche se e’ possibile specificare ogni server con il proprio indirizzo IP . Un esempio di inventario:</p>
<pre>[webservers]
webserver1.example.com
webserver2.example.com

[dbservers]
dbserver1.example.com
dbserver2.example.com</pre>
<h4>Ansible ed i Tasks</h4>
<p>In Ansible i Tasks sono dei “compiti” ovvero una serie di istruzioni che Ansible esegue in ordine di apparizione. Ogni istruzione contiene la definizione e/o la configurazione che dovra’ essere applicata ad ogni sistema.</p>
<h4>Ansible e gli Handlers</h4>
<p>Gli Handlers in Ansible sono delle istruzioni che vengono eseguite a seguito di una determinata azione. Ad esempio dopo aver installato httpd un operatore puo’ voler avviare Apache automaticamente. Un esempio di Handler che avvia Apache su CentOS:</p>
<pre>name: start httpd
service  : name=httpd state=started enabled=yes</pre>
<p>Gli Handlers si basano sul modulo <a title="Ansible Service Module" href="http://docs.ansible.com/service_module.html" target="_blank">service</a> di Ansible (questo modulo viene utilizzato per gestire i servizi di sistema).</p>
<h4>Ansible ed i Playbook</h4>
<p>In Ansible i <strong>Playbook</strong> sono delle collezioni di Tasks. Ogni Playbook puo’ contenere un determinato numero di <strong>Tasks</strong> e di <strong>Handlers</strong>. I Playbook devono essere definiti in linguaggio <strong>YAML</strong>.</p>
<p><strong><br />
Ansible ed i Moduli</strong></p>
<p>Ansible e’ composto da numerosi moduli. Esistono moduli per gestire i servizi di Cloud Computing (EC2 su AWS), Rackspace e Google Compute Engine, esistono moduli per installare pacchetti software su server Linux con apt e yum, moduli per gestire file di configurazione e database e molto altro ancora.</p>
<p>Per una lista completa dei moduli puoi consultare la documentazione ufficiale: <a title="Ansible Modules" href="http://docs.ansible.com/modules.html" target="_blank">Ansible Modules</a>.</p>
<p>#AnsibleConfigurationManagement</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2015/01/13/ansible-per-lautomazione-it-ed-il-configuration-management/feed/</wfw:commentRss>
			<slash:comments>7</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2015/01/ansible_diagram.jpg?w=300" medium="image">
			<media:title type="html">Ansible e l’automazione IT</media:title>
		</media:content>
	</item>
		<item>
		<title>Condividere e&#8217; bello con Screen</title>
		<link>https://tuttiperlinux.blog/2014/10/01/condividere-e-bello-con-screen/</link>
					<comments>https://tuttiperlinux.blog/2014/10/01/condividere-e-bello-con-screen/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 01 Oct 2014 08:33:44 +0000</pubDate>
				<category><![CDATA[Tips & Tricks]]></category>
		<category><![CDATA[condivisione]]></category>
		<category><![CDATA[gui]]></category>
		<category><![CDATA[istanza]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[putty]]></category>
		<category><![CDATA[remote session]]></category>
		<category><![CDATA[screen]]></category>
		<category><![CDATA[split screen]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[terminal]]></category>
		<category><![CDATA[vnc]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=628</guid>

					<description><![CDATA[SCREEN appartiene a quella categoria di applicativi molto potenti ma poco conosciuti, basta però utilizzarlo anche una sola volta per non poterne più fare a meno. Tecnicamente è un multiplexer per terminale, ovvero un applicativo con cui eseguire, all&#8217;interno di una console, molti comandi contemporaneamente, oppure connettersi allo stesso schermo virtuale da più console. Proprio questa &#8230; <a href="https://tuttiperlinux.blog/2014/10/01/condividere-e-bello-con-screen/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png"><img loading="lazy" data-attachment-id="632" data-permalink="https://tuttiperlinux.blog/2014/10/01/condividere-e-bello-con-screen/screen_terminal/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png" data-orig-size="512,512" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="screen_terminal" data-image-description="&lt;p&gt;Screen Terminal Share&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png?w=512" class="alignleft size-medium wp-image-632" src="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png?w=300&#038;h=300" alt="screen_terminal" width="300" height="300" srcset="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png?w=300&amp;h=300 300w, https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png?w=150&amp;h=150 150w, https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png 512w" sizes="(max-width: 300px) 100vw, 300px" /></a><strong>SCREEN </strong>appartiene a quella categoria di applicativi molto potenti ma poco conosciuti, basta però utilizzarlo anche una sola volta per non poterne più fare a meno. Tecnicamente è un multiplexer per terminale, ovvero un applicativo con cui eseguire, all&#8217;interno di una console, molti comandi contemporaneamente, oppure connettersi allo stesso schermo virtuale da più console.</p>
<p>Proprio questa seconda opportunità è quella preferita dagli utenti GNU/Linux, infatti, tramite screen si può lanciare un programma, disconnettersi dal suo output, fare altro e riagganciarsi ad esso in un altro momento senza aver perso nulla!</p>
<p>Ma cerchiamo di spiegarci meglio; sicuramente per lavoro, sia chi usa Linux che chi usa Windows, acra&#8217; dovuto connettersi in remoto su altre macchine e spesso si usano tool quali Putty, diciamo che per varie necessita&#8217; le operazioni di calcolo lanciate sulla macchina su cui operate occupano parecchio tempo e non potete fare log-out per non perdere l&#8217;attivita&#8217; iniziata&#8230;., bene, nel mondo unix e linux esistono due soluzioni a questo problema e si tratta delle utility `nohup` e `screen`. In questo articolo spiegherò come usare  &#8220;<strong>screen</strong>&#8220;.</p>
<p>Iniziamo con l&#8217;installazione :</p>
<pre>sudo apt-get install screen</pre>
<p>Fatto questo, si può avviare screen, semplicemente digitando nel terminale della macchina remota:</p>
<pre>screen</pre>
<p>e si avra&#8217; subito una sessione in cui poter lavorare.<br />
Per inviare comandi direttamente a screen, si usa la combinazione di tasti CTRL-a (abbreviati in seguito con C-a) e poi va digitato il comando.<br />
Ad esempio, per avviare una nuova sessione, basta digitare C-a c, oppure per avere l’elenco dei comandi, C-a ?.<br />
Le combinazioni sicuramente necessarie da sapere sono:</p>
<pre>C-a ? :: visualizza la pagina di aiuto
C-a c :: avvia una nuova sessione
C-a n :: torna alla sessione precedente
C-a p :: va alla sessione successiva
C-a h :: crea un file di log per la sessione
C-a m :: avvia monitoraggio per una sessione
C-a a :: va alla sessione che ha segnalato un evento di monitoraggio
C-a d :: stacca il terminale da screen, lasciando il processo attivo
C-a k :: chiude la sessione corrente di screen</pre>
<p>Ora, cosa succede se mi disconnetto senza chiudere screen? Viene semplicemente lasciata aperta la sessione, ed al nuovo accesso, basterà digitare:</p>
<pre>screen -ls</pre>
<p>per avere l’elenco delle sessioni attualmente attive, es :</p>
<pre>@tuttiperlinux:~$ screen -ls
There is a screen on:
326.pts-2.tuttiperlinux (01.10.2014 09:50:57) (Attached)
1 Socket in /var/run/screen/S-tuttiperlinux.</pre>
<p>e per riconnettersi alla sessione, basterà digitare:</p>
<pre>screen -r 326</pre>
<p>o piu&#8217; semplicemente &#8220;<strong>screen -r</strong>&#8221; se esiste una sola sessione attiva.</p>
<p>Se la vostra necessita&#8217; e&#8217; invece quella di condividere una sessione di lavoro/diagnosi con altri colleghi potrete, ad esempio collegarvi remotamente tutti sullo stesso server , successivamente usare una utenza specifica per la manutenzione del servizio in questione e collegarvi tutti alla stessa sessione, esempio :</p>
<pre>screen -x &lt;user&gt;; #che potra' essere tomcat, come apache ecc...</pre>
<p>condividendone lo stesso terminal e potendo cosi interagire avendo davanti a voi tutto cio&#8217; che succede sulla macchina a prescindere da chi stia impartendo i comandi.</p>
<h3><strong>Caratteristiche principali</strong></h3>
<dl>
<dt><strong>Persistenza</strong></dt>
<dd>Similmente a tool quali <a title="Virtual Network Computing" href="https://it.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a>, &#8220;screen&#8221; permette all&#8217;utente di avviare delle applicazioni da un computer e poi riconnettersi da un altro computer e continuare ad usare la stessa applicazione senza farla ripartire. Questo rende gli spostamenti, come ad esempio tra casa e lavoro, molto più semplici. Screen fornisce una funzionalità <i>terminal-agnostic</i> (ovvero funziona indipendentemente dal terminale utilizzato) perciò gli utenti possono disconnettersi e riconnettersi utilizzando tipi diversi di terminali, permettendo alle applicazioni di continuare senza percepire il cambio del terminale.</dd>
</dl>
<dl>
<dt><strong>Finestre multiple</strong></dt>
<dd>Possono essere create sessioni multiple, ognuna delle quali di solito ospita una singola applicazione. Le finestre sono numerate e l&#8217;utente può utilizzare la tastiera per passare da un&#8217;applicazione all&#8217;altra. Alcune GUI forniscono delle tab o qualche altra opzione simile per fornire questa caratteristica. Ogni finestra ha la sua <i>scroll-back buffer</i>, così è possibile vedere l&#8217;output anche quando la finestra non è attiva in quel momento e questo output può essere salvato anche quando si passa ad un altro computer. Le finestre possono essere ripartite in più screen tramite <a title="Split screen" href="https://it.wikipedia.org/wiki/Split_screen">split screen</a>. Mentre alcune applicazioni di testo hanno già questa funzionalità, Screen permette che ogni finestra sia divisa orizzontalmente in un numero qualsiasi di altre applicazioni.</dd>
</dl>
<dl>
<dt><strong>Condivisione di sessione</strong></dt>
<dd>Screen permette che più computer si connettano alla stessa sessione allo stesso tempo, permettendo così la collaborazione tra più utenti. Lo stesso computer può essere utilizzato per fare connessioni simultanee multiple, fornendo funzionalità alternative per la divisione della schermata, in particolare per i computer con più monitor.</dd>
</dl>
<p>Insomma una gran comodita&#8217;, un tool sicuramente utile da usare in tante diverse situazioni&#8230;.!</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/10/01/condividere-e-bello-con-screen/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/10/screen_terminal.png?w=300" medium="image">
			<media:title type="html">screen_terminal</media:title>
		</media:content>
	</item>
		<item>
		<title>Firewall apriamo un passaggio segreto</title>
		<link>https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/</link>
					<comments>https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 24 Sep 2014 08:58:29 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[fwknop]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[iptables]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[payload]]></category>
		<category><![CDATA[portknoking]]></category>
		<category><![CDATA[replay-attack]]></category>
		<category><![CDATA[spa]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[tcp-ip]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=594</guid>

					<description><![CDATA[Port-knoking &#8211; II Episodio Poco tempo fa abbiamo affrontato il concetto di sicurezza utilizzando la tecnologia del port-knoking . Oggi affronteremo una seconda metodologia legata al port knoking. Facciamo un passo indietro considerando il firewall il miglior sistema di difesa in nostro possesso. Il port-knoking e&#8217; in pratica una tecnica di autorizzazione che agisce sul firewall &#8230; <a href="https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg"><img loading="lazy" data-attachment-id="595" data-permalink="https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/fwknop_spa/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg" data-orig-size="750,367" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="fwknop_spa" data-image-description="&lt;p&gt;Portknoking con Fwknop&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=600" class="alignleft size-medium wp-image-595" src="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=300&#038;h=146" alt="fwknop_spa" width="300" height="146" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=298&amp;h=146 298w, https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=597&amp;h=292 597w, https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=150&amp;h=73 150w" sizes="(max-width: 300px) 100vw, 300px" /></a>Port-knoking &#8211; II Episodio</strong></h3>
<p>Poco tempo fa abbiamo affrontato il concetto di sicurezza utilizzando la tecnologia del <strong>port-knoking </strong>. Oggi affronteremo una seconda metodologia legata al port knoking.</p>
<p>Facciamo un passo indietro considerando il firewall il miglior sistema di difesa in nostro possesso. Il port-knoking e&#8217; in pratica una tecnica di autorizzazione che agisce sul firewall e che puo&#8217; essere realizzato con diverse metodologie; la &#8220;bussata&#8221; dipendera&#8217; dal software di port-knoking utilizzato, ma in tutti i casi si compone di pacchetti TPC/IP appositamente forgiati dall&#8217;utente.</p>
<p>Le tipologie piu&#8217; frequenti sono due:</p>
<ul>
<li><strong>sequenza</strong> affinche&#8217; l&#8217;utente venga riconosciuto , il client deve inviare alcuni pacchetti secondo una sequenza creata al momento della configurazoine su diverse porte TCP o UDP;</li>
<li><strong>payload</strong> tutto il necessario per il riconoscimento dell&#8217;utente e&#8217; contenuto nel payload dei pacchetti</li>
</ul>
<p>a) la prima tipologia e&#8217; di facile realizzazione e utilizzo, ma e&#8217; relativamente fragile perche&#8217; basta uno sniffer di pacchetti per ascoltare la sequenza la sequenza inviata al server, replicarla e ottenere cosi&#8217; l&#8217;accesso;</p>
<p>b) se il nostro desiderio di sicurezza e&#8217; piu&#8217; paranoico, allora soltanto il port-knoking basato sui payload potranno soddisfarci, inqunato questi sono al sicuro dai tentativi di replay-attack.</p>
<h3><strong>PARANOIA</strong></h3>
<p>Il mondo e&#8217; bello ma e&#8217; pericoloso, se questo e&#8217; assodato anche per voi possiamo passare alla visione piu&#8217; paranoica per provare una nuova configurazione tramite il software <strong>fwknop</strong>, un sistema di port-knoking che pone la sua forza nel criptare i payload del pacchetto di autorizzazione.</p>
<p><strong>Fwknop</strong> va oltre al semplice sistema di port-knoking, esso in realta&#8217; e&#8217; il prototipo di una nuova tecnologia chiamata : <strong>Single Packet Authorization </strong>o (<strong>SPA</strong>) che si differenzia proprio per la possibilita&#8217; di autorizzare l&#8217;utente utilizzando un&#8217;unico pacchetto TCP/IP.</p>
<p><strong>SPA</strong> si comporta alla stessa maniera del port-knoking, solo che  invia un singolo pacchetto criptato verso il server di destinazione.<br />
Questo comporta una migliore velocità nell’accedere al servizio che decidiamo di nascondere (esempio SSH), ed un maggiore livello di discrezione sulla rete (al contrario il Port Knocking classico può essere scambiato per un tentativo di port scanning da un IDS) e soprattutto protegge dai tentativi di connessioni replicate ( il singolo pacchetto criptato viene creato tutte le volte con valore casuale e non può essere riutilizzato!).</p>
<p><strong><em>Fwknop è composto da un client ed un server</em></strong>.<br />
Il demone fwknopd installato sul server sniffa le connesioni che arrivano sull’interfaccia di rete tramite la libreria libpcap, appena riceve dal client il pacchetto criptato e firmato con la chiave giusta abilita la connessione dell’indirizzo IP sorgente verso il servizio prestabilito (iptables).<br />
Una volta inviato il pacchetto tramite il client fwknop si ha un lasso di tempo per stabilire la connessione verso il servizio protetto (di default 30 sec.), sfiorata questa tempistica il server chiude la connessione.</p>
<p><strong>INSTALLAZIONE</strong></p>
<pre>sudo apt-get install fwknop-server libpcap-dev

sudo apt-get install fwknop-client</pre>
<p>Oltre ai pacchetti vanno inserite due regole iptables fondamentali per il funziomaneto di fwknop:</p>
<div>
<pre><strong>iptables -I INPUT 1 -i eth0 -p tcp --dport 22 -j DROP
iptables -I INPUT 1 -i eth0 -p tcp --dport 22 -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</strong></pre>
</div>
<p>La prima blocca tutte le connessioni in entrata per il servizio SSH, la seconda invece accetta le connessioni già stabilite (questa servirà quando fwknop server ci autorizzerà a collegarsi verso il demone ssh).<br />
ATTENZIONE!!!<br />
Così facendo chiuderete tutte le connessioni verso ssh, accertatevi di poter accedere al server<br />
dalla console locale o abilitate la connessione a un singolo ip.<br />
Esempio:</p>
<pre><strong>iptables -I INPUT -i eth0 -s 3.3.3.3 -p tcp --dport 22 -j ACCEPT

</strong></pre>
<p>In questo caso le configurazioni sul server remoto le eseguirò da una connessione con ip 3.3.3.3 , che avra&#8217; libero accesso.</p>
<h3>Configurazione fwknop server/client</h3>
<p>Immaginiamo lo scenario:</p>
<p>ServerSPA: 2.2.2.2</p>
<p>ClientSPA: 1.1.1.1</p>
<p>UserClientSPA: pippo</p>
<p><strong>***</strong> Geneare le chiavi sul client e prenderne nota:</p>
<pre>pippo@clientspa:~$ <strong>fwknop -A tcp/22 -D 2.2.2.2 --key-gen --use-hmac --save-rc-stanza</strong>
[*] Creating initial rc file: /home/pippo/.fwknoprc.
[+] Wrote Rijndael and HMAC keys to rc file: /home/pippo/.fwknoprc
pippo@clientspa:~$
pippo@clientspa:~$ <strong>grep KEY /home/pippo/.fwknoprc</strong>
KEY_BASE64                  NPhe11+ORlK1Yfr4ipzW+ngQxzRt8kjI6UTDXLZYSv0=
HMAC_KEY_BASE64             SypMEUIhiAKTjeHlHoWR5dfu7hrLVvLnoIXINPbGTOowST1vUIs+tOtMc/XlKl6+JcVw7qc2jrpqmKujZxvnqw==
pippo@clientspa:~$

</pre>
<p><strong>***</strong> Creare sul serverspa (2.2.2.2) il file “<strong>/etc/fwknop/access.conf</strong>” inserendo le chiavi del client:</p>
<pre>SOURCE                     ANY
REQUIRE_SOURCE_ADDRESS     Y
KEY_BASE64                  NPhe11+ORlK1Yfr4ipzW+ngQxzRt8kjI6UTDXLZYSv0=
HMAC_KEY_BASE64             SypMEUIhiAKTjeHlHoWR5dfu7hrLVvLnoIXINPbGTOowST1vUIs+tOtMc/XlKl6+JcVw7qc2jrpqmKujZxvnqw==</pre>
<p><strong>***</strong> Controllare che sul file di configurazione del serverspa (2.2.2.2) sia configurata l’interfaccia di rete (WAN) corretta su cui fwknopd starà in ascolto:</p>
<pre>[root@serverspa]# <strong>grep PCAP_INTF /etc/fwknop/fwknopd.conf</strong>
# the PCAP_INTF setting.
PCAP_INTF                   eth0;</pre>
<p><strong>***</strong>  Far partire il demone fwknop sul serverspa (2.2.2.2):</p>
<pre>[pippo@serverspa]$ <strong>sudo /etc/init.d/fwknop-server start</strong>
Avvio di fwknopd:                                          [  OK  ]
[pippo@serverspa]$</pre>
<p><strong>Test di connessione</strong></p>
<p>Controllare che il serverspa (2.2.2.2) blocchi di default le connessioni verso il servizio SSH:</p>
<pre>pippo@<strong>clientspa</strong>:~$ <strong>nmap 2.2.2.2 -p22</strong>

Starting Nmap 6.40 ( http://nmap.org ) at 2014-04-30 23:21 CEST
Nmap scan report for 2.2.2.2
Host is up (0.0011s latency).
PORT   STATE    SERVICE
22/tcp <strong>filtered</strong> ssh

Nmap done: 1 IP address (1 host up) scanned in 1.97 seconds</pre>
<p><strong>***</strong> Spedire il pacchetto SPA al serverspa ed abilitare l’accesso SSH al clientspa:</p>
<p>pippo@clientspa:~$ <strong>fwknop -n 2.2.2.2 -a 1.1.1.1 # </strong>in assenza di ip statico 1.1.1.1 dovrà essere sempre sostituito dall&#8217;ip pubblico assegnato dal vostro ISP.</p>
<p>&nbsp;</p>
<p><strong>***</strong> Collegarsi dal clientspa verso il serverspa tramite ssh client <strong>entro 30 secondi</strong> :</p>
<pre>pippo@clientspa:~$ <strong>fwknop -n 2.2.2.2 -a 1.1.1.1</strong>
pippo@clientspa:~$ <strong>ssh root@2.2.2.2</strong>
root@2.2.2.2's password:
Last login: Wed Apr 30 23:06:51 2014 from 5.5.5.5
[root@serverspa ~]#</pre>
<p><strong>Conclusioni</strong></p>
<p>Fwknop non puo&#8217; garantire una sicurezza assoluta (come nessun altro software) ma integrato nel vostro sistema insieme ad altri tool puo&#8217; aumentarne notevolmente il livello.</p>
<p>Pro:</p>
<ul>
<li>Protegge i servizi da eventuali 0-day</li>
<li>Riduce i tempi di risposta del Port Knocking</li>
<li>Cripta il playload</li>
<li>Disponibilità del client per vari dispositivi</li>
</ul>
<p>Contro:</p>
<ul>
<li>Non è utilizzabile con tutti i servizi (soprattutto quelli pubblici a cui devono accedere qualsiasi utente)</li>
<li>Devi sempre avere un client disponibile</li>
</ul>
<p>&nbsp;</p>
<p>*** Leggi anche <a title="Sicurezza con il PortKnocking" href="http://tuttiperlinux.com/2014/08/30/sicurezza-con-il-portknocking/">Portknoking</a> &amp; <a title="Sicurezza – Honeypot SSH" href="http://tuttiperlinux.com/2014/09/03/sicurezza-honeypot-ssh/">Honeypot SSH</a></p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/24/firewall-apriamo-un-passaggio-segreto/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/fwknop_spa.jpg?w=300" medium="image">
			<media:title type="html">fwknop_spa</media:title>
		</media:content>
	</item>
		<item>
		<title>Sicurezza &#8211; Honeypot SSH</title>
		<link>https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/</link>
					<comments>https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 03 Sep 2014 12:43:20 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[authbind]]></category>
		<category><![CDATA[bruteforce]]></category>
		<category><![CDATA[debian]]></category>
		<category><![CDATA[firewall]]></category>
		<category><![CDATA[framework]]></category>
		<category><![CDATA[honeyd]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[kippo]]></category>
		<category><![CDATA[python]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[sudoers]]></category>
		<category><![CDATA[ubuntu]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=476</guid>

					<description><![CDATA[Un Honeypot SSH con Kippo Chiunque abbia un minimo di esperienza nel mettere a punto server rivolti verso Internet conosce bene la quantità di scansioni e di attacchi automatizzati che si possono ricevere in brevissimo tempo, a volte nel momento stesso in cui ci si collega in Rete. Molti scanner non sono sofisticati e si &#8230; <a href="https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png"><img data-attachment-id="477" data-permalink="https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/kippo-300x86/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png" data-orig-size="300,86" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="Kippo honeypot" data-image-description="&lt;p&gt;Kippo SSH Honeypot &lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=300" class="alignleft size-full wp-image-477" src="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=600" alt="Kippo honeypot" srcset="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png 300w, https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png?w=150 150w" sizes="(max-width: 300px) 100vw, 300px"   /></a>Un Honeypot SSH con Kippo</strong></h3>
<p>Chiunque abbia un minimo di esperienza nel mettere a punto server rivolti verso Internet conosce bene la quantità di <strong>scansioni e di attacchi automatizzati che si possono ricevere</strong> in brevissimo tempo, a volte nel momento stesso in cui ci si collega in Rete.</p>
<p>Molti scanner non sono sofisticati e si limitano a cercare porte<strong> ssh</strong> aperte per tentare un <strong>bruteforce</strong> e, in caso di successo, passare il controllo ad un attaccante umano (un cracker non un hacker).</p>
<p>Come descritto in un precedente articolo &#8220;<a title="Sicurezza con il PortKnocking" href="http://tuttiperlinux.com/2014/08/30/sicurezza-con-il-portknocking/"><strong>Sicurezza con il PortKnocking</strong></a>&#8221; , i passi da fare per mettersi al sicuro non sono mai abbastanza ed inparticolare alcuni servizi vanno completamente blindati anche solo per evitare enormi moli di log del firewall, solo per i tentativi di login al servizio SSH; proprio per questi motivi un ottimo esercizio e&#8217; quello di creare un honeypot partendo da quest&#8217;ultimo servizio.</p>
<p>In questo contesto si colloca <a href="http://code.google.com/p/kippo">Kippo</a>: un <strong>honeypot</strong> che simula un <strong>server ssh vulnerabile</strong> il cui obiettivo è quello di impegnare un attaccante e registrarne i movimenti. E&#8217; un tool open source scritto in Python progettato quindi per registrare attacchi di tipo bruteforce e, soprattutto, l&#8217;intera interazione shell effettuata dall&#8217; attaccante. In pratica quando un utente malintenzionato cercherà di entrare nel vostro sistema si troverà davanti un finto sistema che registrerà tutte le sue attività.</p>
<p>Kippo nel tempo si è guadagnato una certa popolarità dovuta alla sua semplicità d’uso, portabilità e al fatto che permette di <strong>riprodurre i log degli attacchi registrati</strong>.</p>
<h2>Installazione</h2>
<p>Kippo è programmato in <a href="http://www.html.it/guide/guida-python/" target="_blank">Python</a> e si basa sul framework Twisted, è necessario quindi un interprete python almeno alla versione 2.5.</p>
<p>I requisiti sono i seguenti:</p>
<ul>
<li>Python 2.5+</li>
<li>Twisted 8.0+</li>
<li>PyCrypto</li>
<li>Zope Interface</li>
</ul>
<p>come prima cosa bisogna cambiare la porta del server SSH per fare questo basta aprire e modificare il file sshd_config:</p>
<h5># vim /etc/ssh/sshd_config</h5>
<p>e sostituire la porta 22 con un’altra a vostra scelta,</p>
<p>Dopo aver modificato il parametro Port 22 con un altro (es. 2443) riavviare il servizio con il commando:</p>
<h5><strong> </strong># /etc/init.d/ssh restart</h5>
<p>Una volta sistemato questo piccolo dettaglio, bisogna installare tutti i pacchetti necessari per il corretto funzionamento di Kippo:</p>
<p>Prima di mettere in esecuzione l&#8217; honeypot occorre configurarlo agendo sui parametri nel file <code>kippo.cfg</code>.</p>
<p>Le principali opzioni sono le seguenti:</p>
<ul>
<li><strong><code>ssh_addr</code></strong>: l’indirizzo dell’interfaccia su cui vogliamo mettere kippo in ascolto (di default su tutte)</li>
<li><strong><code>ssh_port</code></strong>: il numero della porta</li>
<li><strong><code>password</code></strong>: la password per collegarsi all&#8217; honeypot, di default è <code>123456</code> che statisticamente è la password più comune che si può trovare. Se impostiamo una password <em>difficile</em> rischiamo di far fallire un attacco brute force! e ci perdiamo il bello del divertimento.</li>
<li><strong><code>[database_mysql]</code></strong>: parametri per loggare tutta l’attività di kippo su un db mysql. Di default questa opzione non è attiva.</li>
</ul>
<p>Su Linux per motivi di sicurezza kippo <strong>non</strong> può essere eseguita <strong>come</strong> <strong>root</strong> e quindi non può mettersi direttamente in ascolto sulle porte basse del sistema (&lt; 1024) tra cui anche quella di default del server ssh (la porta 22).</p>
<p>Per reindirizzare la porta 22 sulla porta in cui abbiamo messo in ascolto la honeypot dobbiamo impostare un reindirizzamento con il firewall di sistema. L’impostazione corretta dipende dal firewall che state usando sul vostro server e dalla tipologia della rete.</p>
<p>Ad esempio con iptables:</p>
<pre>iptables -A PREROUTING -t nat -i eth0 -p tcp --dport 22 -j REDIRECT --to-port 2443</pre>
<p>oppure usando l&#8217;ottimo tool <strong>rinetd</strong>, come spiegato enll&#8217;articolo &#8220;<strong><a title="Catturare il traffico di rete" href="http://tuttiperlinux.com/2014/08/06/catturare-il-traffico-di-rete/">Catturare il traffico di rete</a></strong>&#8220;.</p>
<h5>Installiamo i pacchetti</h5>
<pre># apt-get install python-dev openssl python-openssl python-pyasn1 python-twisted</pre>
<p>Visto che la porta 22 (che kippo dovrà monitorare) può essere utilizzata solo dall&#8217; utente root e per ragioni di sicurezza non è consigliato usare kippo come utente root bisogna installare un altra piccola applicazione, <strong>Authbind</strong>, che ci permetterà di eseguire kippo sulla porta 22:</p>
<h5><strong># apt-get install authbind</strong></h5>
<p>Ora creiamo un altro utente (non-root) che useremmo per eseguire kippo (non è vietato eseguire kippo come root ma per ragioni di sicurezza è consigliato usare un utente apposito):</p>
<h5># adduser kippo</h5>
<p>e aggiungiamolo alla lista dei sudoers:</p>
<p><strong> # vim /etc/sudoers</strong></p>
<p>aggiungendo la seguente stringa nel file:</p>
<h5>kippo ALL=(ALL:ALL) ALL</h5>
<p>(sotto l’utente root)</p>
<p><strong> </strong>Non ci resta che dare all&#8217; utente kippo i privilegi per usare la porta 22:</p>
<h5># touch /etc/authbind/byport/22<br />
# chown kippo:kippo /etc/authbind/byport/22<br />
# chmod 777 /etc/authbind/byport/22</h5>
<p>Ora non ci resta che cambiare utente ed entrare nel sistema con l’utente kippo, una volta cambiato utente siamo pronti a scaricare kippo (verificare sul sito del progetto per nuove versioni):</p>
<h5># wget <a href="https://kippo.googlecode.com/files/kippo-0.8.tar.gz" rel="nofollow">https://kippo.googlecode.com/files/kippo-0.8.tar.gz</a> /home/&lt;utente xxx&gt;/Downloads/</h5>
<p>estraiamo i file:</p>
<h5># tar -zxvf kippo-0.8.tar.gz -C /opt/</h5>
<p>ora ci spostiamo nella cartella del programma e modifichiamo il file kippo.cfg inserendo la porta 22 come target (di default è impostata la 2222) con la porta da voi prescelta, tipo la 2443.</p>
<h5><strong># vim kippo.cfg</strong></h5>
<p>ed in fine modifichiamo il file start.sh:</p>
<h5><strong># vim start.sh</strong></h5>
<p>sostituendo la stringa:</p>
<h5><strong>twistd -y kippo.tac -l log/kippo.log &#8211;pidfile kippo.pid</strong></h5>
<p>con:</p>
<h5><strong>authbind &#8211;deep twistd -y kippo.tac -l log/kippo.log &#8211;pidfile kippo.pid</strong></h5>
<p>ora non ci resta che eseguire il programma con:</p>
<h5><strong># ./start.sh</strong></h5>
<p>&#8230;&#8230; e qualsiasi tentativo di connettersi alla porta 22 del sistema sarà registrato da Kippo e file di log verranno archiviati nella cartella corrispondente. Kippo rimane in esecuzione in background e aspetta che qualche attaccante si faccia vivo.</p>
<p>Quando finalmente riusciremo a <strong>registrare un attacco</strong> (e solitamente è questione di solo poche ore!) l’honeypot si occuperà di registrare ogni movimento.</p>
<p>Nella cartella <code><strong>log</strong>/</code> verranno salvati i log interattivi delle sessioni registrate e in quella <code><strong>dl</strong>/</code> verranno salvati i file e gli eseguibili che gli ignari attaccanti tenteranno di scaricare sul server (di solito rootkit, malware generici, etc)</p>
<p>Il divertimento, una volta collezionati un po di log interattivi, è quello di riprodurli con il <code>playlog</code> che è una utilità che permette di <strong>riprodurre i log come se fossero un video</strong>.</p>
<p>Il programma si trova nella cartella <code>utils/</code>, per eseguirlo (da linea di comando):</p>
<pre>python playlog.py /path/to/xxx.log

</pre>
<h2>Statistiche</h2>
<p>Quando si ha una honeypot funzionante a pieno regime può risultare scomodo controllare periodicamente i log per capire il numero di attacchi ricevuti, la durata e altre informazioni utili.</p>
<p>Per facilitarci le cose possiamo affidarci a un programma come <a href="http://bruteforce.gr/kippo-graph">Kippo Graph</a> che si occupa di generare statistiche dettagliate e farci risparmiare del tempo prezioso.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/09/03/sicurezza-honeypot-ssh/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/09/kippo-300x86.png" medium="image">
			<media:title type="html">Kippo honeypot</media:title>
		</media:content>
	</item>
		<item>
		<title>Sicurezza con il PortKnocking</title>
		<link>https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/</link>
					<comments>https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sat, 30 Aug 2014 22:33:36 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[firewall]]></category>
		<category><![CDATA[honeypot]]></category>
		<category><![CDATA[ip]]></category>
		<category><![CDATA[iptables]]></category>
		<category><![CDATA[linux blog]]></category>
		<category><![CDATA[port knocking]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[stealth]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=461</guid>

					<description><![CDATA[Mi e&#8217; capitato spesso di dover configurare firewall per proteggere i Server di mia competenza e molte volte capita l&#8217;esigenza di dover tenere aperto un accesso dall&#8217;esterno, per poter operare in qualunque momento o per qualunque motivo. Ovviamente questo ci potrebbe esporre facilmente alla possibilita&#8217; di venire attaccati; che cosa fare in questi casi ??? &#8230; <a href="https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><a href="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png"><img loading="lazy" data-attachment-id="462" data-permalink="https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/portknocking/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png" data-orig-size="320,240" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="portknocking" data-image-description="&lt;p&gt;Port-Knocking&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=320" class="alignleft size-medium wp-image-462" src="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300&#038;h=225" alt="portknocking" width="300" height="225" srcset="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300&amp;h=225 300w, https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=150&amp;h=113 150w, https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png 320w" sizes="(max-width: 300px) 100vw, 300px" /></a>Mi e&#8217; capitato spesso di dover configurare firewall per proteggere i Server di mia competenza e molte volte capita l&#8217;esigenza di dover tenere aperto un accesso dall&#8217;esterno, per poter operare in qualunque momento o per qualunque motivo. Ovviamente questo ci potrebbe esporre facilmente alla possibilita&#8217; di venire attaccati; che cosa fare in questi casi ??? Beh! le possibili soluzioni sono davvero tante, tante quanto la fantasia di chi le studia; in questo articolo quindi descrivero&#8217; semplicemente un mio modo personale di arginare tale possibile pericolo.</p>
<p><strong>* Il primo</strong> suggerimento e&#8217; quello di spostare il servizio SSH dalla porta 22 ad una di vostra preferenza, stando ben attenti a non usare possibili porte utilizzabili da altri servizi web.</p>
<p><strong>* Il secondo</strong> suggerimento e&#8217; quello di creare un servizio di <a href="http://it.wikipedia.org/wiki/Honeypot">Honeypot</a> (tipo <em>honeyd a bassa interazione, oppure come honeynet ad alta interazione</em>) , da tenere in ascolto sulla porta standard (la 22) dell&#8217;SSH, cosi&#8217; che i male intenzionati trovino la porta attiva e nel tentativo di attaccarvi perdano tempo e si ritrovino successivamente all&#8217;interno di servizi fasulli.</p>
<p><strong>* Il terzo</strong> suggerimento e&#8217; quello di utilizzare la tecnica del port-knocking per poter gestire a proprio piacimento ogni accesso in SSH attivando e disattivando tramite una sequenza di caratteri che solo voi conoscete e che potrete cambiare a piacimento.</p>
<h3><strong>PORTKNOCKING</strong></h3>
<p>Iniziamo col dire che cosa e&#8217; questa tecnica: le tecniche di <strong>Port knocking</strong> permettono di aumentare considerevolmente la sicurezza di un server che deve garantire alcuni servizi non permanenti attraverso IP pubblici. Se s&#8217;inviano dei pacchetti a delle porte prestabilite sulle quali il demone è in ascolto e nel caso la sequenza sia corretta, questi attiverà un comando che potrà eseguire delle regole di <strong>iptables </strong>che apriranno le porte necessarie alla connessione. Il vantaggio è notevole in quanto il server potrebbe rimanere sempre in <em>stealth</em> <em>mode</em> e aprire le porte per un determinato servizio solo in caso di necessità.</p>
<p>Innanzitutto per poter utilizzare il portknocking e&#8217; necessario che il firewall sia attivo e funzionante, ora posiamo installare il pacchetto software</p>
<p>sudo apt-get install knockd</p>
<h3 id="Configurazione_knockd">Configurazione knockd</h3>
<ol type="0">
<li>
<p class="line862">Per fare in modo che il demone parta all&#8217;avvio del computer modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/default/knockd</tt> in questo modo: <span id="line-14" class="anchor"></span><span id="line-15" class="anchor"></span><span id="line-16" class="anchor"></span></p>
<pre><span id="line-1" class="anchor"></span>START_KNOCKD=1</pre>
<p>&nbsp;</li>
<li class="gap">
<p class="line862">Sempre nel medesimo file <tt>/etc/default/knockd</tt> modificare con un editor di testo a piacimento, e con i privilegi di amministrazione indicando su quale interfaccia il demone dovrà rimanere in ascolto: <span id="line-19" class="anchor"></span><span id="line-20" class="anchor"></span><span id="line-21" class="anchor"></span></p>
<pre><span id="line-1-1" class="anchor"></span>KNOCKD_OPTS="-i eth0"</pre>
<p>&nbsp;</li>
</ol>
<h3 id="Configurazione_knockd.conf_per_l.27apertura_di_una_sola_porta">Configurazione knockd.conf per l&#8217;apertura di una sola porta</h3>
<p class="line862">Modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/knockd.conf</tt> impostandolo come segue: <span id="line-25" class="anchor"></span><span id="line-26" class="anchor"></span></p>
<pre><span id="line-1-2" class="anchor"></span>[options]
<span id="line-2" class="anchor"></span>        logfile = /var/log/knockd.log
<span id="line-3" class="anchor"></span>
<span id="line-4" class="anchor"></span>[openSSH]
<span id="line-5" class="anchor"></span>        sequence    = 7000,8000,9000
<span id="line-6" class="anchor"></span>        # Questa è la sequenza delle porte sulle quali knockd rimarrà in ascolto. Di default il protocollo è TCP.
<span id="line-7" class="anchor"></span>        # Quali e quante porte usare è discrezionale.
<span id="line-8" class="anchor"></span>
<span id="line-9" class="anchor"></span>        # sequence   = 7000:udp,8000:tcp,9000:udp
<span id="line-10" class="anchor"></span>        # Esempio con sequenza con porte miste udp/tcp
<span id="line-11" class="anchor"></span>
<span id="line-12" class="anchor"></span>        seq_timeout = 30
<span id="line-13" class="anchor"></span>        #Tempo di attesa massimo per completare la sequenza.
<span id="line-14" class="anchor"></span>
<span id="line-15" class="anchor"></span>        command     = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
<span id="line-16" class="anchor"></span>        # Quando la sequenza verrà accettata verrà inserita una regola che aprirà la porta SSH standard.
<span id="line-17" class="anchor"></span>
<span id="line-18" class="anchor"></span>        tcpflags    = syn
<span id="line-19" class="anchor"></span>        # Ulteriore filtro, sul tipo di flag del pacchetto inviato alla sequenza di porte.
<span id="line-20" class="anchor"></span>        
<span id="line-21" class="anchor"></span>[closeSSH]
<span id="line-22" class="anchor"></span>        sequence    = 9000,8000,7000
<span id="line-23" class="anchor"></span>        # Questa è un'altra sequenza di porte sulle quali knockd rimarrà in ascolto.
<span id="line-24" class="anchor"></span>
<span id="line-25" class="anchor"></span>        seq_timeout = 30
<span id="line-26" class="anchor"></span>
<span id="line-27" class="anchor"></span>        command     = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
<span id="line-28" class="anchor"></span>        # Quando la sequenza verrà accettata verrà inserita una regola che cancellerà quella creata in precedenza.
<span id="line-29" class="anchor"></span>
<span id="line-30" class="anchor"></span>        tcpflags    = syn
<span id="line-31" class="anchor"></span>        # Ulteriore filtro, sul tipo di flag del pacchetto inviato alla sequenza di porte.</pre>
<p class="line874">La variabile «%IP%» passa alla regola di iptables l&#8217;indirizzo che ha effettuato la richiesta di connessione, in questo caso verrà permessa l&#8217;apertura della porta SSH discriminando solo l&#8217;IP validato. <span id="line-61" class="anchor"></span><span id="line-62" class="anchor"></span></p>
<h3 id="Configurazione_per_l.27apertura_di_una_sola_porta.2C_per_soli_esperti">Configurazione per l&#8217;apertura di una sola porta, per soli esperti</h3>
<p class="line862">Un&#8217;altra possibilità per usare il demone knockd, e&#8217; utilizzabile <strong>solo se il firewall sul server è configurato per accettare le connessioni &#8220;established&#8221; e &#8220;related&#8221;</strong> alla porta che si vuole aprire (es ssh, 22) è di chiudersi subito dietro la porta appena aperta, per evitare che, restando &#8220;aperta&#8221;, qualche malintenzionato tenti un brute-force al servizio, lanciando uno script anzichè impostando delle regole sul firewall. <span id="line-64" class="anchor"></span><span id="line-65" class="anchor"></span></p>
<p class="line862">Per questo scopo il file <tt>/etc/knockd.conf </tt>può ad esempio essere modificato, con un editor di testo a piacimento, e con i privilegi di amministrazione, come segue : <span id="line-66" class="anchor"></span><span id="line-67" class="anchor"></span></p>
<pre><span id="line-1-3" class="anchor"></span>[options]
<span id="line-2-1" class="anchor"></span>        logfile = /var/log/knockd.log
<span id="line-3-1" class="anchor"></span>
<span id="line-4-1" class="anchor"></span>[openSSH]
<span id="line-5-1" class="anchor"></span>        sequence    = 7000,8000,9000
<span id="line-6-1" class="anchor"></span>        seq_timeout = 30
<span id="line-7-1" class="anchor"></span>        start_command     = /etc/init.d/ssh start
<span id="line-8-1" class="anchor"></span>        tcpflags    = syn
<span id="line-9-1" class="anchor"></span>
<span id="line-10-1" class="anchor"></span>        cmd_timeout = 5
<span id="line-11-1" class="anchor"></span>        stop_command     = /etc/init.d/ssh stop
<span id="line-12-1" class="anchor"></span>        # Dopo cmd_timeout secondi, viene eseguito il comando stop_command</pre>
<p class="line862">Ricordiamo ancora che <strong>è indispensabile</strong> che il firewall sul server accetti le connessioni &#8220;related&#8221; ed &#8220;established&#8221; altrimenti la sezione &#8220;stop_command&#8221;, appena sarà eseguita, vi chiuderà la connessione SSH senza quindi avere possibilità di connettervi al server! <span id="line-82" class="anchor"></span><span id="line-83" class="anchor"></span></p>
<pre><span id="line-1-4" class="anchor">tuttiperlinux</span>@server:~# iptables -nL | grep ":22"
<span id="line-2-2" class="anchor"></span>
<span id="line-3-2" class="anchor"></span>ACCEPT     tcp  --  0.0.0.0/0    0.0.0.0/0           tcp dpt:22
<span id="line-4-2" class="anchor"></span>ACCEPT     tcp  --  0.0.0.0/0    0.0.0.0/0           tcp spt:22 dpts:513:65535 state RELATED,ESTABLISHED
<span id="line-5-2" class="anchor"></span>ACCEPT     tcp  --  0.0.0.0/0    0.0.0.0/0           tcp spts:1024:65535 dpt:22 flags:0x17/0x02 state RELATED,ESTABLISHED
<span id="line-6-2" class="anchor"></span>ACCEPT     udp  --  0.0.0.0/0    0.0.0.0/0           udp dpt:22 state ESTABLISHE
<span id="line-7-2" class="anchor"></span></pre>
<h3 id="Configurazione_knockd.conf_per_l.27apertura_di_pi.2BAPk_porte">Configurazione knockd.conf per l&#8217;apertura di più porte</h3>
<p class="line874">Nell&#8217;esempio sopra esposto si è visto come aprire una sola porta. Se l&#8217;esigenza fosse però quella di aprirne di più procedere creando più sessioni «[openServizio]» e «[closeServizio]». Questo sistema risulta però scomodo per ovvi motivi, per ottenere lo stesso risultato è consigliato usare degli script. <span id="line-94" class="anchor"></span><span id="line-95" class="anchor"></span></p>
<p class="line862">Modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/knockd.conf</tt> impostandolo come segue: <span id="line-96" class="anchor"></span><span id="line-97" class="anchor"></span></p>
<pre><span id="line-1-5" class="anchor"></span>[options]
<span id="line-2-3" class="anchor"></span>        logfile = /var/log/knockd.log
<span id="line-3-3" class="anchor"></span>
<span id="line-4-3" class="anchor"></span>[open]
<span id="line-5-3" class="anchor"></span>        sequence    = 7000,8000,9000
<span id="line-6-3" class="anchor"></span>        seq_timeout = 30
<span id="line-7-3" class="anchor"></span>        tcpflags    = syn
<span id="line-8-2" class="anchor"></span>        command     = sh /etc/open_ports %IP%
<span id="line-9-2" class="anchor"></span>
<span id="line-10-2" class="anchor"></span>
<span id="line-11-2" class="anchor"></span>[close]
<span id="line-12-2" class="anchor"></span>        sequence    = 9000,8000,7000
<span id="line-13-1" class="anchor"></span>        seq_timeout = 30
<span id="line-14-1" class="anchor"></span>        tcpflags    = syn
<span id="line-15-1" class="anchor"></span>        command     = sh /etc/close_ports %IP%</pre>
<p class="line874">In questo caso invece di eseguire direttamente iptables si richiamano due script passando il parametro «%IP%» alla variabile speciale «$1». <span id="line-116" class="anchor"></span><span id="line-117" class="anchor"></span></p>
<h3 id="Esempio_di_script_open_ports">Esempio di script open_ports</h3>
<p class="line862">Modificare con un editor di testo a piacimento, e con i privilegi di amministrazione il file <tt>/etc/open_ports</tt> impostandolo come segue: <span id="line-119" class="anchor"></span><span id="line-120" class="anchor"></span></p>
<pre><span id="line-1-6" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 22 -j ACCEPT
<span id="line-2-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 21 -j ACCEPT
<span id="line-3-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 631 -j ACCEPT
<span id="line-4-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 5125 -j ACCEPT
<span id="line-5-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 5126 -j ACCEPT
<span id="line-6-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 8888 -j ACCEPT
<span id="line-7-4" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 10000 -j ACCEPT
<span id="line-8-3" class="anchor"></span>iptables -A INPUT -s $1 -p tcp --dport 81 -j ACCEPT</pre>
<h3 id="Esempio_di_script_close_ports">Esempio di script close_ports</h3>
<p class="line862">Modificare con un editor di testo a piacimento,  e con i privilegi di amministrazione il file <tt>/etc/close_ports</tt> impostandolo come segue: <span id="line-134" class="anchor"></span><span id="line-135" class="anchor"></span></p>
<pre><span id="line-1-7" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 22 -j ACCEPT
<span id="line-2-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 21 -j ACCEPT
<span id="line-3-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 631 -j ACCEPT
<span id="line-4-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 5125 -j ACCEPT
<span id="line-5-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 5126 -j ACCEPT
<span id="line-6-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 8888 -j ACCEPT
<span id="line-7-5" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 10000 -j ACCEPT
<span id="line-8-4" class="anchor"></span>iptables -D INPUT -s $1 -p tcp --dport 81 -j ACCEPT

</pre>
<h3 id="Connessione">Esempio di una connessione</h3>
<p class="line874">Per effettuare la connessione digitare il seguente comando all&#8217;interno di una finestra di terminale: <span id="line-168" class="anchor"></span><span id="line-169" class="anchor"></span></p>
<pre><span id="line-1-9" class="anchor"></span>./knock -v &lt;ip_host&gt; port1 port2 port3 port...</pre>
<p>Ora non resta altro che fare pratica e pratica ma sono sicuro che il portknocking vi dara&#8217; tanta soddisfazione.</p>
<p>Leggete anche l&#8217;articolo sulla sicurezza inerente <a title="Metasploit Framework" href="http://tuttiperlinux.com/2014/08/29/metasploit-framework/">Metasploit Framework</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/08/30/sicurezza-con-il-portknocking/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/08/portknocking.png?w=300" medium="image">
			<media:title type="html">portknocking</media:title>
		</media:content>
	</item>
		<item>
		<title>Multi Tail ed  i file di Log</title>
		<link>https://tuttiperlinux.blog/2014/06/30/multi-tail-ed-i-file-di-log/</link>
					<comments>https://tuttiperlinux.blog/2014/06/30/multi-tail-ed-i-file-di-log/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Mon, 30 Jun 2014 20:48:06 +0000</pubDate>
				<category><![CDATA[Tips & Tricks]]></category>
		<category><![CDATA[log]]></category>
		<category><![CDATA[multitail]]></category>
		<category><![CDATA[sessioni]]></category>
		<category><![CDATA[sistema]]></category>
		<category><![CDATA[ssh]]></category>
		<category><![CDATA[syslog]]></category>
		<category><![CDATA[tail]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=150</guid>

					<description><![CDATA[Come tenere sotto controllo piu&#8217; file di Log :  Uno dei comandi piu&#8217; utilizzati dagli amministratori di sistema e&#8217; TAIL , che permette di tenere sotto controllo i log, ossia quei preziosi file di testo nei quali sono presenti innumerevoli quantita&#8217; d&#8217;informazioni utili alla corretta gestione di un sistema e del funzionamento dei molti software installati. Basta &#8230; <a href="https://tuttiperlinux.blog/2014/06/30/multi-tail-ed-i-file-di-log/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_152" style="width: 310px" class="wp-caption alignleft"><a href="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png"><img loading="lazy" aria-describedby="caption-attachment-152" data-attachment-id="152" data-permalink="https://tuttiperlinux.blog/2014/06/30/multi-tail-ed-i-file-di-log/multitail-gnome-terminal/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png" data-orig-size="506,366" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="multitail-gnome-terminal" data-image-description="&lt;p&gt;Sistema di gestione dei Log in Multitail&lt;/p&gt;
" data-image-caption="&lt;p&gt;Immagine presa dal sito del produttore di MultiTail&lt;br /&gt;
(http://www.vanheusden.com/multitail/)&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png?w=506" class="size-medium wp-image-152" src="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png?w=300&#038;h=216" alt="MultiTail by Vanheusden" width="300" height="216" srcset="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png?w=300&amp;h=216 300w, https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png?w=150&amp;h=108 150w, https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png 506w" sizes="(max-width: 300px) 100vw, 300px" /></a><p id="caption-attachment-152" class="wp-caption-text">Immagine presa dal sito del produttore di MultiTail<br />(<a href="http://www.vanheusden.com/multitail/" rel="nofollow">http://www.vanheusden.com/multitail/</a>)</p></div>
<p><strong>Come tenere sotto controllo piu&#8217; file di Log : </strong></p>
<p>Uno dei comandi piu&#8217; utilizzati dagli amministratori di sistema e&#8217; <strong>TAIL </strong>, che permette di tenere sotto controllo i log, ossia quei preziosi file di testo nei quali sono presenti innumerevoli quantita&#8217; d&#8217;informazioni utili alla corretta gestione di un sistema e del funzionamento dei molti software installati.<br />
Basta infatti, ad esempio, digitare il comando # <strong>sudo tail -f /var/log/syslog </strong>per poter leggere gli ultimi messaggi che il kernel ha inviato alla console. In alcuni casi pero&#8217; non basta poter controllare un solo file di log per volta finendo cosi&#8217; per aprire piu&#8217; finestre del terminale (una per ogni file di log che si deve controllare) o a dover stabilire piu&#8217; connessioni <strong>ssh </strong>(nel caso si stia accedendo remotamente ad un sistema).<br />
Una valida alternativa che ci permette di evitare il prolificare di finestre e sessioni e&#8217; <strong>multitail </strong>, un&#8217;utility che ci consente di monitorare contemporaneamente, all&#8217;interno della stessa finestra del terminale, piu&#8217; file di log. Il suo utilizzo e&#8217; decisamente semplice, infatti basta ricorrere piu&#8217; volte , all&#8217;interno del comando, all&#8217;opzione &#8221; <strong>-i </strong>&#8221; seguita dal nome del file  di log che si vuole controllare per veder comporsi la pagina del terminale con piu&#8217; istanze di tail attive. Ad esempio, digitando :</p>
<pre>sudo multitail -i /var/log/syslog -i /var/log/ufw -i /var/log/cups/access.log -i /var/log/samba/log.smbd
</pre>
<p>la finestra del terminale verra&#8217; divisa in quattro parti (orizzontalmente) e verranno visualizzati contemporaneamente i file precedentemente indicati nel comando. Per uscire da questa visualizzazione e&#8217; sufficiente premere il tasto &#8221; <strong>q </strong>&#8220;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/06/30/multi-tail-ed-i-file-di-log/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/06/multitail-gnome-terminal.png?w=300" medium="image">
			<media:title type="html">MultiTail by Vanheusden</media:title>
		</media:content>
	</item>
		<item>
		<title>Fail2ban &#8211; fuori i curiosi</title>
		<link>https://tuttiperlinux.blog/2014/06/24/fail2ban-tenere-i-curiosi-fuori-dal-nostro-pc/</link>
					<comments>https://tuttiperlinux.blog/2014/06/24/fail2ban-tenere-i-curiosi-fuori-dal-nostro-pc/#respond</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Tue, 24 Jun 2014 11:34:07 +0000</pubDate>
				<category><![CDATA[Sicurezza]]></category>
		<category><![CDATA[client]]></category>
		<category><![CDATA[fail2ban]]></category>
		<category><![CDATA[ip]]></category>
		<category><![CDATA[jail]]></category>
		<category><![CDATA[ssh]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=17</guid>

					<description><![CDATA[Spesso capita, persino in ufficio, di dover proteggere la propria privacy da curiosi o male intenzionati e fail2ban ha sempre svolto egregiamente il suo compito di guardiano del castello, infatti si tratta di un programma che tiene sotto monitoraggio alcuni file di log e, quando rileva dei tentativi ripetuti &#38; falliti (configurabili) di accedere ad un determinato servizio provvedera&#8217; &#8230; <a href="https://tuttiperlinux.blog/2014/06/24/fail2ban-tenere-i-curiosi-fuori-dal-nostro-pc/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Spesso capita, persino in ufficio, di dover proteggere la propria privacy da curiosi o male intenzionati e <strong>fail2ban</strong> ha sempre svolto egregiamente il suo compito di guardiano del castello, infatti si tratta di un programma che tiene sotto monitoraggio alcuni file di log e, quando rileva dei tentativi ripetuti &amp; falliti (configurabili) di accedere ad un determinato servizio provvedera&#8217; al blocco dell&#8217;host incriminato, a livello d&#8217;indirizzo IP, aggiungendolo alle regole di firewall di IPTABLES.</p>
<p>Bene, installiamolo ! :  <strong>/$ sudo apt-get install fail2ban</strong></p>
<p>Appena installato il pacchetto saranno gia&#8217; in esecuzione alcune regole abilitate di default come ad esempio quella per bloccare gli IP che falliscono gli accessi SSH ecc&#8230;.</p>
<p>Fail2ban viene installato in modalita&#8217; demone, sara&#8217; quindi possibile gestirne lo start &amp; stop tramite i comandi</p>
<p><strong>/etc/init.d/fail2ban  start/stop</strong>      oppure       <strong>service fail2ban  start/stop</strong></p>
<p>I file di configurazione si trovano in /etc/fail2ban, in particolare prestiamo attenzione al file &#8220;jail.conf&#8221; il quale contiene le configurazioni di base del pacchetto e suo relativo uso. Dal manuale viene consigliato di non modificare i file di conf originari ma di creare una copia locale tramite (es.) : <strong>/etc/fail2ban$ sudo cp jail.conf jail.local </strong></p>
<p>Andremo ora ad impostare all&#8217;interno di quest&#8217;ultimo file le regole di filtraggio per i vari servizi di nostro interesse.</p>
<p>Ogni regola e&#8217; indicata dal nome della regola, scritta tra parentesi quadre, a cui fanno seguito i parametri che vogliamo impostare, seguiti da un simbolo  &#8221; = &#8221; e dal valore che vogliamo assegnare alla regola, facciamo un esempio lavorando su alcuni parametri di Default e sulla regola di filtraggio del servizio SSH :</p>
<p>[DEFAULT]<br />
ignoreip = 127.0.0.1 192.168.xx.xx<br />
bantime = 600<br />
maxretry = 3<br />
backend = polling<br />
destemail = root@localhost<br />
action = iptables[name=%(__name__)s, port=%(port)s]</p>
<p>&#8230;in questo esempio stiamo dicendo al programma di non considerare nei filtri le richieste di autenticazione errate provenienti dall&#8217;IP locale (127.0.0.1) e da un IP fidato della nostra rete (192.168.xx.xx). Il secondo parametro imposta il tempo di <strong>&#8220;ban&#8221; </strong>ossia la quantita&#8217; di tempo (espressa in secondi) per cui vogliamo che fail2ban tenga nelle regole di Iptables</p>
<p>l&#8217;IP da &#8216;bannare&#8217; / bloccare [600 secondi = 10 minuti], mentre il parametro &#8216;maxretry&#8217; indica quanti tentativi errati di connessione lasciamo attivi prima di bannare l&#8217;IP, le ultime tre righe lavorano insieme, in pratica il polling e&#8217; il metodo di gestione degli allarmi a cui, una volta scattato l&#8217;allarme, viene fatta mandare una mail al destinatario sotto indicato.</p>
<p>Passiamo adesso alla sezione del servizio SSH :</p>
<p>[ssh]<br />
enabled = true<br />
port = ssh<br />
filter = sshd<br />
logpath = /var/log/auth.log<br />
maxretry = 5</p>
<p>i parametri in questo caso sono presto spiegati, la prima riga dice di abilitare il controllo su questo servizio, indicando come porta da monitorare quella del servizio SSH (che come standard ascolta sulla 22) e come demone associa SSHD, indicando il percorso contenente il file di log da cui leggere per verificare i tentativi di accesso; l&#8217;ultimo parametro indica il valore del numero di accessi negati da trovare nel file di log prima che l&#8217;IP venga bloccato dalle regole di firewall Iptables.</p>
<p>Al termine della configurazione delle regole di nostro interesse sara&#8217; necessario riavviare il servizio cosi&#8217; come indicato precedentemente e magari provare ad accedere da qualche altro PC, sbagliando volontariamente la password di accesso in ssh cosi da poter sperimentare l&#8217;effettivo funzionamento dei filtri.</p>
<p>Per verificare il funzionamento dei filtri su di un servizio e&#8217; anche possibile utilizzare il comando del client fail2ban:</p>
<ul>
<li><strong>sudo fail2ban-client status ssh </strong></li>
</ul>
<p>dalla versione 8.8 in poi e&#8217; anche possibile &#8220;unbannare&#8221; ossia togliere dall&#8217;esclusione degli accessi un IP precedentemente bloccato tramite il comando : <strong>sudo fail2ban-client set ssh unbanip &lt;ip da sbloccare&gt;</strong></p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/06/24/fail2ban-tenere-i-curiosi-fuori-dal-nostro-pc/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>
	</item>
	</channel>
</rss>
