<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>localhost &#8211; Tutti per Linux</title>
	<atom:link href="https://tuttiperlinux.blog/tag/localhost/feed/" rel="self" type="application/rss+xml" />
	<link>https://tuttiperlinux.blog</link>
	<description>Tutto cio&#039; che avresti sempre voluto capire su Linux ed il mondo Digitale</description>
	<lastBuildDate>Mon, 19 Jan 2015 08:05:51 +0000</lastBuildDate>
	<language>it-IT</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='tuttiperlinux.blog' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/fa5c4cf69896031d9ec71ff8d5aafd25?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>localhost &#8211; Tutti per Linux</title>
		<link>https://tuttiperlinux.blog</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://tuttiperlinux.blog/osd.xml" title="Tutti per Linux" />
	<atom:link rel='hub' href='https://tuttiperlinux.blog/?pushpress=hub'/>
	<item>
		<title>Bloccare la pubblicita&#8217; senza plug-in</title>
		<link>https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/</link>
					<comments>https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sun, 28 Dec 2014 11:36:52 +0000</pubDate>
				<category><![CDATA[SysAdmin]]></category>
		<category><![CDATA[Tips & Tricks]]></category>
		<category><![CDATA[127.0.0.1]]></category>
		<category><![CDATA[adblock]]></category>
		<category><![CDATA[banner]]></category>
		<category><![CDATA[bash]]></category>
		<category><![CDATA[browser]]></category>
		<category><![CDATA[chrome]]></category>
		<category><![CDATA[crontab]]></category>
		<category><![CDATA[extension]]></category>
		<category><![CDATA[google]]></category>
		<category><![CDATA[hosts]]></category>
		<category><![CDATA[linux blog in italiano]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[plugin]]></category>
		<category><![CDATA[schedulazione]]></category>
		<category><![CDATA[script]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.com/?p=833</guid>

					<description><![CDATA[&#160; Negli ultimi anni i banner pubblicitari presenti nelle pagine di molti siti si sono trasformati in un mostro incontrollato e soprattutto molto invasivo e, a causa dell’abuso da parte di alcuni, sono finiti per diventare la bestia nera di Internet, inducendo numerosi utenti a trovare un modo per bloccarli con i metodi più disparati. &#160; Tra questi figurano &#8230; <a href="https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_836" style="width: 293px" class="wp-caption alignleft"><img aria-describedby="caption-attachment-836" data-attachment-id="836" data-permalink="https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/adblock/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg" data-orig-size="283,178" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="adblock" data-image-description="" data-image-caption="&lt;p&gt;Linux Ad Block&lt;/p&gt;
" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=283" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=283" class="size-full wp-image-836" src="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=600" alt="Linux Ad Block" srcset="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg 283w, https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg?w=150 150w" sizes="(max-width: 283px) 100vw, 283px"   /><p id="caption-attachment-836" class="wp-caption-text">Linux Ad Block</p></div>
<p>&nbsp;</p>
<p>Negli ultimi anni i banner pubblicitari presenti nelle pagine di molti siti si sono trasformati in un mostro incontrollato e soprattutto molto invasivo e, a causa dell’abuso da parte di alcuni, sono finiti per diventare la bestia nera di Internet, inducendo numerosi utenti a trovare un modo per bloccarli con i metodi più disparati.</p>
<p>&nbsp;</p>
<p>Tra questi figurano ad esempio due note estensioni per browser, ad esempio su Chrome tra i piu&#8217; conosciuti possiamo trovare AdBlock e AdBlock Plus, che svolgono egregiamente il proprio lavoro modificando al volo il foglio di stile delle pagine web impedendone la visualizzazione. D’altra parte questo vantaggio ha un peso materiale: entrambe le estensioni finiscono per appesantire notevolmente il browser, il che potrebbe essere uno svantaggio per molti.</p>
<p>In questo breve articolo verra&#8217; illustrato un metodo efficace per bloccare la visualizzazione dei banner pubblicitari dei più noti circuiti pubblicitari, usando una versione modificata del file <strong>/etc/hosts</strong></p>
<p>&nbsp;</p>
<p><strong>Bloccare la pubblicità senza AdBlock </strong></p>
<p>Il criterio che utilizzeremo è di per se molto semplice, infatti il file /etc/hosts permette di associare manualmente host ad indirizzi IP senza affidarsi alla risoluzione tramite server DNS; grazie al lavoro ed alla costanza di alcuni sviluppatori, è possibile scaricare un file modificato ad-hoc affinché agli host dei più noti banner pubblicitari venga automaticamente associato l&#8217;indirizzo IP 127.0.0.1, ovvero l’indirizzo locale della propria macchina (localhost).  Risultato:<br />
i banner non verranno più visualizzati!</p>
<p>Senza dilungarci in ulteriori spiegazioni procediamo alla modifica: andiamo innanzitutto a creare un backup del file /etc/hosts presente nel nostro sistema operativo, da ripristinare in caso di problemi, dopodiché, andremo a creare uno script per il download/upgrade automatico del file che inseriremo nel nostro crontab.</p>
<p><strong>*Preparazione</strong><br />
Creamo innanzitutto un backup del nostro file /etc/hosts originale da ripristinare in caso di problemi: per farlo, da terminale, digitiamo</p>
<pre># sudo cp /etc/hosts /etc/hosts.bak</pre>
<p>Adesso creiamo lo script che sara&#8217; in grado di scaricare automaticamente il nuovo file host, concedendogli eventualmente una serie di tentativi qualora la connessione ad Internet non fosse subito disponibile, quindi dal nostro terminale digitiamo</p>
<pre># sudo vim /usr/local/bin/adblock.sh</pre>
<p>All’interno del file appena creato inseriamo quanto segue:</p>
<pre>#!/bin/bash

exec 2&gt; /tmp/adblock.log
exec 1&gt;&amp;2
set -x
wget -q -O - 1 --retry-connrefused http://someonewhocares.org/hosts/hosts | grep -P "^(127.0.0.1 |::1 |# )" &gt; /etc/hosts

chmod 644 /etc/hosts</pre>
<p>Salviamo il file ed usciamo dall’editor, dopodiché renderlo eseguibile con il comando</p>
<pre># sudo chmod +x /usr/local/bin/adblock.sh</pre>
<p>Ora facciamo in modo di aggiungere il nostro nuovo script nel crontab del sistema in modo da farlo eseguire, in automatico, almeno ogni 4 ore (la scelta ottimale sta a voi).</p>
<p>Per coloro che non sono soliti ad utilizzare la gestione del crontab facciamo un breve ripasso sulla sua sintassi :</p>
<p id="Esempi_di_sintassi_dei_comandi"><strong>Esempi di sintassi dei comandi cron</strong></p>
<p class="line862">Il file <strong>crontab</strong> deve rispettare una sintassi ben precisa, diversamente il sistema non accetterà le impostazioni. Quello che segue è un esempio generico:<span id="line-37" class="anchor"></span><span id="line-38" class="anchor"></span><span id="line-39" class="anchor"></span></p>
<p><span id="line-1-3" class="anchor"></span>5 3 * * * /usr/bin/apt-get update</p>
<p class="line862">L&#8217;esempio precedente eseguirà il comando <strong>apt-get update</strong> ogni giorno di ogni mese alle ore 03:05 (l&#8217;orario viene indicato nel formato a 24 ore).<span id="line-42" class="anchor"></span><span id="line-43" class="anchor"></span></p>
<p class="line874">La prima parte della voce descrive quando l&#8217;azione deve essere effettuata. Ci sono cinque campi (nell&#8217;esempio precedente, «5 3 * * *»), separati da uno spazio, ognuno dei quali accetta un numero, un asterisco o un testo appropriato. I campi specificano, in ordine (tra parentesi l&#8217;abbreviazione standard):<span id="line-44" class="anchor"></span></p>
<ul>
<li>minuti, da 0 a 59 («m»);<span id="line-45" class="anchor"></span></li>
<li>ore, da 0 a 23 («h»);<span id="line-46" class="anchor"></span></li>
<li>giorno del mese, da 1 a 31 («dom»);<span id="line-47" class="anchor"></span></li>
<li>mese, da 1 a 12 («mon»);<span id="line-48" class="anchor"></span></li>
<li>giorno della settimana, da 0 (domenica) a 6 (sabato) («dow»)</li>
</ul>
<p>&nbsp;</p>
<p class="line874">Quelle che seguono sono alcune varianti della precedente pianificazione d&#8217;esempio:<span id="line-77" class="anchor"></span><span id="line-78" class="anchor"></span></p>
<div>
<table>
<tbody>
<tr>
<td>
<p class="line891"><strong>Stringa</strong></p>
</td>
<td>
<p class="line891"><strong>Descrizione</strong></p>
</td>
</tr>
<tr>
<td>
<p class="line862">«12 03 * * *»</p>
</td>
<td>
<p class="line862">tutte le mattine, più o meno alle 3</p>
</td>
</tr>
<tr>
<td>
<p class="line862">« 12 03 15 * *»</p>
</td>
<td>
<p class="line862">tutti i 15 del mese, alla stessa ora</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«12 03 31 * *»</p>
</td>
<td>
<p class="line862">7 volte l&#8217;anno, alla stessa ora</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«0 12 * * 0»</p>
</td>
<td>
<p class="line862">ogni domenica, a mezzogiorno</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«2 0 * * *»</p>
</td>
<td>
<p class="line862">ogni giorno, più o meno a mezzanotte</p>
</td>
</tr>
<tr>
<td>
<p class="line862">«02 03 * * 1,5»</p>
</td>
<td>
<p class="line862">ogni lunedì e venerdì, alle 3 del mattino circa</p>
</td>
</tr>
</tbody>
</table>
<p>Altri esempi per aiutarvi a capire le varie combinazioni :</p>
<ul>
<li>Esempio 1</li>
</ul>
<pre>1-30 * * * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito ogni giorno, ogni ora e quando i minuti vanno da 1 a 30.</p>
<ul>
<li>Esempio 2</li>
</ul>
<pre>30 * 1-7 * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito i primi sette giorni di ogni mese, ad ogni ora e quando i minuti valgono 30.</p>
<ul>
<li>Esempio 3</li>
</ul>
<pre>00 */2 15 * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito il quindicesimo giorno di ogni mese, ogni due ore.</p>
<ul>
<li>Esempio 4</li>
</ul>
<pre>00 1-9/2 1 5 * /comando/da/eseguire
</pre>
<p>il comando viene eseguito il primo maggio alle 1,00 &#8211; 3,00 &#8211; 5,00 &#8211; 7,00 &#8211; 9,00. Cioè ogni due ore dalle 1,00 alle 9,00.</p>
<ul>
<li>Esempio 5</li>
</ul>
<pre>00 1-10/2 1 5 * /comando/da/eseguire
</pre>
<p>il comando viene eseguito il primo maggio alle 1,00 &#8211; 3,00 &#8211; 5,00 &#8211; 7,00 &#8211; 9,00. Cioè ogni due ore dalle 1,00 alle 10,00. Si noti come l&#8217;ultimo valore utile dell&#8217;intervallo non coincida, in questo caso, con l&#8217;ora in cui viene fatta partire l&#8217;ultima esecuzione giornaliera del comando.</p>
<ul>
<li>Esempio 6</li>
</ul>
<pre>00 13 2,8,14 * * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito il secondo, l&#8217;ottavo e il quattordicesimo giorno di ogni mese alle 13.00</p>
<ul>
<li>Esempio 7</li>
</ul>
<pre>30 13 1-15 4,10 * /comando/da/eseguire
</pre>
<p>il comando verrà eseguito i primi quindici giorni di aprile e ottobre alle 13,30.</p>
<ul>
<li>Esempio 8</li>
</ul>
<pre>*/30 13,20 * 1-7,9-12 1-5 /comando/da/eseguire
</pre>
<p>il comando verrà eseguito nei giorni feriali (da lunedì a venerdì) di tutti i mesi tranne agosto, alle 13,00 &#8211; 13,30 &#8211; 20,00 &#8211; 20,30.</p>
<ul>
<li>Esempio 9</li>
</ul>
<pre>00 14,19 1-15 * 5 /comando/da/eseguire
</pre>
<p>il comando verrà eseguito alle 14,00 e alle 19,00 dei primi quindici giorni di ogni mese e anche ogni venerdì.</p>
<p>** Ora per tornare al nostro esempio possiamo editare il file del nostro crontab tramite il comando</p>
<pre># crontab -e</pre>
<p>ed in base agli esempi appena visti la riga di configurazione per far si che lo script venga eseguito ogni 4 ore di ogni giorno dell&#8217;anno sara&#8217; la seguente :</p>
<pre># 00 */4 * * *  /usr/local/bin/adblock.sh</pre>
<p>una volta salvato ed usciti non rimarra&#8217; altro da fare che riavviare il servizio per far si che la modifica diventi operativa</p>
<pre># sudo /etc/init.d/cron restart</pre>
<p>per verificare che effettivamente la schedulazione sia stata inserita verifichiamo tramite il comando</p>
<pre># crontab -l</pre>
<p>Se doveste riscontrare problemi nella gestione della navigazione e voleste tornare alla configurazione iniziale vi bastera&#8217; rieditare il crontab eliminando la stringa inserita e ripristinare il file hosts iniziale di cui avevamo fatto il backup tramite il comando :</p>
<pre># sudo mv /etc/hosts.bak /etc/hosts</pre>
<p>Buon Anno!</p>
<p>#linuxadblocksenzaplugin</p>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/12/28/bloccare-la-pubblicita-senza-plug-in/feed/</wfw:commentRss>
			<slash:comments>4</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/12/adblock.jpg" medium="image">
			<media:title type="html">Linux Ad Block</media:title>
		</media:content>
	</item>
		<item>
		<title>Catturare il traffico di rete</title>
		<link>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/</link>
					<comments>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Wed, 06 Aug 2014 22:41:38 +0000</pubDate>
				<category><![CDATA[Load Balancing]]></category>
		<category><![CDATA[back-end]]></category>
		<category><![CDATA[bilanciamento]]></category>
		<category><![CDATA[carico]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[load balancing]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[opensource]]></category>
		<category><![CDATA[pound]]></category>
		<category><![CDATA[rinetd]]></category>
		<category><![CDATA[servizi]]></category>
		<category><![CDATA[url]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=281</guid>

					<description><![CDATA[Redirect fai da te Molte volte vi capitera&#8217; (ed a me e&#8217; capitato piu&#8217; volte) di aver bisogno di gestire il traffico di rete ottimizzandolo, filtrandolo e redirezionandolo. Si pensi, ad esempio, ai test di sviluppo effettuati sulle molte VM in cui si deve tenere conto della quantita&#8217; di Server interessati e del carico di &#8230; <a href="https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg"><img data-attachment-id="282" data-permalink="https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/redirect/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg" data-orig-size="252,200" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="redirect" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=252" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=252" class="alignleft size-full wp-image-282" src="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=600" alt="redirect" srcset="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg 252w, https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg?w=150 150w" sizes="(max-width: 252px) 100vw, 252px"   /></a>Redirect fai da te </strong></h3>
<p>Molte volte vi capitera&#8217; (ed a me e&#8217; capitato piu&#8217; volte) di aver bisogno di gestire il traffico di rete ottimizzandolo, filtrandolo e redirezionandolo.<br />
Si pensi, ad esempio, ai test di sviluppo effettuati sulle molte VM in cui si deve tenere conto della quantita&#8217; di Server interessati e del carico di rete da gestire bilanciando quest&#8217;ultimo e gestendo le porte interessate.</p>
<p>In questo articolo illustrero&#8217; alcuni dei migliori tra quelli da me usati in ambito OpenSource sono, <strong>Rinetd,</strong> <strong>LVS</strong> e <strong>Pound</strong>, ma l&#8217;elenco potrebbe ancora allungarsi, magari per un seguito.</p>
<p><strong>PARTIAMO</strong></p>
<p><strong>rinetd</strong></p>
<p>E&#8217; il piu&#8217; semplice dei tre, dunque partiremo da questo; esso permette di ridirigere una destinazione TCP, definita attraverso una coppia <em>&lt;indirizzo-ip&gt;</em>:<em>&lt;numero-di-porta&gt;</em>, presso un&#8217;altra coppia di questi valori. Lo scopo di questo può essere semplicemente quello di dirigere una porta locale verso un&#8217;altra porta locale, oppure si può arrivare a intercettare il traffico IP che attraversa un <em>router</em> in modo da ridirigere alcune coppie di indirizzi e porte presso altre destinazioni.</p>
<p>Tutto è composto semplicemente da un <em>daemon</em>, <b><code>rinetd</code></b>, che si avvale di un file di configurazione, <code>/etc/rinetd.conf</code>, nel quale si indicano semplicemente le ridirezioni da applicare.</p>
<p>La presenza in funzione di <b><code>rinetd</code></b> è incompatibile con altri <em>daemon</em> che stanno in ascolto delle stesse porte che devono essere ridirette, anche se queste sono intese appartenere a <em>host</em> differenti.</p>
<p>Il programma rinetd è il demone che si occupa di ridirigere il traffico TCP in base a quanto contenuto nel file di configurazione <code class="file">/etc/rinetd.conf<br />
E' sufficiente avviarlo e, se il file di configurazione risultera'corretto, iniziare subito a lavorarci. All'avvio, dopo aver letto la configurazione, rinetd deve poter stare in ascolto dell'indirizzo da ridirigere e della porta relativa; qualunque sia l'indirizzo in questione, è necessario che non ci sia già un programma locale che fa la stessa cosa su quella stessa porta; per esempio, non si può tentare di ridirigere il servizio HTTP di un indirizzo qualunque, se questo è presente localmente.</code></p>
<p>Un esempio di configurazione del file rinetd.conf dovrebbe essere sufficiente a chiarire le idee su questo file. Supponiamo di voler dirottare il traffico diretto verso l&#8217;indirizzo IP 10.11.12.13 alla porta 80, in modo che questo vada verso l&#8217;indirizzo IP 192.168.1.7, alla porta 80.</p>
<pre>120.121.122.123 80 192.168.1.7 80</pre>
<p>L&#8217;indirizzo da ridirigere, può appartenere a un&#8217;interfaccia del nodo presso cui si trova in funzione il demone rinetd,<br />
oppure no, purché i pacchetti diretti a tale indirizzo transitino attraverso il nodo che attua la ridirezione.<br />
Se si vuole apprendere il funzionamento di rinetd senza disporre di una rete vera e propria, basta una direttiva di configurazione simile a quella seguente:</p>
<pre>localhost 8888 localhost html</pre>
<p>In questo modo, la porta locale 8888 viene ridiretta sulla porta del servizio HTTP (80). Se il servizio HTTP è attivo, si può verificare la ridirezione con un programma di navigazione qualunque, puntando all&#8217;URL</p>
<pre>http://localhost:8888</pre>
<p>Rispetto ai prossimi due tool rinetd non e&#8217; in grado di fungere anche come LoadBalancer.</p>
<hr />
<p><strong>ipvsadm</strong></p>
<p>Questo servizio aggiorna la tabella d&#8217;instradamento IPVS nel kernel. Il demone <strong><code class="command">lvs</code></strong> imposta e gestisce Load Balancer Add-On richiamando <strong><code class="command">ipvsadm</code></strong> per aggiungere, modificare e cancellare le voci all&#8217;interno della tabella d&#8217;instradamento IPVS. Inoltre ipvsadm fa parte del paccheto LVS  che è una soluzione di bilanciamento del carico avanzato per sistemi Linux.<br />
Si tratta di un progetto open source avviato da Wensong Zhang nel lontano 1998. La missione del progetto è di costruire un server ad alte prestazioni e ad alta disponibilità per Linux utilizzando tecnologie di clustering, offrendo una buona scalabilità, affidabilità e facilità di manutenzione. L’opera principale del progetto LVS è ora quello di sviluppare un software avanzato di bilanciamento del carico IP (IPVS), ed un software di bilanciamento a livello dell’applicazione (KTCPVS), ed i componenti di gestione dei cluster.</p>
<h3>Ipvs in pratica</h3>
<p>IPVS (IP Virtual Server) implementa un bilanciatore di carico a livello Layer 4 della rete. IPVS in esecuzione su un host si comporta come un sistema di bilanciamento del carico di fronte ad un insieme di server reali in cluster, può indirizzare le richieste per servizi basati si TCP/UDP ai veri server, e fa apparire i servizi dei server reali come un unico servizio virtuale su un unico indirizzo IP.</p>
<p>La componente IPVS è presente in tutti i recenti Kernel, per installare la componente in user-space utilizzate il vostro gestore di pacchetti, ad esempio in Ubuntu:</p>
<pre>aptitude install ipvsadm</pre>
<p>a questo punto si può creare uno script da far avviare al boot. Io di solito inserisco i comandi all’interno del file<br />
<strong>/etc/rc.local</strong>.</p>
<div>Prima di tutto dobbiamo <em>resettare</em> l’attuale configurazione con il comando:</div>
<pre>ipvsadm -C</pre>
<div>Dopodiché iniziamo a dare le regole con i comandi come nell’esempio qui sotto in cui diciamo che le chiamate TCP (parametro -t) all’indirizzo 192.168.10.100 sulla porta 5060 (quella per il protocollo SIP) debbano essere inoltrate alla stessa porta dell’indirizzo 192.168.10.250.  Per reindirizzare una chiamata UDP sostituire il -t con -u.</div>
<pre>ipvsadm -A -t 192.168.10.100:5060 -s rr</pre>
<p>ipvsadm -a -t 192.168.10.100:5060 -r 192.168.10.250:5060 -m</p>
<div id="_mcePaste">Naturalmente è possibile catturare il traffico su una porta e inoltrarla ad un’altra con un comando tipo questo:</div>
<div>ipvsadm -A -t 192.168.10.100:88 -s rr</div>
<div>ipvsadm -a -t 192.168.10.100:88 -r 192.168.10.250:80 -m</div>
<div>In questo caso non abbiamo fatto altro che prendere le chiamate alla porta 88 dell’indirizzo 192.168.10.100 e rinviarle al server web dell’IP 192.168.10.250 sulla normale porta 80</div>
<p><strong>Metodi di bilanciamento utilizzati da LVS</strong></p>
<p>In caso si desideri testare il funzionamento di <strong>LVS</strong> senza la necessita&#8217; di monitorare i servizi e possibile aggiungere e rimuovere nodi con il comando <code>ipvsadm</code>:<br />
<code><br />
ipvsadm -C<br />
ipvsadm -A -t 10.2.1.164:8080 -s lc<br />
ipvsadm -a -t 10.2.1.164:8080 -r 10.2.1.166 -g<br />
ipvsadm -a -t 10.2.1.164:8080 -r 10.2.1.165 -g<br />
</code><br />
Le opzioni utilizzate nelle linee di comando di ipvsadm per l&#8217;esempio riportato sono le seguenti:</p>
<p>&#8211; <strong>-C</strong>, <strong>&#8211;clear</strong>: cancella la tabella del virtual server.<br />
&#8211; <strong>-A</strong>, <strong>&#8211;add-service</strong>: crea un servizio virtuale.<br />
&#8211; <strong>-a</strong>, <strong>&#8211;add-server</strong>: aggiunge un nodo ad un servizio virtuale.<br />
&#8211; <strong>-t</strong>, <strong>&#8211;tcp-service</strong>: specifica indirizzo ip e numero di porta tcp del servizio virtuale.<br />
&#8211; <strong>-s</strong>, <strong>&#8211;scheduler</strong>: specifica l&#8217;algoritmo di bilanciamento<br />
&#8211; <strong>-r</strong>, <strong>&#8211;real-server</strong>: specifica l&#8217;indirizzo ip del nodo reale<br />
&#8211; <strong>-g</strong>, <strong>&#8211;gatewaying</strong>: indica il metodo di forwarding direct routing (<strong>LVS-DR</strong>)</p>
<p><strong>** algoritmi per il bilanciamento che possiamo usare con LVS</strong>.</p>
<p><strong>Statici</strong>:</p>
<p>&#8211; Round Robin</p>
<p>&#8211; Weighted Round Robin</p>
<p>&#8211; Destination Hashing</p>
<p>&#8211; Source Hashing</p>
<p><strong>Dinamici</strong>:</p>
<p>&#8211; Least-Connection</p>
<p>&#8211; Weighted least-connection</p>
<p>&#8211; Never queue</p>
<p>&#8211; Locality-based least-connection</p>
<p>&#8211; Locality-based least-connection with replication scheduling</p>
<p>&#8211; Shortest expected delay</p>
<hr />
<p><strong>pound<br />
</strong></p>
<p>Pound è un proxy server di bilanciamento del carico inverso. Accetta richieste da HTTP / HTTPS clienti e li distribuisce a uno o più server web. Le richieste HTTPS vengono decifrati e passati al back-end come semplice protocollo HTTP.</p>
<p>Se più di un server back-end è definita, Pound sceglie uno di loro a caso, sulla base delle priorità definite. Per impostazione predefinita, Pound tiene traccia di associazioni tra client e server back-end (sessioni).</p>
<p>General Principles</p>
<p>In generale, Pound ha bisogno di tre tipi di oggetti definiti, al fine di funzione: ascoltatori , i servizi e back-end .</p>
<p><strong>Ascoltatori</strong><br />
Un ascoltatore è una definizione di come Pound riceve le richieste dai client (browser). Due tipi di ascoltatori può essere definito: normale connessione HTTP ascoltatori e HTTPS (HTTP su SSL / TLS) ascoltatori . Per lo meno un ascoltatore deve definire l&#8217;indirizzo e la porta per l&#8217;ascolto su, con ulteriori requisiti per HTTPS ascoltatori .</p>
<p><strong>Servizi</strong><br />
Un servizio è la definizione di come le domande trovano risposta. Il servizio può essere definito all&#8217;interno di un ascoltatore o al livello superiore (globale). Quando viene ricevuta una richiesta Pound tenta di far corrispondere a ciascun servizio , a sua volta, a partire dai servizi definiti nel ascoltatore stesso e, se necessario, di proseguire con l&#8217; servizi definiti a livello globale. I servizi possono definire le proprie condizioni al quale le domande si può rispondere: in genere si tratta certo URL (solo foto, o un certo percorso) o intestazioni specifiche (come ad esempio l&#8217;intestazione Host). Un servizio può anche definire una sessione meccanismo: se definito le richieste future da un determinato cliente sarà sempre la stessa risposta da parte di back-end .</p>
<p><strong>Back-end</strong><br />
Il back-end sono i server reale per il contenuto richiesto. Di per sé, Pound fornisce nessuna risposta &#8211; tutti i contenuti devono essere ricevuti da un vero e proprio &#8220;web server&#8221;. Il back-end definisce come il server dovrebbe essere contattato.</p>
<p>Tre tipi di back-end può essere definito: un &#8220;regolare&#8221; back-end che riceve le richieste e le risposte restituisce, un &#8220;redirect&#8221; back-end in questo caso, Pound risponde con una risposta redirect, senza l&#8217;accesso a qualsiasi back-end a tutti , o una &#8220;emergenza&#8221; back-end che sarà usato solo se tutti gli altri backend sono &#8220;morti&#8221;.</p>
<p>Multiple back-end può essere definito all&#8217;interno di un servizio , nel qual caso Pound sarà bilanciamento del carico tra i disponibili back-end .</p>
<p>Se un back-end non riesce a rispondere, sarà considerato &#8220;morto&#8221;, nel qual caso Pound si ferma l&#8217;invio di richieste ad esso. Dead indietro _ e NDS sono periodicamente controllate per la disponibilità, e una volta che rispondono ancora sono &#8220;resurected&#8221; e le richieste sono inviati di nuovo la loro strada. Se non back-end sono disponibili (nessuno è stato definito, o sono tutti &#8220;morti&#8221;), allora Pound risponderà con &#8220;503 Servizio non disponibile&#8221;, senza verificare ulteriori servizi .</p>
<p>Il collegamento tra Pound e il back end- è sempre via HTTP, a prescindere dal protocollo utilizzato tra Pound e il cliente.</p>
<p><strong>Installazione </strong></p>
<pre>sudo apt-get install pound</pre>
<p>La gestione completa del servizio avviene tramite la configurazione del file <strong>/etc/pound/pound.cfg</strong><br />
<strong>Esempio 1:</strong></p>
<p><strong>Semplice configurazione HTTP Proxy </strong><br />
Supponiamo di forwardare le richieste http che arrivano dall”IP pubblico 202.54.10.5 all’IP sulla LAN 192.168.1.5 su cui è configurato un web server Apache sulla porta 8080.<br />
Editiamo il file di configurazione di pound di una distro Debian/Ubuntu:</p>
<p>vim /etc/pound/pound.cfg</p>
<p>Questo è l’aspetto del file:</p>
<pre>ListenHTTP
Address  202.54.10.5
Port          80
Service
BackEnd
Address  192.168.1.5
Port           8080
End
End
End</pre>
<p>Salvare e chiudere il file e restartare Pound:</p>
<p>/etc/init.d/pound restart</p>
<p><strong>Esempio 2</strong><br />
<strong>Semplice configurazione HTTP &amp; HTTPS Proxy<br />
</strong>In questo esempio vediamo come “proxare” una richiesta http e https dallo stesso IP pubblico 202.54.10.5 a due web server 192.168.1.5 e 192.168.1.6, entrambi sulla porta 80:</p>
<pre>ListenHTTP
Address  202.54.10.5
Port          80
End

ListenHTTPs
Address   202.54.10.5
Port           443
Cert           “/etc/ssl/local.server.pem” -–&gt;percorso certificato ssl
End

Service
BackEnd
Address     192.168.1.5
Port              80
Priority       1
Backend
Address     192.168.1.6
Port              80
Priority       3
End
End</pre>
<p>Salviamo il file di configurazione e restartiamo pound.</p>
<p>In questo esempio le richieste alla porta 80 all’ ip 202.54.10.5  vengono inoltrate alla porta 80 del webserver 192.168.1.5, mentre le richieste alla porta 443 dall’ ip 202.54.10.5 vengono inoltrate alla porta 80 del web server 192.168.1.6  e in questo caso pound gestisce il certificato ssl, che è possibile generarsi senza alcuna modifica nel backend del web server, che continua a gestire chiamate in http.</p>
<p><strong>PS:</strong> e&#8217; possibile inoltre impostare una priorità di inoltro del traffico differente, nel caso si disponga di più server web, cosi&#8217; come indicato dalla voce &#8220;Priority&#8221; presente nella configurazione del secondo esempio; minore è la cifra, maggiore sarà la priorità assegnata al server.</p>
<p>Buon divertimento !</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/08/06/catturare-il-traffico-di-rete/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/08/redirect.jpeg" medium="image">
			<media:title type="html">redirect</media:title>
		</media:content>
	</item>
		<item>
		<title>Grafici di rete con Vnstat</title>
		<link>https://tuttiperlinux.blog/2014/08/01/238/</link>
					<comments>https://tuttiperlinux.blog/2014/08/01/238/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Fri, 01 Aug 2014 17:59:15 +0000</pubDate>
				<category><![CDATA[Networking]]></category>
		<category><![CDATA[apache]]></category>
		<category><![CDATA[banda]]></category>
		<category><![CDATA[ip link]]></category>
		<category><![CDATA[linux]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[monitoring]]></category>
		<category><![CDATA[php frontend]]></category>
		<category><![CDATA[rete]]></category>
		<category><![CDATA[vnstat]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=238</guid>

					<description><![CDATA[Controllare la banda Sui server, come sui PC, è utile monitorare e raccogliere dati circa l’utilizzo della banda di rete. E&#8217; possibile utilizzare vnstat per avere un monitoraggio in tempo reale della banda; questo piccolo programma ha qualcosa in più degli altri, oltre a mostrare statistiche in tempo reale, la caratteristica in cui brilla questo piccolo programma &#8230; <a href="https://tuttiperlinux.blog/2014/08/01/238/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<h3><strong><a href="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png"><img loading="lazy" data-attachment-id="242" data-permalink="https://tuttiperlinux.blog/2014/08/01/238/vnstat-php-frontend-screenshots/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png" data-orig-size="593,424" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="vnstat-php-frontend-screenshots" data-image-description="" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png?w=300" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png?w=593" class="alignleft size-medium wp-image-242" src="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png?w=300&#038;h=214" alt="vnstat-php-frontend-screenshots" width="300" height="214" srcset="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png?w=300&amp;h=214 300w, https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png?w=150&amp;h=107 150w, https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png 593w" sizes="(max-width: 300px) 100vw, 300px" /></a></strong></h3>
<h3><strong>Controllare la banda</strong></h3>
<p>Sui server, come sui PC, è utile monitorare e raccogliere dati circa l’utilizzo della banda di rete. E&#8217; possibile utilizzare <strong>vnstat</strong> per avere un monitoraggio in tempo reale della banda; questo piccolo programma ha qualcosa in più degli altri, oltre a mostrare statistiche in tempo reale, la caratteristica in cui brilla questo piccolo programma è la sua capacità di raccogliere dati su un lungo periodo di tempo. <code>vnstat </code>è un monitor di traffico di rete basata su console per Linux e BSD che mantiene un log del traffico di rete per l’interfaccia/e che gli indicherete nel file di conf. Utilizza le statistiche dell’interfaccia di rete fornite dal kernel come fonte di informazioni, ciò significa che vnstat non sta effettivamente sniffando il traffico, inoltre assicura anche un basso impatto sull’uso delle risorse di sistema.</p>
<p>In Linux, è richiesto almeno un kernel della serie 2.2, che vuol dire che tutti oggigiorno sono in grado di utilizzare questo piccolo programma.</p>
<p>Il programma è open source/GPL e può essere utilizzato sia come root che come utente non privilegiato.</p>
<p><strong>INSTALLAZIONE</strong></p>
<pre>sudo apt-get install vnstat
                     vnstati
                     apache2
                     php5
                     php5-gd
</pre>
<h3>Primo setup</h3>
<p>Durante la prima esecuzione è necessario inizializzare ogni interfaccia che desiderate registrare su vnstat. Ad esempio per una interfaccia cablata con cavo di rete è necessario utilizzare il comando:</p>
<div class="wp_syntax">
<table>
<tbody>
<tr>
<td class="code">
<pre># vnstat -u -i eth0</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>o per una interfaccia wireless:</p>
<div class="wp_syntax">
<table>
<tbody>
<tr>
<td class="code">
<pre># vnstat -u -i wlan0</pre>
</td>
</tr>
</tbody>
</table>
</div>
<p>Quando si inizializza una interfaccia per la prima volta ci potrà essere un messaggio di errore che stamperà ‘unable to read database’. Se questo messaggio è seguito da un messaggio di informazioni che dice ‘a new database has been created’ l’interfaccia è stata aggiunta con successo.<br />
Se questo non accade verificare che l’interfaccia specificata sia valida.</p>
<p>Per vedere tutte le interfacce del vostro sistema Linux, è possibile utilizzare il comando</p>
<div class="wp_syntax">
<table>
<tbody>
<tr>
<td class="code">
<pre> ip link show</pre>
</td>
</tr>
</tbody>
</table>
</div>
<pre> ... ora scarichiamo il pacchetto vnstat_php_frontend nel seguente modo :</pre>
<pre># cd /tmp
# wget http://www.sqweek.com/sqweek/files/vnstat_php_frontend-1.5.1.tar.gz</pre>
<pre class="bash">scompattiamolo nel percorso dei file di Apache ( /var/www/html )</pre>
<pre># sudo tar zxvf vnstat_php_frontend-1.5.1.tar.gz -C /var/www/html/</pre>
<p>a questo punto non rimane altro che spostarci nel percorso sopra indicato in cui potremo trovare la nuova directory<br />
# cd /var/www/html<br />
** rinominiamo x maggiore comodita&#8217; da &#8220;vnstat_php_frontend-1.5.1&#8221; a semplicemente vnstat<br />
# sudo mv vnstat_php_frontend-1.5.1 vnstat</p>
<p>&#8230;. spostiamoci all&#8217;interno della Directory vnstat ed andiamo a fare alcune veloci modifiche che ci permetteranno di diventare subito operativi.</p>
<p># cd vnstat<br />
&#8230;effettuiamo come consuetudine un backup del file config.php prima di fare qualunque modifica<br />
# cp config.php config.php.bck</p>
<p>ora possiamo passare ad editare il file in questione e ad apportare le seguenti modifiche :<br />
# vim config.php</p>
<pre>*** modifichiamo nel seguente modo
$locale = 'en_US.UTF-8';
$language = '<strong>en</strong>';</pre>
<pre>$iface_list = array('<strong>eth0</strong>', '<strong>eth1</strong>'); # nel mio caso ho modificato le interfacce con la mia <strong>wlan0 

</strong></pre>
<pre>$iface_title['wlan0'] = '<strong>Internal</strong>';
// $iface_title['eth1'] = '<strong>External</strong>'; # se non avete due o piu' interfacce da monitorare potete commentarla</pre>
<p>&#8230;salvate ed uscite dal file; a questo punto bastera&#8217; puntare il browser all&#8217;URL</p>
<pre>http://localhost/vnstat/
</pre>
<p>&nbsp;</p>
<pre class="bash">da qui in avanti potrete tenere sotto controllo i consumi della/e vostra interfaccia di rete (ora,giorno,mese).</pre>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/08/01/238/feed/</wfw:commentRss>
			<slash:comments>1</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/08/vnstat-php-frontend-screenshots.png?w=300" medium="image">
			<media:title type="html">vnstat-php-frontend-screenshots</media:title>
		</media:content>
	</item>
		<item>
		<title>Introduzione a CouchDB</title>
		<link>https://tuttiperlinux.blog/2014/07/26/introduzione-a-couchdb/</link>
					<comments>https://tuttiperlinux.blog/2014/07/26/introduzione-a-couchdb/#comments</comments>
		
		<dc:creator><![CDATA[Tutti per Linux]]></dc:creator>
		<pubDate>Sat, 26 Jul 2014 13:46:49 +0000</pubDate>
				<category><![CDATA[DB]]></category>
		<category><![CDATA[WebServer]]></category>
		<category><![CDATA[apache]]></category>
		<category><![CDATA[api]]></category>
		<category><![CDATA[couchdb]]></category>
		<category><![CDATA[crud]]></category>
		<category><![CDATA[database]]></category>
		<category><![CDATA[futon]]></category>
		<category><![CDATA[http]]></category>
		<category><![CDATA[localhost]]></category>
		<category><![CDATA[nosql]]></category>
		<category><![CDATA[peer-to-peer]]></category>
		<category><![CDATA[postgresql]]></category>
		<category><![CDATA[restful]]></category>
		<category><![CDATA[tuple]]></category>
		<guid isPermaLink="false">http://tuttiperlinux.wordpress.com/?p=213</guid>

					<description><![CDATA[CouchDB e&#8217; un database documentale NoSQL disponibile con l&#8217;ampia licenza Apache. Apache CouchDB e&#8217; un moderno documentale richiamabile semplicemente con l&#8217;HTTP e che al tempo stesso offre le piu&#8217; avanzate funzionalita&#8217; di replicazione dati e di ricerca in parallelo (Map/Reduce). CouchDB (acronimo di Cluster Of Unreliable Commodity Hardware) e&#8217; uno dei piu&#8217; diffusi DB documentali &#8230; <a href="https://tuttiperlinux.blog/2014/07/26/introduzione-a-couchdb/">Continua a leggere <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><b><a href="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png"><img data-attachment-id="214" data-permalink="https://tuttiperlinux.blog/2014/07/26/introduzione-a-couchdb/couch/#main" data-orig-file="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png" data-orig-size="160,112" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;}" data-image-title="couchDB" data-image-description="&lt;p&gt;Performing Web DB&lt;/p&gt;
" data-image-caption="" data-medium-file="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=160" data-large-file="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=160" class="alignleft size-full wp-image-214" src="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=600" alt="couchDB" srcset="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png 160w, https://tuttiperlinux.files.wordpress.com/2014/07/couch.png?w=150 150w" sizes="(max-width: 160px) 100vw, 160px"   /></a>CouchDB</b> e&#8217; un database documentale NoSQL disponibile con l&#8217;ampia licenza Apache.<br />
Apache CouchDB e&#8217; un moderno documentale richiamabile semplicemente con l&#8217;HTTP e che al tempo stesso offre le piu&#8217; avanzate funzionalita&#8217; di replicazione dati e di ricerca in parallelo (Map/Reduce).</p>
<p>CouchDB (acronimo di Cluster Of Unreliable Commodity Hardware) e&#8217; uno dei piu&#8217; diffusi DB documentali Web grazie alla sua velocita&#8217;, alla flessibilita, alla semplicita&#8217; di utilizzo ed al&#8230; prezzo!</p>
<h2>Installazione</h2>
<p>Installare CouchDB e cURL (che serve per accedere) e&#8217; facile su Linux (eg. RedHat, Fedora, CentOS, Scientific Linux, &#8230;):</p>
<div class="video"><b>yum install couchdb curl -y</b></div>
<div class="video">oppure</div>
<div class="video"><strong>sudo aptitude install couchdb curl</strong></div>
<div class="video"></div>
<div class="video">Ora bisogna far partire il server CouchDB con il comando <b>couchdb</b>. Per verificare se funziona tutto basta un comando:</div>
<div class="video"># <b>curl <a href="http://127.0.0.1:5984" rel="nofollow">http://127.0.0.1:5984</a><br />
</b>{&#8220;couchdb&#8221;:&#8221;Welcome&#8221;,&#8221;uuid&#8221;:&#8221;fd91d8b7b77c7f6d75d5937326a95ad2&#8243;,&#8221;version&#8221;:&#8221;1.5.0&#8243;,&#8221;vendor&#8221;:{&#8220;version&#8221;:&#8221;14.04&#8243;,&#8221;name&#8221;:&#8221;Ubuntu&#8221;}}<b><br />
</b></div>
<p>CouchDB e&#8217; disponibile per tutti i sistemi UNIX-based ed anche sulle piattaforme MS-Windows e Mac OS X. Installare le versioni precedenti di CouchDB non era cosi&#8217; semplice: bisognava partire dall&#8217;installazione del linguaggio di programmazione Erlang e ricompilare&#8230;</p>
<h2>Utilizzo</h2>
<p>CouchDB e&#8217; accessibile esclusivamente attraverso un HTTP-based RESTful API, cio&#8217; significa che, anziche&#8217; collegarsi al DB server utilizzando un&#8217;applicazione client per interagire con il sistema, basta utilizzare un software in grado di interagire con un HTTP server web per fare richieste. CouchDB che a sua volta eseguira&#8217; le azioni nel database, restituendo una risposta appropriata quando finito.<br />
Quindi e&#8217; possibile gestire il database semplicemente visitando gli URL nel browser web oppure utilizzando gli strumenti da riga di comando come curl o, cosa piu&#8217; importante, attraverso qualsiasi linguaggio di programmazione che supporta richieste HTTP.<br />
L&#8217;implementazione dell&#8217;interfaccia REST (Representational Transfer State) su CouchDB e&#8217; molto completa poiche&#8217; non si limita al CRUD (CREATE, READ, UPDATE, DELETE) ma ogni operazione svolta su CouchDB e&#8217; richiamabile con l&#8217;HTTP.</p>
<h3>Futon</h3>
<p>CouchDB possiede una sua interfaccia web molto user friendly, Futon, dalla quale e&#8217; possibile eseguire qualsiasi operazione per la gestione di un database, come l&#8217;inserimento, la visualizzazione, la modifica e la cancellazione dei dati. Inoltre <strong>Futon</strong> contiene anche le principali funzionalita&#8217; di amministrazione di un database, come le impostazioni di configurazione, la replicazione dei dati, definizione dei ruoli e privilegi e uno strumento di testing.<br />
Per accedere all&#8217;interfaccia web basta collegarsi da browser a <b>localhost:5984/_utils</b></p>
<h3>cURL</h3>
<p>Per i piu&#8217; affezionati alla linea di comando (come me per esempio), si puo&#8217; usare curl, un ottimo tool utile per trasferire dati da/a un server utilizzando vari protocolli, tra cui HTTP, HTTPS, FTP. Il modo per farlo e&#8217; digitando:</p>
<pre><i>curl &lt;opzioni&gt; &lt;ip_host&gt;:5984/&lt;database&gt;/&lt;record&gt;</i>.</pre>
<p>Da notare che nel URL viene specificata la porta 5984, e&#8217; quella usata dal processo di couchdb.<br />
Tra le opzioni piu&#8217; importanti: <b>-X</b> per specificare il tipo di richiesta http: <b>GET</b> per richiedere dati, <b>PUT</b> e <b>POST</b> per modificare dati o <b>DELETE</b> per cancellare. Inoltre <b>-d</b> permette di specificare i dati da includere nella richiesta, ad esempio per modificare documenti nel database.<br />
Esempi:</p>
<pre># Crea il database "libri"
curl -X PUT http://127.0.0.1:5984/libri

# Visualizza il contenuto di "libri" (all'inizio e' vuoto)
curl -X GET http://127.0.0.1:5984/libri

# Crea il documento con _id "lafineeilmioinizio" dentro il database "libri"
curl -X PUT http://127.0.0.1:5984/libri/lafineeilmioinizio \
 -d '{"titolo":"La fine e il mio inizio", "autore":"Tiziano Terzani", 
      "casa_editrice":"Longanesi", "prezzo":"18.60"}'

# NB: Tutte le volte che un documento viene modificato riceve un revision number
# Modifica un documento aggiungendo come allegato un'immagine
curl -X PUT http://127.0.0.1:5984/libri/lafineeilmioinizio/cover.jpg?rev=1-XXX \
 --data-binary @images/budda.jpg -H "Content-Type: image/jpg"

# Crea un documento hungergames copiando il contenuto da un altro documento
curl -X COPY http://127.0.0.1:5984/libri/lafineeilmioinizio -H "Destination: hungergames"

# Cancella il documento con _id "hungergames"
curl -X DELETE http://127.0.0.1:5984/libri/hungergames?rev=1-YYY 

# Effettua un caricamento massivo di documenti da file
curl -X POST http://127.0.0.1:5984/libri/_bulk_docs -H "Content-type: application/json" -d @biblio.json

# Visualizza tutto il contenuto del database "libri" e il dettaglio dei documenti presenti
curl -X GET http://127.0.0.1:5984/libri/_all_docs?include_docs=true

</pre>
<h2>Architettura</h2>
<p>CouchDB e&#8217; un database document-oriented. Cio&#8217; significa che a differenza dei piu&#8217; tradizionali DBMS (Database Management System) relazionali come Oracle e PostgreSQL, i dati non vengono memorizzati in tabelle (o se volete, relazioni), ma in &#8220;documenti&#8221;.</p>
<p>Su un database relazionale le tabelle hanno una struttura rigida, sono composte da campi definiti prima della effettiva memorizzazione dei dati. Le tabelle vanno dichiarate con gli opportuni statement DDL, prima di essere utilizzate. Ogni tabella e&#8217; composta da tuple (ovvero le righe della tabella o i record) che contengono i dati. La gestione dei dati si effettua con statement DML. I comandi DDL e DML della stragrande maggioranza dei DB relazionali sono in SQL. Ora dimentichiamoci tutto questo&#8230;</p>
<p>In CouchDB il concetto di relazione o di tabella non esiste, l&#8217;elemento fondamentale e&#8217; il documento che contiene al suo interno tutti i dati relativi, organizzati in modo eterogeneo. Si possono aggiungere e modificare i campi anche dopo l&#8217;effettivo inserimento dei dati. In questo modo record appartenenti alla stessa categoria di informazioni possono avere campi diversi tra di loro. La chiave primaria dei database relazionali viene tradotta nel campo univoco <i>_id</i> di CouchDB, creato automaticamente dall&#8217;engine del DBMS (ma che e&#8217; anche possibile indicare in modo esplicito.</p>
<p>Dal punto di vista del sistema operativo CouchDB si presenta come un unico processo beam.smp in ascolto sulla porta TCP 5984 (6984 se e&#8217; abilitato l&#8217;HTTPS). In realta&#8217; all&#8217;interno del processo operano diversi thread con compiti specifici.<br />
I file utilizzati da CouchDB su Linux si trovano in /etc/couchdb, i file di database su /var/lib/couchdb, i log su /var/log/couchdb.</p>
<h3><strong>Consistenza dei dati e replicazione</strong></h3>
<p>CouchDB non utilizza alcun meccanismo di locking ma sfrutta l&#8217;MVCC (Multiversion Concurrency Control), ogni modifica di un oggetto ne crea una nuova versione. Le versioni precedenti non vengono cancellate. Se due modifiche vanno in conflitto poiche&#8217; accedono allo stesso documento, la seconda riceve un errore in save. L&#8217;applicazione deve riprendere l&#8217;ultima versione del documento e rieseguire l&#8217;UPDATE.<br />
L&#8217;isolamento e&#8217; mantenuto solo a livello di un singolo documento, questa e&#8217; una notevole semplificazione, rispetto alla complessa logica transazionale di altri database, ma consente l&#8217;ottimizzazione, la parallelizzazione e la distribuzione dei dati in modo semplice. A livello di accesso al file di dati ogni singola modifica ad un documento rispetta le proprieta ACID (Atomic Consistent Isolated Durable) con la serializzazione delle modifiche sui documenti e la scrittura sincrona sul disco.</p>
<p>Piu&#8217; database CouchDB possono essere collegati tra loro in modo molto semplice. I database vengono aggiornati tra loro con una replicazione peer-to-peer incrementale implementata nativamente nell&#8217;engine. CouchDB permette una replicazione bidirezionale asincrona, utilizza un meccanismo automatico di risoluzione dei conflitti e fornisce una <b>eventual consistency</b> tra i database. Se i database sono ospitati su nodi differenti si ottiene con questo la distribuzione dei dati.<br />
La replicazione di CouchDB puo&#8217; essere utilizzata sia per sincronizzare database locali che per complesse configurazioni con sharding dei dati.</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://tuttiperlinux.blog/2014/07/26/introduzione-a-couchdb/feed/</wfw:commentRss>
			<slash:comments>2</slash:comments>
		
		
		
		<media:content url="https://2.gravatar.com/avatar/855ab7cb725a5b56c356471b79d1cef6?s=96&#38;d=&#38;r=G" medium="image">
			<media:title type="html">lordisil72lordisil72</media:title>
		</media:content>

		<media:content url="https://tuttiperlinux.files.wordpress.com/2014/07/couch.png" medium="image">
			<media:title type="html">couchDB</media:title>
		</media:content>
	</item>
	</channel>
</rss>
